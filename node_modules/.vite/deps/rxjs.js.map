{
  "version": 3,
  "sources": ["../../rxjs/src/internal/scheduler/performanceTimestampProvider.ts", "../../rxjs/src/internal/scheduler/animationFrameProvider.ts", "../../rxjs/src/internal/observable/dom/animationFrames.ts", "../../rxjs/src/internal/util/Immediate.ts", "../../rxjs/src/internal/scheduler/immediateProvider.ts", "../../rxjs/src/internal/scheduler/AsapAction.ts", "../../rxjs/src/internal/scheduler/AsapScheduler.ts", "../../rxjs/src/internal/scheduler/asap.ts", "../../rxjs/src/internal/scheduler/QueueAction.ts", "../../rxjs/src/internal/scheduler/QueueScheduler.ts", "../../rxjs/src/internal/scheduler/queue.ts", "../../rxjs/src/internal/scheduler/AnimationFrameAction.ts", "../../rxjs/src/internal/scheduler/AnimationFrameScheduler.ts", "../../rxjs/src/internal/scheduler/animationFrame.ts", "../../rxjs/src/internal/scheduler/VirtualTimeScheduler.ts", "../../rxjs/src/internal/util/isObservable.ts", "../../rxjs/src/internal/lastValueFrom.ts", "../../rxjs/src/internal/firstValueFrom.ts", "../../rxjs/src/internal/observable/bindCallbackInternals.ts", "../../rxjs/src/internal/observable/bindCallback.ts", "../../rxjs/src/internal/observable/bindNodeCallback.ts", "../../rxjs/src/internal/observable/defer.ts", "../../rxjs/src/internal/observable/connectable.ts", "../../rxjs/src/internal/observable/forkJoin.ts", "../../rxjs/src/internal/observable/fromEvent.ts", "../../rxjs/src/internal/observable/fromEventPattern.ts", "../../rxjs/src/internal/observable/generate.ts", "../../rxjs/src/internal/observable/iif.ts", "../../rxjs/src/internal/observable/merge.ts", "../../rxjs/src/internal/observable/never.ts", "../../rxjs/src/internal/observable/pairs.ts", "../../rxjs/src/internal/observable/partition.ts", "../../rxjs/src/internal/observable/range.ts", "../../rxjs/src/internal/observable/using.ts"],
  "sourcesContent": ["import { TimestampProvider } from '../types';\r\n\r\ninterface PerformanceTimestampProvider extends TimestampProvider {\r\n  delegate: TimestampProvider | undefined;\r\n}\r\n\r\nexport const performanceTimestampProvider: PerformanceTimestampProvider = {\r\n  now() {\r\n    // Use the variable rather than `this` so that the function can be called\r\n    // without being bound to the provider.\r\n    return (performanceTimestampProvider.delegate || performance).now();\r\n  },\r\n  delegate: undefined,\r\n};\r\n", "import { Subscription } from '../Subscription';\r\n\r\ninterface AnimationFrameProvider {\r\n  schedule(callback: FrameRequestCallback): Subscription;\r\n  requestAnimationFrame: typeof requestAnimationFrame;\r\n  cancelAnimationFrame: typeof cancelAnimationFrame;\r\n  delegate:\r\n    | {\r\n        requestAnimationFrame: typeof requestAnimationFrame;\r\n        cancelAnimationFrame: typeof cancelAnimationFrame;\r\n      }\r\n    | undefined;\r\n}\r\n\r\nexport const animationFrameProvider: AnimationFrameProvider = {\r\n  // When accessing the delegate, use the variable rather than `this` so that\r\n  // the functions can be called without being bound to the provider.\r\n  schedule(callback) {\r\n    let request = requestAnimationFrame;\r\n    let cancel: typeof cancelAnimationFrame | undefined = cancelAnimationFrame;\r\n    const { delegate } = animationFrameProvider;\r\n    if (delegate) {\r\n      request = delegate.requestAnimationFrame;\r\n      cancel = delegate.cancelAnimationFrame;\r\n    }\r\n    const handle = request((timestamp) => {\r\n      // Clear the cancel function. The request has been fulfilled, so\r\n      // attempting to cancel the request upon unsubscription would be\r\n      // pointless.\r\n      cancel = undefined;\r\n      callback(timestamp);\r\n    });\r\n    return new Subscription(() => cancel?.(handle));\r\n  },\r\n  requestAnimationFrame(...args) {\r\n    const { delegate } = animationFrameProvider;\r\n    return (delegate?.requestAnimationFrame || requestAnimationFrame)(...args);\r\n  },\r\n  cancelAnimationFrame(...args) {\r\n    const { delegate } = animationFrameProvider;\r\n    return (delegate?.cancelAnimationFrame || cancelAnimationFrame)(...args);\r\n  },\r\n  delegate: undefined,\r\n};\r\n", "import { Observable } from '../../Observable';\r\nimport { TimestampProvider } from '../../types';\r\nimport { performanceTimestampProvider } from '../../scheduler/performanceTimestampProvider';\r\nimport { animationFrameProvider } from '../../scheduler/animationFrameProvider';\r\n\r\n/**\r\n * An observable of animation frames\r\n *\r\n * Emits the amount of time elapsed since subscription and the timestamp on each animation frame.\r\n * Defaults to milliseconds provided to the requestAnimationFrame's callback. Does not end on its own.\r\n *\r\n * Every subscription will start a separate animation loop. Since animation frames are always scheduled\r\n * by the browser to occur directly before a repaint, scheduling more than one animation frame synchronously\r\n * should not be much different or have more overhead than looping over an array of events during\r\n * a single animation frame. However, if for some reason the developer would like to ensure the\r\n * execution of animation-related handlers are all executed during the same task by the engine,\r\n * the `share` operator can be used.\r\n *\r\n * This is useful for setting up animations with RxJS.\r\n *\r\n * ## Examples\r\n *\r\n * Tweening a div to move it on the screen\r\n *\r\n * ```ts\r\n * import { animationFrames, map, takeWhile, endWith } from 'rxjs';\r\n *\r\n * function tween(start: number, end: number, duration: number) {\r\n *   const diff = end - start;\r\n *   return animationFrames().pipe(\r\n *     // Figure out what percentage of time has passed\r\n *     map(({ elapsed }) => elapsed / duration),\r\n *     // Take the vector while less than 100%\r\n *     takeWhile(v => v < 1),\r\n *     // Finish with 100%\r\n *     endWith(1),\r\n *     // Calculate the distance traveled between start and end\r\n *     map(v => v * diff + start)\r\n *   );\r\n * }\r\n *\r\n * // Setup a div for us to move around\r\n * const div = document.createElement('div');\r\n * document.body.appendChild(div);\r\n * div.style.position = 'absolute';\r\n * div.style.width = '40px';\r\n * div.style.height = '40px';\r\n * div.style.backgroundColor = 'lime';\r\n * div.style.transform = 'translate3d(10px, 0, 0)';\r\n *\r\n * tween(10, 200, 4000).subscribe(x => {\r\n *   div.style.transform = `translate3d(${ x }px, 0, 0)`;\r\n * });\r\n * ```\r\n *\r\n * Providing a custom timestamp provider\r\n *\r\n * ```ts\r\n * import { animationFrames, TimestampProvider } from 'rxjs';\r\n *\r\n * // A custom timestamp provider\r\n * let now = 0;\r\n * const customTSProvider: TimestampProvider = {\r\n *   now() { return now++; }\r\n * };\r\n *\r\n * const source$ = animationFrames(customTSProvider);\r\n *\r\n * // Log increasing numbers 0...1...2... on every animation frame.\r\n * source$.subscribe(({ elapsed }) => console.log(elapsed));\r\n * ```\r\n *\r\n * @param timestampProvider An object with a `now` method that provides a numeric timestamp\r\n */\r\nexport function animationFrames(timestampProvider?: TimestampProvider) {\r\n  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;\r\n}\r\n\r\n/**\r\n * Does the work of creating the observable for `animationFrames`.\r\n * @param timestampProvider The timestamp provider to use to create the observable\r\n */\r\nfunction animationFramesFactory(timestampProvider?: TimestampProvider) {\r\n  return new Observable<{ timestamp: number; elapsed: number }>((subscriber) => {\r\n    // If no timestamp provider is specified, use performance.now() - as it\r\n    // will return timestamps 'compatible' with those passed to the run\r\n    // callback and won't be affected by NTP adjustments, etc.\r\n    const provider = timestampProvider || performanceTimestampProvider;\r\n\r\n    // Capture the start time upon subscription, as the run callback can remain\r\n    // queued for a considerable period of time and the elapsed time should\r\n    // represent the time elapsed since subscription - not the time since the\r\n    // first rendered animation frame.\r\n    const start = provider.now();\r\n\r\n    let id = 0;\r\n    const run = () => {\r\n      if (!subscriber.closed) {\r\n        id = animationFrameProvider.requestAnimationFrame((timestamp: DOMHighResTimeStamp | number) => {\r\n          id = 0;\r\n          // Use the provider's timestamp to calculate the elapsed time. Note that\r\n          // this means - if the caller hasn't passed a provider - that\r\n          // performance.now() will be used instead of the timestamp that was\r\n          // passed to the run callback. The reason for this is that the timestamp\r\n          // passed to the callback can be earlier than the start time, as it\r\n          // represents the time at which the browser decided it would render any\r\n          // queued frames - and that time can be earlier the captured start time.\r\n          const now = provider.now();\r\n          subscriber.next({\r\n            timestamp: timestampProvider ? now : timestamp,\r\n            elapsed: now - start,\r\n          });\r\n          run();\r\n        });\r\n      }\r\n    };\r\n\r\n    run();\r\n\r\n    return () => {\r\n      if (id) {\r\n        animationFrameProvider.cancelAnimationFrame(id);\r\n      }\r\n    };\r\n  });\r\n}\r\n\r\n/**\r\n * In the common case, where the timestamp provided by the rAF API is used,\r\n * we use this shared observable to reduce overhead.\r\n */\r\nconst DEFAULT_ANIMATION_FRAMES = animationFramesFactory();\r\n", "let nextHandle = 1;\r\n// The promise needs to be created lazily otherwise it won't be patched by Zones\r\nlet resolved: Promise<any>;\r\nconst activeHandles: { [key: number]: any } = {};\r\n\r\n/**\r\n * Finds the handle in the list of active handles, and removes it.\r\n * Returns `true` if found, `false` otherwise. Used both to clear\r\n * Immediate scheduled tasks, and to identify if a task should be scheduled.\r\n */\r\nfunction findAndClearHandle(handle: number): boolean {\r\n  if (handle in activeHandles) {\r\n    delete activeHandles[handle];\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Helper functions to schedule and unschedule microtasks.\r\n */\r\nexport const Immediate = {\r\n  setImmediate(cb: () => void): number {\r\n    const handle = nextHandle++;\r\n    activeHandles[handle] = true;\r\n    if (!resolved) {\r\n      resolved = Promise.resolve();\r\n    }\r\n    resolved.then(() => findAndClearHandle(handle) && cb());\r\n    return handle;\r\n  },\r\n\r\n  clearImmediate(handle: number): void {\r\n    findAndClearHandle(handle);\r\n  },\r\n};\r\n\r\n/**\r\n * Used for internal testing purposes only. Do not export from library.\r\n */\r\nexport const TestTools = {\r\n  pending() {\r\n    return Object.keys(activeHandles).length;\r\n  }\r\n};\r\n", "import { Immediate } from '../util/Immediate';\r\nimport type { TimerHandle } from './timerHandle';\r\nconst { setImmediate, clearImmediate } = Immediate;\r\n\r\ntype SetImmediateFunction = (handler: () => void, ...args: any[]) => TimerHandle;\r\ntype ClearImmediateFunction = (handle: TimerHandle) => void;\r\n\r\ninterface ImmediateProvider {\r\n  setImmediate: SetImmediateFunction;\r\n  clearImmediate: ClearImmediateFunction;\r\n  delegate:\r\n    | {\r\n        setImmediate: SetImmediateFunction;\r\n        clearImmediate: ClearImmediateFunction;\r\n      }\r\n    | undefined;\r\n}\r\n\r\nexport const immediateProvider: ImmediateProvider = {\r\n  // When accessing the delegate, use the variable rather than `this` so that\r\n  // the functions can be called without being bound to the provider.\r\n  setImmediate(...args) {\r\n    const { delegate } = immediateProvider;\r\n    return (delegate?.setImmediate || setImmediate)(...args);\r\n  },\r\n  clearImmediate(handle) {\r\n    const { delegate } = immediateProvider;\r\n    return (delegate?.clearImmediate || clearImmediate)(handle as any);\r\n  },\r\n  delegate: undefined,\r\n};\r\n", "import { AsyncAction } from './AsyncAction';\r\nimport { AsapScheduler } from './AsapScheduler';\r\nimport { SchedulerAction } from '../types';\r\nimport { immediateProvider } from './immediateProvider';\r\nimport { TimerHandle } from './timerHandle';\r\n\r\nexport class AsapAction<T> extends AsyncAction<T> {\r\n  constructor(protected scheduler: AsapScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\r\n    super(scheduler, work);\r\n  }\r\n\r\n  protected requestAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\r\n    // If delay is greater than 0, request as an async action.\r\n    if (delay !== null && delay > 0) {\r\n      return super.requestAsyncId(scheduler, id, delay);\r\n    }\r\n    // Push the action to the end of the scheduler queue.\r\n    scheduler.actions.push(this);\r\n    // If a microtask has already been scheduled, don't schedule another\r\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\r\n    // the current scheduled microtask id.\r\n    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));\r\n  }\r\n\r\n  protected recycleAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\r\n    // If delay exists and is greater than 0, or if the delay is null (the\r\n    // action wasn't rescheduled) but was originally scheduled as an async\r\n    // action, then recycle as an async action.\r\n    if (delay != null ? delay > 0 : this.delay > 0) {\r\n      return super.recycleAsyncId(scheduler, id, delay);\r\n    }\r\n    // If the scheduler queue has no remaining actions with the same async id,\r\n    // cancel the requested microtask and set the scheduled flag to undefined\r\n    // so the next AsapAction will request its own.\r\n    const { actions } = scheduler;\r\n    if (id != null && actions[actions.length - 1]?.id !== id) {\r\n      immediateProvider.clearImmediate(id);\r\n      if (scheduler._scheduled === id) {\r\n        scheduler._scheduled = undefined;\r\n      }\r\n    }\r\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\r\n    return undefined;\r\n  }\r\n}\r\n", "import { AsyncAction } from './AsyncAction';\r\nimport { AsyncScheduler } from './AsyncScheduler';\r\n\r\nexport class AsapScheduler extends AsyncScheduler {\r\n  public flush(action?: AsyncAction<any>): void {\r\n    this._active = true;\r\n    // The async id that effects a call to flush is stored in _scheduled.\r\n    // Before executing an action, it's necessary to check the action's async\r\n    // id to determine whether it's supposed to be executed in the current\r\n    // flush.\r\n    // Previous implementations of this method used a count to determine this,\r\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\r\n    // are removed from the actions array and that can shift actions that are\r\n    // scheduled to be executed in a subsequent flush into positions at which\r\n    // they are executed within the current flush.\r\n    const flushId = this._scheduled;\r\n    this._scheduled = undefined;\r\n\r\n    const { actions } = this;\r\n    let error: any;\r\n    action = action || actions.shift()!;\r\n\r\n    do {\r\n      if ((error = action.execute(action.state, action.delay))) {\r\n        break;\r\n      }\r\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\r\n\r\n    this._active = false;\r\n\r\n    if (error) {\r\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\r\n        action.unsubscribe();\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n", "import { AsapAction } from './AsapAction';\r\nimport { AsapScheduler } from './AsapScheduler';\r\n\r\n/**\r\n *\r\n * Asap Scheduler\r\n *\r\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\r\n *\r\n * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task\r\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\r\n * code to end and then it will try to execute given task as fast as possible.\r\n *\r\n * `asap` scheduler will do its best to minimize time between end of currently executing code\r\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\r\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\r\n * some (although minimal) unwanted delay.\r\n *\r\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\r\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\r\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\r\n * as soon as possible, `asap` scheduler is your best bet.\r\n *\r\n * ## Example\r\n * Compare async and asap scheduler<\r\n * ```ts\r\n * import { asapScheduler, asyncScheduler } from 'rxjs';\r\n *\r\n * asyncScheduler.schedule(() => console.log('async')); // scheduling 'async' first...\r\n * asapScheduler.schedule(() => console.log('asap'));\r\n *\r\n * // Logs:\r\n * // \"asap\"\r\n * // \"async\"\r\n * // ... but 'asap' goes first!\r\n * ```\r\n */\r\n\r\nexport const asapScheduler = new AsapScheduler(AsapAction);\r\n\r\n/**\r\n * @deprecated Renamed to {@link asapScheduler}. Will be removed in v8.\r\n */\r\nexport const asap = asapScheduler;\r\n", "import { AsyncAction } from './AsyncAction';\r\nimport { Subscription } from '../Subscription';\r\nimport { QueueScheduler } from './QueueScheduler';\r\nimport { SchedulerAction } from '../types';\r\nimport { TimerHandle } from './timerHandle';\r\n\r\nexport class QueueAction<T> extends AsyncAction<T> {\r\n  constructor(protected scheduler: QueueScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\r\n    super(scheduler, work);\r\n  }\r\n\r\n  public schedule(state?: T, delay: number = 0): Subscription {\r\n    if (delay > 0) {\r\n      return super.schedule(state, delay);\r\n    }\r\n    this.delay = delay;\r\n    this.state = state;\r\n    this.scheduler.flush(this);\r\n    return this;\r\n  }\r\n\r\n  public execute(state: T, delay: number): any {\r\n    return delay > 0 || this.closed ? super.execute(state, delay) : this._execute(state, delay);\r\n  }\r\n\r\n  protected requestAsyncId(scheduler: QueueScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\r\n    // If delay exists and is greater than 0, or if the delay is null (the\r\n    // action wasn't rescheduled) but was originally scheduled as an async\r\n    // action, then recycle as an async action.\r\n\r\n    if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {\r\n      return super.requestAsyncId(scheduler, id, delay);\r\n    }\r\n\r\n    // Otherwise flush the scheduler starting with this action.\r\n    scheduler.flush(this);\r\n\r\n    // HACK: In the past, this was returning `void`. However, `void` isn't a valid\r\n    // `TimerHandle`, and generally the return value here isn't really used. So the\r\n    // compromise is to return `0` which is both \"falsy\" and a valid `TimerHandle`,\r\n    // as opposed to refactoring every other instanceo of `requestAsyncId`.\r\n    return 0;\r\n  }\r\n}\r\n", "import { AsyncScheduler } from './AsyncScheduler';\r\n\r\nexport class QueueScheduler extends AsyncScheduler {\r\n}\r\n", "import { QueueAction } from './QueueAction';\r\nimport { QueueScheduler } from './QueueScheduler';\r\n\r\n/**\r\n *\r\n * Queue Scheduler\r\n *\r\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\r\n *\r\n * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\r\n *\r\n * When used without delay, it schedules given task synchronously - executes it right when\r\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\r\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\r\n * that task will be put on a queue and wait for current one to finish.\r\n *\r\n * This means that when you execute task with `queue` scheduler, you are sure it will end\r\n * before any other task scheduled with that scheduler will start.\r\n *\r\n * ## Examples\r\n * Schedule recursively first, then do something\r\n * ```ts\r\n * import { queueScheduler } from 'rxjs';\r\n *\r\n * queueScheduler.schedule(() => {\r\n *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\r\n *\r\n *   console.log('first');\r\n * });\r\n *\r\n * // Logs:\r\n * // \"first\"\r\n * // \"second\"\r\n * ```\r\n *\r\n * Reschedule itself recursively\r\n * ```ts\r\n * import { queueScheduler } from 'rxjs';\r\n *\r\n * queueScheduler.schedule(function(state) {\r\n *   if (state !== 0) {\r\n *     console.log('before', state);\r\n *     this.schedule(state - 1); // `this` references currently executing Action,\r\n *                               // which we reschedule with new state\r\n *     console.log('after', state);\r\n *   }\r\n * }, 0, 3);\r\n *\r\n * // In scheduler that runs recursively, you would expect:\r\n * // \"before\", 3\r\n * // \"before\", 2\r\n * // \"before\", 1\r\n * // \"after\", 1\r\n * // \"after\", 2\r\n * // \"after\", 3\r\n *\r\n * // But with queue it logs:\r\n * // \"before\", 3\r\n * // \"after\", 3\r\n * // \"before\", 2\r\n * // \"after\", 2\r\n * // \"before\", 1\r\n * // \"after\", 1\r\n * ```\r\n */\r\n\r\nexport const queueScheduler = new QueueScheduler(QueueAction);\r\n\r\n/**\r\n * @deprecated Renamed to {@link queueScheduler}. Will be removed in v8.\r\n */\r\nexport const queue = queueScheduler;\r\n", "import { AsyncAction } from './AsyncAction';\r\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\r\nimport { SchedulerAction } from '../types';\r\nimport { animationFrameProvider } from './animationFrameProvider';\r\nimport { TimerHandle } from './timerHandle';\r\n\r\nexport class AnimationFrameAction<T> extends AsyncAction<T> {\r\n  constructor(protected scheduler: AnimationFrameScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\r\n    super(scheduler, work);\r\n  }\r\n\r\n  protected requestAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\r\n    // If delay is greater than 0, request as an async action.\r\n    if (delay !== null && delay > 0) {\r\n      return super.requestAsyncId(scheduler, id, delay);\r\n    }\r\n    // Push the action to the end of the scheduler queue.\r\n    scheduler.actions.push(this);\r\n    // If an animation frame has already been requested, don't request another\r\n    // one. If an animation frame hasn't been requested yet, request one. Return\r\n    // the current animation frame request id.\r\n    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(() => scheduler.flush(undefined)));\r\n  }\r\n\r\n  protected recycleAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\r\n    // If delay exists and is greater than 0, or if the delay is null (the\r\n    // action wasn't rescheduled) but was originally scheduled as an async\r\n    // action, then recycle as an async action.\r\n    if (delay != null ? delay > 0 : this.delay > 0) {\r\n      return super.recycleAsyncId(scheduler, id, delay);\r\n    }\r\n    // If the scheduler queue has no remaining actions with the same async id,\r\n    // cancel the requested animation frame and set the scheduled flag to\r\n    // undefined so the next AnimationFrameAction will request its own.\r\n    const { actions } = scheduler;\r\n    if (id != null && id === scheduler._scheduled && actions[actions.length - 1]?.id !== id) {\r\n      animationFrameProvider.cancelAnimationFrame(id as number);\r\n      scheduler._scheduled = undefined;\r\n    }\r\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\r\n    return undefined;\r\n  }\r\n}\r\n", "import { AsyncAction } from './AsyncAction';\r\nimport { AsyncScheduler } from './AsyncScheduler';\r\n\r\nexport class AnimationFrameScheduler extends AsyncScheduler {\r\n  public flush(action?: AsyncAction<any>): void {\r\n    this._active = true;\r\n    // The async id that effects a call to flush is stored in _scheduled.\r\n    // Before executing an action, it's necessary to check the action's async\r\n    // id to determine whether it's supposed to be executed in the current\r\n    // flush.\r\n    // Previous implementations of this method used a count to determine this,\r\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\r\n    // are removed from the actions array and that can shift actions that are\r\n    // scheduled to be executed in a subsequent flush into positions at which\r\n    // they are executed within the current flush.\r\n    let flushId;\r\n    if (action) {\r\n      flushId = action.id;\r\n    } else {\r\n      flushId = this._scheduled;\r\n      this._scheduled = undefined;\r\n    }\r\n\r\n    const { actions } = this;\r\n    let error: any;\r\n    action = action || actions.shift()!;\r\n\r\n    do {\r\n      if ((error = action.execute(action.state, action.delay))) {\r\n        break;\r\n      }\r\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\r\n\r\n    this._active = false;\r\n\r\n    if (error) {\r\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\r\n        action.unsubscribe();\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n", "import { AnimationFrameAction } from './AnimationFrameAction';\r\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\r\n\r\n/**\r\n *\r\n * Animation Frame Scheduler\r\n *\r\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\r\n *\r\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler\r\n * behaviour.\r\n *\r\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\r\n * It makes sure scheduled task will happen just before next browser content repaint,\r\n * thus performing animations as efficiently as possible.\r\n *\r\n * ## Example\r\n * Schedule div height animation\r\n * ```ts\r\n * // html: <div style=\"background: #0ff;\"></div>\r\n * import { animationFrameScheduler } from 'rxjs';\r\n *\r\n * const div = document.querySelector('div');\r\n *\r\n * animationFrameScheduler.schedule(function(height) {\r\n *   div.style.height = height + \"px\";\r\n *\r\n *   this.schedule(height + 1);  // `this` references currently executing Action,\r\n *                               // which we reschedule with new state\r\n * }, 0, 0);\r\n *\r\n * // You will see a div element growing in height\r\n * ```\r\n */\r\n\r\nexport const animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);\r\n\r\n/**\r\n * @deprecated Renamed to {@link animationFrameScheduler}. Will be removed in v8.\r\n */\r\nexport const animationFrame = animationFrameScheduler;\r\n", "import { AsyncAction } from './AsyncAction';\r\nimport { Subscription } from '../Subscription';\r\nimport { AsyncScheduler } from './AsyncScheduler';\r\nimport { SchedulerAction } from '../types';\r\nimport { TimerHandle } from './timerHandle';\r\n\r\nexport class VirtualTimeScheduler extends AsyncScheduler {\r\n  /** @deprecated Not used in VirtualTimeScheduler directly. Will be removed in v8. */\r\n  static frameTimeFactor = 10;\r\n\r\n  /**\r\n   * The current frame for the state of the virtual scheduler instance. The difference\r\n   * between two \"frames\" is synonymous with the passage of \"virtual time units\". So if\r\n   * you record `scheduler.frame` to be `1`, then later, observe `scheduler.frame` to be at `11`,\r\n   * that means `10` virtual time units have passed.\r\n   */\r\n  public frame: number = 0;\r\n\r\n  /**\r\n   * Used internally to examine the current virtual action index being processed.\r\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\r\n   */\r\n  public index: number = -1;\r\n\r\n  /**\r\n   * This creates an instance of a `VirtualTimeScheduler`. Experts only. The signature of\r\n   * this constructor is likely to change in the long run.\r\n   *\r\n   * @param schedulerActionCtor The type of Action to initialize when initializing actions during scheduling.\r\n   * @param maxFrames The maximum number of frames to process before stopping. Used to prevent endless flush cycles.\r\n   */\r\n  constructor(schedulerActionCtor: typeof AsyncAction = VirtualAction as any, public maxFrames: number = Infinity) {\r\n    super(schedulerActionCtor, () => this.frame);\r\n  }\r\n\r\n  /**\r\n   * Prompt the Scheduler to execute all of its queued actions, therefore\r\n   * clearing its queue.\r\n   */\r\n  public flush(): void {\r\n    const { actions, maxFrames } = this;\r\n    let error: any;\r\n    let action: AsyncAction<any> | undefined;\r\n\r\n    while ((action = actions[0]) && action.delay <= maxFrames) {\r\n      actions.shift();\r\n      this.frame = action.delay;\r\n\r\n      if ((error = action.execute(action.state, action.delay))) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (error) {\r\n      while ((action = actions.shift())) {\r\n        action.unsubscribe();\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\nexport class VirtualAction<T> extends AsyncAction<T> {\r\n  protected active: boolean = true;\r\n\r\n  constructor(\r\n    protected scheduler: VirtualTimeScheduler,\r\n    protected work: (this: SchedulerAction<T>, state?: T) => void,\r\n    protected index: number = (scheduler.index += 1)\r\n  ) {\r\n    super(scheduler, work);\r\n    this.index = scheduler.index = index;\r\n  }\r\n\r\n  public schedule(state?: T, delay: number = 0): Subscription {\r\n    if (Number.isFinite(delay)) {\r\n      if (!this.id) {\r\n        return super.schedule(state, delay);\r\n      }\r\n      this.active = false;\r\n      // If an action is rescheduled, we save allocations by mutating its state,\r\n      // pushing it to the end of the scheduler queue, and recycling the action.\r\n      // But since the VirtualTimeScheduler is used for testing, VirtualActions\r\n      // must be immutable so they can be inspected later.\r\n      const action = new VirtualAction(this.scheduler, this.work);\r\n      this.add(action);\r\n      return action.schedule(state, delay);\r\n    } else {\r\n      // If someone schedules something with Infinity, it'll never happen. So we\r\n      // don't even schedule it.\r\n      return Subscription.EMPTY;\r\n    }\r\n  }\r\n\r\n  protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle {\r\n    this.delay = scheduler.frame + delay;\r\n    const { actions } = scheduler;\r\n    actions.push(this);\r\n    (actions as Array<VirtualAction<T>>).sort(VirtualAction.sortActions);\r\n    return 1;\r\n  }\r\n\r\n  protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle | undefined {\r\n    return undefined;\r\n  }\r\n\r\n  protected _execute(state: T, delay: number): any {\r\n    if (this.active === true) {\r\n      return super._execute(state, delay);\r\n    }\r\n  }\r\n\r\n  private static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>) {\r\n    if (a.delay === b.delay) {\r\n      if (a.index === b.index) {\r\n        return 0;\r\n      } else if (a.index > b.index) {\r\n        return 1;\r\n      } else {\r\n        return -1;\r\n      }\r\n    } else if (a.delay > b.delay) {\r\n      return 1;\r\n    } else {\r\n      return -1;\r\n    }\r\n  }\r\n}\r\n", "/** prettier */\r\nimport { Observable } from '../Observable';\r\nimport { isFunction } from './isFunction';\r\n\r\n/**\r\n * Tests to see if the object is an RxJS {@link Observable}\r\n * @param obj the object to test\r\n */\r\nexport function isObservable(obj: any): obj is Observable<unknown> {\r\n  // The !! is to ensure that this publicly exposed function returns\r\n  // `false` if something like `null` or `0` is passed.\r\n  return !!obj && (obj instanceof Observable || (isFunction(obj.lift) && isFunction(obj.subscribe)));\r\n}\r\n", "import { Observable } from './Observable';\r\nimport { EmptyError } from './util/EmptyError';\r\n\r\nexport interface LastValueFromConfig<T> {\r\n  defaultValue: T;\r\n}\r\n\r\nexport function lastValueFrom<T, D>(source: Observable<T>, config: LastValueFromConfig<D>): Promise<T | D>;\r\nexport function lastValueFrom<T>(source: Observable<T>): Promise<T>;\r\n\r\n/**\r\n * Converts an observable to a promise by subscribing to the observable,\r\n * waiting for it to complete, and resolving the returned promise with the\r\n * last value from the observed stream.\r\n *\r\n * If the observable stream completes before any values were emitted, the\r\n * returned promise will reject with {@link EmptyError} or will resolve\r\n * with the default value if a default was specified.\r\n *\r\n * If the observable stream emits an error, the returned promise will reject\r\n * with that error.\r\n *\r\n * **WARNING**: Only use this with observables you *know* will complete. If the source\r\n * observable does not complete, you will end up with a promise that is hung up, and\r\n * potentially all of the state of an async function hanging out in memory. To avoid\r\n * this situation, look into adding something like {@link timeout}, {@link take},\r\n * {@link takeWhile}, or {@link takeUntil} amongst others.\r\n *\r\n * ## Example\r\n *\r\n * Wait for the last value from a stream and emit it from a promise in\r\n * an async function\r\n *\r\n * ```ts\r\n * import { interval, take, lastValueFrom } from 'rxjs';\r\n *\r\n * async function execute() {\r\n *   const source$ = interval(2000).pipe(take(10));\r\n *   const finalNumber = await lastValueFrom(source$);\r\n *   console.log(`The final number is ${ finalNumber }`);\r\n * }\r\n *\r\n * execute();\r\n *\r\n * // Expected output:\r\n * // 'The final number is 9'\r\n * ```\r\n *\r\n * @see {@link firstValueFrom}\r\n *\r\n * @param source the observable to convert to a promise\r\n * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value\r\n */\r\nexport function lastValueFrom<T, D>(source: Observable<T>, config?: LastValueFromConfig<D>): Promise<T | D> {\r\n  const hasConfig = typeof config === 'object';\r\n  return new Promise<T | D>((resolve, reject) => {\r\n    let _hasValue = false;\r\n    let _value: T;\r\n    source.subscribe({\r\n      next: (value) => {\r\n        _value = value;\r\n        _hasValue = true;\r\n      },\r\n      error: reject,\r\n      complete: () => {\r\n        if (_hasValue) {\r\n          resolve(_value);\r\n        } else if (hasConfig) {\r\n          resolve(config!.defaultValue);\r\n        } else {\r\n          reject(new EmptyError());\r\n        }\r\n      },\r\n    });\r\n  });\r\n}\r\n", "import { Observable } from './Observable';\r\nimport { EmptyError } from './util/EmptyError';\r\nimport { SafeSubscriber } from './Subscriber';\r\n\r\nexport interface FirstValueFromConfig<T> {\r\n  defaultValue: T;\r\n}\r\n\r\nexport function firstValueFrom<T, D>(source: Observable<T>, config: FirstValueFromConfig<D>): Promise<T | D>;\r\nexport function firstValueFrom<T>(source: Observable<T>): Promise<T>;\r\n\r\n/**\r\n * Converts an observable to a promise by subscribing to the observable,\r\n * and returning a promise that will resolve as soon as the first value\r\n * arrives from the observable. The subscription will then be closed.\r\n *\r\n * If the observable stream completes before any values were emitted, the\r\n * returned promise will reject with {@link EmptyError} or will resolve\r\n * with the default value if a default was specified.\r\n *\r\n * If the observable stream emits an error, the returned promise will reject\r\n * with that error.\r\n *\r\n * **WARNING**: Only use this with observables you *know* will emit at least one value,\r\n * *OR* complete. If the source observable does not emit one value or complete, you will\r\n * end up with a promise that is hung up, and potentially all of the state of an\r\n * async function hanging out in memory. To avoid this situation, look into adding\r\n * something like {@link timeout}, {@link take}, {@link takeWhile}, or {@link takeUntil}\r\n * amongst others.\r\n *\r\n * ## Example\r\n *\r\n * Wait for the first value from a stream and emit it from a promise in\r\n * an async function\r\n *\r\n * ```ts\r\n * import { interval, firstValueFrom } from 'rxjs';\r\n *\r\n * async function execute() {\r\n *   const source$ = interval(2000);\r\n *   const firstNumber = await firstValueFrom(source$);\r\n *   console.log(`The first number is ${ firstNumber }`);\r\n * }\r\n *\r\n * execute();\r\n *\r\n * // Expected output:\r\n * // 'The first number is 0'\r\n * ```\r\n *\r\n * @see {@link lastValueFrom}\r\n *\r\n * @param source the observable to convert to a promise\r\n * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value\r\n */\r\nexport function firstValueFrom<T, D>(source: Observable<T>, config?: FirstValueFromConfig<D>): Promise<T | D> {\r\n  const hasConfig = typeof config === 'object';\r\n  return new Promise<T | D>((resolve, reject) => {\r\n    const subscriber = new SafeSubscriber<T>({\r\n      next: (value) => {\r\n        resolve(value);\r\n        subscriber.unsubscribe();\r\n      },\r\n      error: reject,\r\n      complete: () => {\r\n        if (hasConfig) {\r\n          resolve(config!.defaultValue);\r\n        } else {\r\n          reject(new EmptyError());\r\n        }\r\n      },\r\n    });\r\n    source.subscribe(subscriber);\r\n  });\r\n}\r\n", "import { SchedulerLike } from '../types';\r\nimport { isScheduler } from '../util/isScheduler';\r\nimport { Observable } from '../Observable';\r\nimport { subscribeOn } from '../operators/subscribeOn';\r\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\r\nimport { observeOn } from '../operators/observeOn';\r\nimport { AsyncSubject } from '../AsyncSubject';\r\n\r\nexport function bindCallbackInternals(\r\n  isNodeStyle: boolean,\r\n  callbackFunc: any,\r\n  resultSelector?: any,\r\n  scheduler?: SchedulerLike\r\n): (...args: any[]) => Observable<unknown> {\r\n  if (resultSelector) {\r\n    if (isScheduler(resultSelector)) {\r\n      scheduler = resultSelector;\r\n    } else {\r\n      // The user provided a result selector.\r\n      return function (this: any, ...args: any[]) {\r\n        return (bindCallbackInternals(isNodeStyle, callbackFunc, scheduler) as any)\r\n          .apply(this, args)\r\n          .pipe(mapOneOrManyArgs(resultSelector as any));\r\n      };\r\n    }\r\n  }\r\n\r\n  // If a scheduler was passed, use our `subscribeOn` and `observeOn` operators\r\n  // to compose that behavior for the user.\r\n  if (scheduler) {\r\n    return function (this: any, ...args: any[]) {\r\n      return (bindCallbackInternals(isNodeStyle, callbackFunc) as any)\r\n        .apply(this, args)\r\n        .pipe(subscribeOn(scheduler!), observeOn(scheduler!));\r\n    };\r\n  }\r\n\r\n  return function (this: any, ...args: any[]): Observable<any> {\r\n    // We're using AsyncSubject, because it emits when it completes,\r\n    // and it will play the value to all late-arriving subscribers.\r\n    const subject = new AsyncSubject<any>();\r\n\r\n    // If this is true, then we haven't called our function yet.\r\n    let uninitialized = true;\r\n    return new Observable((subscriber) => {\r\n      // Add our subscriber to the subject.\r\n      const subs = subject.subscribe(subscriber);\r\n\r\n      if (uninitialized) {\r\n        uninitialized = false;\r\n        // We're going to execute the bound function\r\n        // This bit is to signal that we are hitting the callback asynchronously.\r\n        // Because we don't have any anti-\"Zalgo\" guarantees with whatever\r\n        // function we are handed, we use this bit to figure out whether or not\r\n        // we are getting hit in a callback synchronously during our call.\r\n        let isAsync = false;\r\n\r\n        // This is used to signal that the callback completed synchronously.\r\n        let isComplete = false;\r\n\r\n        // Call our function that has a callback. If at any time during this\r\n        // call, an error is thrown, it will be caught by the Observable\r\n        // subscription process and sent to the consumer.\r\n        callbackFunc.apply(\r\n          // Pass the appropriate `this` context.\r\n          this,\r\n          [\r\n            // Pass the arguments.\r\n            ...args,\r\n            // And our callback handler.\r\n            (...results: any[]) => {\r\n              if (isNodeStyle) {\r\n                // If this is a node callback, shift the first value off of the\r\n                // results and check it, as it is the error argument. By shifting,\r\n                // we leave only the argument(s) we want to pass to the consumer.\r\n                const err = results.shift();\r\n                if (err != null) {\r\n                  subject.error(err);\r\n                  // If we've errored, we can stop processing this function\r\n                  // as there's nothing else to do. Just return to escape.\r\n                  return;\r\n                }\r\n              }\r\n              // If we have one argument, notify the consumer\r\n              // of it as a single value, otherwise, if there's more than one, pass\r\n              // them as an array. Note that if there are no arguments, `undefined`\r\n              // will be emitted.\r\n              subject.next(1 < results.length ? results : results[0]);\r\n              // Flip this flag, so we know we can complete it in the synchronous\r\n              // case below.\r\n              isComplete = true;\r\n              // If we're not asynchronous, we need to defer the `complete` call\r\n              // until after the call to the function is over. This is because an\r\n              // error could be thrown in the function after it calls our callback,\r\n              // and if that is the case, if we complete here, we are unable to notify\r\n              // the consumer than an error occurred.\r\n              if (isAsync) {\r\n                subject.complete();\r\n              }\r\n            },\r\n          ]\r\n        );\r\n        // If we flipped `isComplete` during the call, we resolved synchronously,\r\n        // notify complete, because we skipped it in the callback to wait\r\n        // to make sure there were no errors during the call.\r\n        if (isComplete) {\r\n          subject.complete();\r\n        }\r\n\r\n        // We're no longer synchronous. If the callback is called at this point\r\n        // we can notify complete on the spot.\r\n        isAsync = true;\r\n      }\r\n\r\n      // Return the subscription from adding our subscriber to the subject.\r\n      return subs;\r\n    });\r\n  };\r\n}\r\n", "/* @prettier */\r\nimport { SchedulerLike } from '../types';\r\nimport { Observable } from '../Observable';\r\nimport { bindCallbackInternals } from './bindCallbackInternals';\r\n\r\nexport function bindCallback(\r\n  callbackFunc: (...args: any[]) => void,\r\n  resultSelector: (...args: any[]) => any,\r\n  scheduler?: SchedulerLike\r\n): (...args: any[]) => Observable<any>;\r\n\r\n// args is the arguments array and we push the callback on the rest tuple since the rest parameter must be last (only item) in a parameter list\r\nexport function bindCallback<A extends readonly unknown[], R extends readonly unknown[]>(\r\n  callbackFunc: (...args: [...A, (...res: R) => void]) => void,\r\n  schedulerLike?: SchedulerLike\r\n): (...arg: A) => Observable<R extends [] ? void : R extends [any] ? R[0] : R>;\r\n\r\n/**\r\n * Converts a callback API to a function that returns an Observable.\r\n *\r\n * <span class=\"informal\">Give it a function `f` of type `f(x, callback)` and\r\n * it will return a function `g` that when called as `g(x)` will output an\r\n * Observable.</span>\r\n *\r\n * `bindCallback` is not an operator because its input and output are not\r\n * Observables. The input is a function `func` with some parameters. The\r\n * last parameter must be a callback function that `func` calls when it is\r\n * done.\r\n *\r\n * The output of `bindCallback` is a function that takes the same parameters\r\n * as `func`, except the last one (the callback). When the output function\r\n * is called with arguments it will return an Observable. If function `func`\r\n * calls its callback with one argument, the Observable will emit that value.\r\n * If on the other hand the callback is called with multiple values the resulting\r\n * Observable will emit an array with said values as arguments.\r\n *\r\n * It is **very important** to remember that input function `func` is not called\r\n * when the output function is, but rather when the Observable returned by the output\r\n * function is subscribed. This means if `func` makes an AJAX request, that request\r\n * will be made every time someone subscribes to the resulting Observable, but not before.\r\n *\r\n * The last optional parameter - `scheduler` - can be used to control when the call\r\n * to `func` happens after someone subscribes to Observable, as well as when results\r\n * passed to callback will be emitted. By default, the subscription to an Observable calls `func`\r\n * synchronously, but using {@link asyncScheduler} as the last parameter will defer the call to `func`,\r\n * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you were to use the async Scheduler\r\n * and call `subscribe` on the output Observable, all function calls that are currently executing\r\n * will end before `func` is invoked.\r\n *\r\n * By default, results passed to the callback are emitted immediately after `func` invokes the callback.\r\n * In particular, if the callback is called synchronously, then the subscription of the resulting Observable\r\n * will call the `next` function synchronously as well.  If you want to defer that call,\r\n * you may use {@link asyncScheduler} just as before.  This means that by using `Scheduler.async` you can\r\n * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.\r\n *\r\n * Note that the Observable created by the output function will always emit a single value\r\n * and then complete immediately. If `func` calls the callback multiple times, values from subsequent\r\n * calls will not appear in the stream. If you need to listen for multiple calls,\r\n *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.\r\n *\r\n * If `func` depends on some context (`this` property) and is not already bound, the context of `func`\r\n * will be the context that the output function has at call time. In particular, if `func`\r\n * is called as a method of some object and if `func` is not already bound, in order to preserve the context\r\n * it is recommended that the context of the output function is set to that object as well.\r\n *\r\n * If the input function calls its callback in the \"node style\" (i.e. first argument to callback is\r\n * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}\r\n * provides convenient error handling and probably is a better choice.\r\n * `bindCallback` will treat such functions the same as any other and error parameters\r\n * (whether passed or not) will always be interpreted as regular callback argument.\r\n *\r\n * ## Examples\r\n *\r\n * Convert jQuery's getJSON to an Observable API\r\n *\r\n * ```ts\r\n * import { bindCallback } from 'rxjs';\r\n * import * as jQuery from 'jquery';\r\n *\r\n * // Suppose we have jQuery.getJSON('/my/url', callback)\r\n * const getJSONAsObservable = bindCallback(jQuery.getJSON);\r\n * const result = getJSONAsObservable('/my/url');\r\n * result.subscribe(x => console.log(x), e => console.error(e));\r\n * ```\r\n *\r\n * Receive an array of arguments passed to a callback\r\n *\r\n * ```ts\r\n * import { bindCallback } from 'rxjs';\r\n *\r\n * const someFunction = (n, s, cb) => {\r\n *   cb(n, s, { someProperty: 'someValue' });\r\n * };\r\n *\r\n * const boundSomeFunction = bindCallback(someFunction);\r\n * boundSomeFunction(5, 'some string').subscribe((values) => {\r\n *   console.log(values); // [5, 'some string', {someProperty: 'someValue'}]\r\n * });\r\n * ```\r\n *\r\n * Compare behaviour with and without `asyncScheduler`\r\n *\r\n * ```ts\r\n * import { bindCallback, asyncScheduler } from 'rxjs';\r\n *\r\n * function iCallMyCallbackSynchronously(cb) {\r\n *   cb();\r\n * }\r\n *\r\n * const boundSyncFn = bindCallback(iCallMyCallbackSynchronously);\r\n * const boundAsyncFn = bindCallback(iCallMyCallbackSynchronously, null, asyncScheduler);\r\n *\r\n * boundSyncFn().subscribe(() => console.log('I was sync!'));\r\n * boundAsyncFn().subscribe(() => console.log('I was async!'));\r\n * console.log('This happened...');\r\n *\r\n * // Logs:\r\n * // I was sync!\r\n * // This happened...\r\n * // I was async!\r\n * ```\r\n *\r\n * Use `bindCallback` on an object method\r\n *\r\n * ```ts\r\n * import { bindCallback } from 'rxjs';\r\n *\r\n * const boundMethod = bindCallback(someObject.methodWithCallback);\r\n * boundMethod\r\n *   .call(someObject) // make sure methodWithCallback has access to someObject\r\n *   .subscribe(subscriber);\r\n * ```\r\n *\r\n * @see {@link bindNodeCallback}\r\n * @see {@link from}\r\n *\r\n * @param callbackFunc A function with a callback as the last parameter.\r\n * @param resultSelector A mapping function used to transform callback events.\r\n * @param scheduler The scheduler on which to schedule the callbacks.\r\n * @return A function which returns the Observable that delivers the same\r\n * values the callback would deliver.\r\n */\r\nexport function bindCallback(\r\n  callbackFunc: (...args: [...any[], (...res: any) => void]) => void,\r\n  resultSelector?: ((...args: any[]) => any) | SchedulerLike,\r\n  scheduler?: SchedulerLike\r\n): (...args: any[]) => Observable<unknown> {\r\n  return bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);\r\n}\r\n", "/* @prettier */\r\nimport { Observable } from '../Observable';\r\nimport { SchedulerLike } from '../types';\r\nimport { bindCallbackInternals } from './bindCallbackInternals';\r\n\r\nexport function bindNodeCallback(\r\n  callbackFunc: (...args: any[]) => void,\r\n  resultSelector: (...args: any[]) => any,\r\n  scheduler?: SchedulerLike\r\n): (...args: any[]) => Observable<any>;\r\n\r\n// args is the arguments array and we push the callback on the rest tuple since the rest parameter must be last (only item) in a parameter list\r\nexport function bindNodeCallback<A extends readonly unknown[], R extends readonly unknown[]>(\r\n  callbackFunc: (...args: [...A, (err: any, ...res: R) => void]) => void,\r\n  schedulerLike?: SchedulerLike\r\n): (...arg: A) => Observable<R extends [] ? void : R extends [any] ? R[0] : R>;\r\n\r\n/**\r\n * Converts a Node.js-style callback API to a function that returns an\r\n * Observable.\r\n *\r\n * <span class=\"informal\">It's just like {@link bindCallback}, but the\r\n * callback is expected to be of type `callback(error, result)`.</span>\r\n *\r\n * `bindNodeCallback` is not an operator because its input and output are not\r\n * Observables. The input is a function `func` with some parameters, but the\r\n * last parameter must be a callback function that `func` calls when it is\r\n * done. The callback function is expected to follow Node.js conventions,\r\n * where the first argument to the callback is an error object, signaling\r\n * whether call was successful. If that object is passed to callback, it means\r\n * something went wrong.\r\n *\r\n * The output of `bindNodeCallback` is a function that takes the same\r\n * parameters as `func`, except the last one (the callback). When the output\r\n * function is called with arguments, it will return an Observable.\r\n * If `func` calls its callback with error parameter present, Observable will\r\n * error with that value as well. If error parameter is not passed, Observable will emit\r\n * second parameter. If there are more parameters (third and so on),\r\n * Observable will emit an array with all arguments, except first error argument.\r\n *\r\n * Note that `func` will not be called at the same time output function is,\r\n * but rather whenever resulting Observable is subscribed. By default call to\r\n * `func` will happen synchronously after subscription, but that can be changed\r\n * with proper `scheduler` provided as optional third parameter. {@link SchedulerLike}\r\n * can also control when values from callback will be emitted by Observable.\r\n * To find out more, check out documentation for {@link bindCallback}, where\r\n * {@link SchedulerLike} works exactly the same.\r\n *\r\n * As in {@link bindCallback}, context (`this` property) of input function will be set to context\r\n * of returned function, when it is called.\r\n *\r\n * After Observable emits value, it will complete immediately. This means\r\n * even if `func` calls callback again, values from second and consecutive\r\n * calls will never appear on the stream. If you need to handle functions\r\n * that call callbacks multiple times, check out {@link fromEvent} or\r\n * {@link fromEventPattern} instead.\r\n *\r\n * Note that `bindNodeCallback` can be used in non-Node.js environments as well.\r\n * \"Node.js-style\" callbacks are just a convention, so if you write for\r\n * browsers or any other environment and API you use implements that callback style,\r\n * `bindNodeCallback` can be safely used on that API functions as well.\r\n *\r\n * Remember that Error object passed to callback does not have to be an instance\r\n * of JavaScript built-in `Error` object. In fact, it does not even have to an object.\r\n * Error parameter of callback function is interpreted as \"present\", when value\r\n * of that parameter is truthy. It could be, for example, non-zero number, non-empty\r\n * string or boolean `true`. In all of these cases resulting Observable would error\r\n * with that value. This means usually regular style callbacks will fail very often when\r\n * `bindNodeCallback` is used. If your Observable errors much more often then you\r\n * would expect, check if callback really is called in Node.js-style and, if not,\r\n * switch to {@link bindCallback} instead.\r\n *\r\n * Note that even if error parameter is technically present in callback, but its value\r\n * is falsy, it still won't appear in array emitted by Observable.\r\n *\r\n * ## Examples\r\n *\r\n *  Read a file from the filesystem and get the data as an Observable\r\n *\r\n * ```ts\r\n * import * as fs from 'fs';\r\n * const readFileAsObservable = bindNodeCallback(fs.readFile);\r\n * const result = readFileAsObservable('./roadNames.txt', 'utf8');\r\n * result.subscribe(x => console.log(x), e => console.error(e));\r\n * ```\r\n *\r\n * Use on function calling callback with multiple arguments\r\n *\r\n * ```ts\r\n * someFunction((err, a, b) => {\r\n *   console.log(err); // null\r\n *   console.log(a); // 5\r\n *   console.log(b); // \"some string\"\r\n * });\r\n * const boundSomeFunction = bindNodeCallback(someFunction);\r\n * boundSomeFunction()\r\n * .subscribe(value => {\r\n *   console.log(value); // [5, \"some string\"]\r\n * });\r\n * ```\r\n *\r\n * Use on function calling callback in regular style\r\n *\r\n * ```ts\r\n * someFunction(a => {\r\n *   console.log(a); // 5\r\n * });\r\n * const boundSomeFunction = bindNodeCallback(someFunction);\r\n * boundSomeFunction()\r\n * .subscribe(\r\n *   value => {}             // never gets called\r\n *   err => console.log(err) // 5\r\n * );\r\n * ```\r\n *\r\n * @see {@link bindCallback}\r\n * @see {@link from}\r\n *\r\n * @param callbackFunc Function with a Node.js-style callback as the last parameter.\r\n * @param resultSelector A mapping function used to transform callback events.\r\n * @param scheduler The scheduler on which to schedule the callbacks.\r\n * @return A function which returns the Observable that delivers the same values the\r\n * Node.js callback would deliver.\r\n */\r\nexport function bindNodeCallback(\r\n  callbackFunc: (...args: [...any[], (err: any, ...res: any) => void]) => void,\r\n  resultSelector?: ((...args: any[]) => any) | SchedulerLike,\r\n  scheduler?: SchedulerLike\r\n): (...args: any[]) => Observable<any> {\r\n  return bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { ObservedValueOf, ObservableInput } from '../types';\r\nimport { innerFrom } from './innerFrom';\r\n\r\n/**\r\n * Creates an Observable that, on subscribe, calls an Observable factory to\r\n * make an Observable for each new Observer.\r\n *\r\n * <span class=\"informal\">Creates the Observable lazily, that is, only when it\r\n * is subscribed.\r\n * </span>\r\n *\r\n * ![](defer.png)\r\n *\r\n * `defer` allows you to create an Observable only when the Observer\r\n * subscribes. It waits until an Observer subscribes to it, calls the given\r\n * factory function to get an Observable -- where a factory function typically\r\n * generates a new Observable -- and subscribes the Observer to this Observable.\r\n * In case the factory function returns a falsy value, then EMPTY is used as\r\n * Observable instead. Last but not least, an exception during the factory\r\n * function call is transferred to the Observer by calling `error`.\r\n *\r\n * ## Example\r\n *\r\n * Subscribe to either an Observable of clicks or an Observable of interval, at random\r\n *\r\n * ```ts\r\n * import { defer, fromEvent, interval } from 'rxjs';\r\n *\r\n * const clicksOrInterval = defer(() => {\r\n *   return Math.random() > 0.5\r\n *     ? fromEvent(document, 'click')\r\n *     : interval(1000);\r\n * });\r\n * clicksOrInterval.subscribe(x => console.log(x));\r\n *\r\n * // Results in the following behavior:\r\n * // If the result of Math.random() is greater than 0.5 it will listen\r\n * // for clicks anywhere on the \"document\"; when document is clicked it\r\n * // will log a MouseEvent object to the console. If the result is less\r\n * // than 0.5 it will emit ascending numbers, one every second(1000ms).\r\n * ```\r\n *\r\n * @see {@link Observable}\r\n *\r\n * @param observableFactory The Observable factory function to invoke for each\r\n * Observer that subscribes to the output Observable. May also return any\r\n * `ObservableInput`, which will be converted on the fly to an Observable.\r\n * @return An Observable whose Observers' subscriptions trigger an invocation of the\r\n * given Observable factory function.\r\n */\r\nexport function defer<R extends ObservableInput<any>>(observableFactory: () => R): Observable<ObservedValueOf<R>> {\r\n  return new Observable<ObservedValueOf<R>>((subscriber) => {\r\n    innerFrom(observableFactory()).subscribe(subscriber);\r\n  });\r\n}\r\n", "import { Connectable, ObservableInput, SubjectLike } from '../types';\r\nimport { Subject } from '../Subject';\r\nimport { Subscription } from '../Subscription';\r\nimport { Observable } from '../Observable';\r\nimport { defer } from './defer';\r\n\r\nexport interface ConnectableConfig<T> {\r\n  /**\r\n   * A factory function used to create the Subject through which the source\r\n   * is multicast. By default this creates a {@link Subject}.\r\n   */\r\n  connector: () => SubjectLike<T>;\r\n  /**\r\n   * If true, the resulting observable will reset internal state upon disconnection\r\n   * and return to a \"cold\" state. This allows the resulting observable to be\r\n   * reconnected.\r\n   * If false, upon disconnection, the connecting subject will remain the\r\n   * connecting subject, meaning the resulting observable will not go \"cold\" again,\r\n   * and subsequent repeats or resubscriptions will resubscribe to that same subject.\r\n   */\r\n  resetOnDisconnect?: boolean;\r\n}\r\n\r\n/**\r\n * The default configuration for `connectable`.\r\n */\r\nconst DEFAULT_CONFIG: ConnectableConfig<unknown> = {\r\n  connector: () => new Subject<unknown>(),\r\n  resetOnDisconnect: true,\r\n};\r\n\r\n/**\r\n * Creates an observable that multicasts once `connect()` is called on it.\r\n *\r\n * @param source The observable source to make connectable.\r\n * @param config The configuration object for `connectable`.\r\n * @returns A \"connectable\" observable, that has a `connect()` method, that you must call to\r\n * connect the source to all consumers through the subject provided as the connector.\r\n */\r\nexport function connectable<T>(source: ObservableInput<T>, config: ConnectableConfig<T> = DEFAULT_CONFIG): Connectable<T> {\r\n  // The subscription representing the connection.\r\n  let connection: Subscription | null = null;\r\n  const { connector, resetOnDisconnect = true } = config;\r\n  let subject = connector();\r\n\r\n  const result: any = new Observable<T>((subscriber) => {\r\n    return subject.subscribe(subscriber);\r\n  });\r\n\r\n  // Define the `connect` function. This is what users must call\r\n  // in order to \"connect\" the source to the subject that is\r\n  // multicasting it.\r\n  result.connect = () => {\r\n    if (!connection || connection.closed) {\r\n      connection = defer(() => source).subscribe(subject);\r\n      if (resetOnDisconnect) {\r\n        connection.add(() => (subject = connector()));\r\n      }\r\n    }\r\n    return connection;\r\n  };\r\n\r\n  return result;\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { ObservedValueOf, ObservableInputTuple, ObservableInput } from '../types';\r\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\r\nimport { innerFrom } from './innerFrom';\r\nimport { popResultSelector } from '../util/args';\r\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\r\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\r\nimport { createObject } from '../util/createObject';\r\nimport { AnyCatcher } from '../AnyCatcher';\r\n\r\n// forkJoin(any)\r\n// We put this first because we need to catch cases where the user has supplied\r\n// _exactly `any`_ as the argument. Since `any` literally matches _anything_,\r\n// we don't want it to randomly hit one of the other type signatures below,\r\n// as we have no idea at build-time what type we should be returning when given an any.\r\n\r\n/**\r\n * You have passed `any` here, we can't figure out if it is\r\n * an array or an object, so you're getting `unknown`. Use better types.\r\n * @param arg Something typed as `any`\r\n */\r\nexport function forkJoin<T extends AnyCatcher>(arg: T): Observable<unknown>;\r\n\r\n// forkJoin(null | undefined)\r\nexport function forkJoin(scheduler: null | undefined): Observable<never>;\r\n\r\n// forkJoin([a, b, c])\r\nexport function forkJoin(sources: readonly []): Observable<never>;\r\nexport function forkJoin<A extends readonly unknown[]>(sources: readonly [...ObservableInputTuple<A>]): Observable<A>;\r\nexport function forkJoin<A extends readonly unknown[], R>(\r\n  sources: readonly [...ObservableInputTuple<A>],\r\n  resultSelector: (...values: A) => R\r\n): Observable<R>;\r\n\r\n// forkJoin(a, b, c)\r\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\r\nexport function forkJoin<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A>;\r\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\r\nexport function forkJoin<A extends readonly unknown[], R>(\r\n  ...sourcesAndResultSelector: [...ObservableInputTuple<A>, (...values: A) => R]\r\n): Observable<R>;\r\n\r\n// forkJoin({a, b, c})\r\nexport function forkJoin(sourcesObject: { [K in any]: never }): Observable<never>;\r\nexport function forkJoin<T extends Record<string, ObservableInput<any>>>(\r\n  sourcesObject: T\r\n): Observable<{ [K in keyof T]: ObservedValueOf<T[K]> }>;\r\n\r\n/**\r\n * Accepts an `Array` of {@link ObservableInput} or a dictionary `Object` of {@link ObservableInput} and returns\r\n * an {@link Observable} that emits either an array of values in the exact same order as the passed array,\r\n * or a dictionary of values in the same shape as the passed dictionary.\r\n *\r\n * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted;\r\n * complete immediately if an empty array is passed.</span>\r\n *\r\n * ![](forkJoin.png)\r\n *\r\n * `forkJoin` is an operator that takes any number of input observables which can be passed either as an array\r\n * or a dictionary of input observables. If no input observables are provided (e.g. an empty array is passed),\r\n * then the resulting stream will complete immediately.\r\n *\r\n * `forkJoin` will wait for all passed observables to emit and complete and then it will emit an array or an object with last\r\n * values from corresponding observables.\r\n *\r\n * If you pass an array of `n` observables to the operator, then the resulting\r\n * array will have `n` values, where the first value is the last one emitted by the first observable,\r\n * second value is the last one emitted by the second observable and so on.\r\n *\r\n * If you pass a dictionary of observables to the operator, then the resulting\r\n * objects will have the same keys as the dictionary passed, with their last values they have emitted\r\n * located at the corresponding key.\r\n *\r\n * That means `forkJoin` will not emit more than once and it will complete after that. If you need to emit combined\r\n * values not only at the end of the lifecycle of passed observables, but also throughout it, try out {@link combineLatest}\r\n * or {@link zip} instead.\r\n *\r\n * In order for the resulting array to have the same length as the number of input observables, whenever any of\r\n * the given observables completes without emitting any value, `forkJoin` will complete at that moment as well\r\n * and it will not emit anything either, even if it already has some last values from other observables.\r\n * Conversely, if there is an observable that never completes, `forkJoin` will never complete either,\r\n * unless at any point some other observable completes without emitting a value, which brings us back to\r\n * the previous case. Overall, in order for `forkJoin` to emit a value, all given observables\r\n * have to emit something at least once and complete.\r\n *\r\n * If any given observable errors at some point, `forkJoin` will error as well and immediately unsubscribe\r\n * from the other observables.\r\n *\r\n * Optionally `forkJoin` accepts a `resultSelector` function, that will be called with values which normally\r\n * would land in the emitted array. Whatever is returned by the `resultSelector`, will appear in the output\r\n * observable instead. This means that the default `resultSelector` can be thought of as a function that takes\r\n * all its arguments and puts them into an array. Note that the `resultSelector` will be called only\r\n * when `forkJoin` is supposed to emit a result.\r\n *\r\n * ## Examples\r\n *\r\n * Use `forkJoin` with a dictionary of observable inputs\r\n *\r\n * ```ts\r\n * import { forkJoin, of, timer } from 'rxjs';\r\n *\r\n * const observable = forkJoin({\r\n *   foo: of(1, 2, 3, 4),\r\n *   bar: Promise.resolve(8),\r\n *   baz: timer(4000)\r\n * });\r\n * observable.subscribe({\r\n *  next: value => console.log(value),\r\n *  complete: () => console.log('This is how it ends!'),\r\n * });\r\n *\r\n * // Logs:\r\n * // { foo: 4, bar: 8, baz: 0 } after 4 seconds\r\n * // 'This is how it ends!' immediately after\r\n * ```\r\n *\r\n * Use `forkJoin` with an array of observable inputs\r\n *\r\n * ```ts\r\n * import { forkJoin, of, timer } from 'rxjs';\r\n *\r\n * const observable = forkJoin([\r\n *   of(1, 2, 3, 4),\r\n *   Promise.resolve(8),\r\n *   timer(4000)\r\n * ]);\r\n * observable.subscribe({\r\n *  next: value => console.log(value),\r\n *  complete: () => console.log('This is how it ends!'),\r\n * });\r\n *\r\n * // Logs:\r\n * // [4, 8, 0] after 4 seconds\r\n * // 'This is how it ends!' immediately after\r\n * ```\r\n *\r\n * @see {@link combineLatest}\r\n * @see {@link zip}\r\n *\r\n * @param args Any number of `ObservableInput`s provided either as an array, as an object\r\n * or as arguments passed directly to the operator.\r\n * @return Observable emitting either an array of last values emitted by passed Observables\r\n * or value from project function.\r\n */\r\nexport function forkJoin(...args: any[]): Observable<any> {\r\n  const resultSelector = popResultSelector(args);\r\n  const { args: sources, keys } = argsArgArrayOrObject(args);\r\n  const result = new Observable((subscriber) => {\r\n    const { length } = sources;\r\n    if (!length) {\r\n      subscriber.complete();\r\n      return;\r\n    }\r\n    const values = new Array(length);\r\n    let remainingCompletions = length;\r\n    let remainingEmissions = length;\r\n    for (let sourceIndex = 0; sourceIndex < length; sourceIndex++) {\r\n      let hasValue = false;\r\n      innerFrom(sources[sourceIndex]).subscribe(\r\n        createOperatorSubscriber(\r\n          subscriber,\r\n          (value) => {\r\n            if (!hasValue) {\r\n              hasValue = true;\r\n              remainingEmissions--;\r\n            }\r\n            values[sourceIndex] = value;\r\n          },\r\n          () => remainingCompletions--,\r\n          undefined,\r\n          () => {\r\n            if (!remainingCompletions || !hasValue) {\r\n              if (!remainingEmissions) {\r\n                subscriber.next(keys ? createObject(keys, values) : values);\r\n              }\r\n              subscriber.complete();\r\n            }\r\n          }\r\n        )\r\n      );\r\n    }\r\n  });\r\n  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;\r\n}\r\n", "import { innerFrom } from '../observable/innerFrom';\r\nimport { Observable } from '../Observable';\r\nimport { mergeMap } from '../operators/mergeMap';\r\nimport { isArrayLike } from '../util/isArrayLike';\r\nimport { isFunction } from '../util/isFunction';\r\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\r\n\r\n// These constants are used to create handler registry functions using array mapping below.\r\nconst nodeEventEmitterMethods = ['addListener', 'removeListener'] as const;\r\nconst eventTargetMethods = ['addEventListener', 'removeEventListener'] as const;\r\nconst jqueryMethods = ['on', 'off'] as const;\r\n\r\nexport interface NodeStyleEventEmitter {\r\n  addListener(eventName: string | symbol, handler: NodeEventHandler): this;\r\n  removeListener(eventName: string | symbol, handler: NodeEventHandler): this;\r\n}\r\n\r\nexport type NodeEventHandler = (...args: any[]) => void;\r\n\r\n// For APIs that implement `addListener` and `removeListener` methods that may\r\n// not use the same arguments or return EventEmitter values\r\n// such as React Native\r\nexport interface NodeCompatibleEventEmitter {\r\n  addListener(eventName: string, handler: NodeEventHandler): void | {};\r\n  removeListener(eventName: string, handler: NodeEventHandler): void | {};\r\n}\r\n\r\n// Use handler types like those in @types/jquery. See:\r\n// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/847731ba1d7fa6db6b911c0e43aa0afe596e7723/types/jquery/misc.d.ts#L6395\r\nexport interface JQueryStyleEventEmitter<TContext, T> {\r\n  on(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\r\n  off(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\r\n}\r\n\r\nexport interface EventListenerObject<E> {\r\n  handleEvent(evt: E): void;\r\n}\r\n\r\nexport interface HasEventTargetAddRemove<E> {\r\n  addEventListener(\r\n    type: string,\r\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\r\n    options?: boolean | AddEventListenerOptions\r\n  ): void;\r\n  removeEventListener(\r\n    type: string,\r\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\r\n    options?: EventListenerOptions | boolean\r\n  ): void;\r\n}\r\n\r\nexport interface EventListenerOptions {\r\n  capture?: boolean;\r\n  passive?: boolean;\r\n  once?: boolean;\r\n}\r\n\r\nexport interface AddEventListenerOptions extends EventListenerOptions {\r\n  once?: boolean;\r\n  passive?: boolean;\r\n}\r\n\r\nexport function fromEvent<T>(target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>, eventName: string): Observable<T>;\r\nexport function fromEvent<T, R>(\r\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\r\n  eventName: string,\r\n  resultSelector: (event: T) => R\r\n): Observable<R>;\r\nexport function fromEvent<T>(\r\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\r\n  eventName: string,\r\n  options: EventListenerOptions\r\n): Observable<T>;\r\nexport function fromEvent<T, R>(\r\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\r\n  eventName: string,\r\n  options: EventListenerOptions,\r\n  resultSelector: (event: T) => R\r\n): Observable<R>;\r\n\r\nexport function fromEvent(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<unknown>;\r\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\r\nexport function fromEvent<T>(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<T>;\r\nexport function fromEvent<R>(\r\n  target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>,\r\n  eventName: string,\r\n  resultSelector: (...args: any[]) => R\r\n): Observable<R>;\r\n\r\nexport function fromEvent(\r\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\r\n  eventName: string\r\n): Observable<unknown>;\r\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\r\nexport function fromEvent<T>(target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>, eventName: string): Observable<T>;\r\nexport function fromEvent<R>(\r\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\r\n  eventName: string,\r\n  resultSelector: (...args: any[]) => R\r\n): Observable<R>;\r\n\r\nexport function fromEvent<T>(\r\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\r\n  eventName: string\r\n): Observable<T>;\r\nexport function fromEvent<T, R>(\r\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\r\n  eventName: string,\r\n  resultSelector: (value: T, ...args: any[]) => R\r\n): Observable<R>;\r\n\r\n/**\r\n * Creates an Observable that emits events of a specific type coming from the\r\n * given event target.\r\n *\r\n * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\r\n * EventEmitter events or others.</span>\r\n *\r\n * ![](fromEvent.png)\r\n *\r\n * `fromEvent` accepts as a first argument event target, which is an object with methods\r\n * for registering event handler functions. As a second argument it takes string that indicates\r\n * type of event we want to listen for. `fromEvent` supports selected types of event targets,\r\n * which are described in detail below. If your event target does not match any of the ones listed,\r\n * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\r\n * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\r\n * handler functions have different names, but they all accept a string describing event type\r\n * and function itself, which will be called whenever said event happens.\r\n *\r\n * Every time resulting Observable is subscribed, event handler function will be registered\r\n * to event target on given event type. When that event fires, value\r\n * passed as a first argument to registered function will be emitted by output Observable.\r\n * When Observable is unsubscribed, function will be unregistered from event target.\r\n *\r\n * Note that if event target calls registered function with more than one argument, second\r\n * and following arguments will not appear in resulting stream. In order to get access to them,\r\n * you can pass to `fromEvent` optional project function, which will be called with all arguments\r\n * passed to event handler. Output Observable will then emit value returned by project function,\r\n * instead of the usual value.\r\n *\r\n * Remember that event targets listed below are checked via duck typing. It means that\r\n * no matter what kind of object you have and no matter what environment you work in,\r\n * you can safely use `fromEvent` on that object if it exposes described methods (provided\r\n * of course they behave as was described above). So for example if Node.js library exposes\r\n * event target which has the same method names as DOM EventTarget, `fromEvent` is still\r\n * a good choice.\r\n *\r\n * If the API you use is more callback then event handler oriented (subscribed\r\n * callback function fires only once and thus there is no need to manually\r\n * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\r\n * instead.\r\n *\r\n * `fromEvent` supports following types of event targets:\r\n *\r\n * **DOM EventTarget**\r\n *\r\n * This is an object with `addEventListener` and `removeEventListener` methods.\r\n *\r\n * In the browser, `addEventListener` accepts - apart from event type string and event\r\n * handler function arguments - optional third parameter, which is either an object or boolean,\r\n * both used for additional configuration how and when passed function will be called. When\r\n * `fromEvent` is used with event target of that type, you can provide this values\r\n * as third parameter as well.\r\n *\r\n * **Node.js EventEmitter**\r\n *\r\n * An object with `addListener` and `removeListener` methods.\r\n *\r\n * **JQuery-style event target**\r\n *\r\n * An object with `on` and `off` methods\r\n *\r\n * **DOM NodeList**\r\n *\r\n * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\r\n *\r\n * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\r\n * it contains and install event handler function in every of them. When returned Observable\r\n * is unsubscribed, function will be removed from all Nodes.\r\n *\r\n * **DOM HtmlCollection**\r\n *\r\n * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\r\n * installed and removed in each of elements.\r\n *\r\n *\r\n * ## Examples\r\n *\r\n * Emit clicks happening on the DOM document\r\n *\r\n * ```ts\r\n * import { fromEvent } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * clicks.subscribe(x => console.log(x));\r\n *\r\n * // Results in:\r\n * // MouseEvent object logged to console every time a click\r\n * // occurs on the document.\r\n * ```\r\n *\r\n * Use `addEventListener` with capture option\r\n *\r\n * ```ts\r\n * import { fromEvent } from 'rxjs';\r\n *\r\n * const div = document.createElement('div');\r\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\r\n * document.body.appendChild(div);\r\n *\r\n * // note optional configuration parameter which will be passed to addEventListener\r\n * const clicksInDocument = fromEvent(document, 'click', { capture: true });\r\n * const clicksInDiv = fromEvent(div, 'click');\r\n *\r\n * clicksInDocument.subscribe(() => console.log('document'));\r\n * clicksInDiv.subscribe(() => console.log('div'));\r\n *\r\n * // By default events bubble UP in DOM tree, so normally\r\n * // when we would click on div in document\r\n * // \"div\" would be logged first and then \"document\".\r\n * // Since we specified optional `capture` option, document\r\n * // will catch event when it goes DOWN DOM tree, so console\r\n * // will log \"document\" and then \"div\".\r\n * ```\r\n *\r\n * @see {@link bindCallback}\r\n * @see {@link bindNodeCallback}\r\n * @see {@link fromEventPattern}\r\n *\r\n * @param target The DOM EventTarget, Node.js EventEmitter, JQuery-like event target,\r\n * NodeList or HTMLCollection to attach the event handler to.\r\n * @param eventName The event name of interest, being emitted by the `target`.\r\n * @param options Options to pass through to the underlying `addListener`,\r\n * `addEventListener` or `on` functions.\r\n * @param resultSelector A mapping function used to transform events. It takes the\r\n * arguments from the event handler and should return a single value.\r\n * @return An Observable emitting events registered through `target`'s\r\n * listener handlers.\r\n */\r\nexport function fromEvent<T>(\r\n  target: any,\r\n  eventName: string,\r\n  options?: EventListenerOptions | ((...args: any[]) => T),\r\n  resultSelector?: (...args: any[]) => T\r\n): Observable<T> {\r\n  if (isFunction(options)) {\r\n    resultSelector = options;\r\n    options = undefined;\r\n  }\r\n  if (resultSelector) {\r\n    return fromEvent<T>(target, eventName, options as EventListenerOptions).pipe(mapOneOrManyArgs(resultSelector));\r\n  }\r\n\r\n  // Figure out our add and remove methods. In order to do this,\r\n  // we are going to analyze the target in a preferred order, if\r\n  // the target matches a given signature, we take the two \"add\" and \"remove\"\r\n  // method names and apply them to a map to create opposite versions of the\r\n  // same function. This is because they all operate in duplicate pairs,\r\n  // `addListener(name, handler)`, `removeListener(name, handler)`, for example.\r\n  // The call only differs by method name, as to whether or not you're adding or removing.\r\n  const [add, remove] =\r\n    // If it is an EventTarget, we need to use a slightly different method than the other two patterns.\r\n    isEventTarget(target)\r\n      ? eventTargetMethods.map((methodName) => (handler: any) => target[methodName](eventName, handler, options as EventListenerOptions))\r\n      : // In all other cases, the call pattern is identical with the exception of the method names.\r\n      isNodeStyleEventEmitter(target)\r\n      ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))\r\n      : isJQueryStyleEventEmitter(target)\r\n      ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))\r\n      : [];\r\n\r\n  // If add is falsy, it's because we didn't match a pattern above.\r\n  // Check to see if it is an ArrayLike, because if it is, we want to\r\n  // try to apply fromEvent to all of it's items. We do this check last,\r\n  // because there are may be some types that are both ArrayLike *and* implement\r\n  // event registry points, and we'd rather delegate to that when possible.\r\n  if (!add) {\r\n    if (isArrayLike(target)) {\r\n      return mergeMap((subTarget: any) => fromEvent(subTarget, eventName, options as EventListenerOptions))(\r\n        innerFrom(target)\r\n      ) as Observable<T>;\r\n    }\r\n  }\r\n\r\n  // If add is falsy and we made it here, it's because we didn't\r\n  // match any valid target objects above.\r\n  if (!add) {\r\n    throw new TypeError('Invalid event target');\r\n  }\r\n\r\n  return new Observable<T>((subscriber) => {\r\n    // The handler we are going to register. Forwards the event object, by itself, or\r\n    // an array of arguments to the event handler, if there is more than one argument,\r\n    // to the consumer.\r\n    const handler = (...args: any[]) => subscriber.next(1 < args.length ? args : args[0]);\r\n    // Do the work of adding the handler to the target.\r\n    add(handler);\r\n    // When we finalize, we want to remove the handler and free up memory.\r\n    return () => remove!(handler);\r\n  });\r\n}\r\n\r\n/**\r\n * Used to create `add` and `remove` functions to register and unregister event handlers\r\n * from a target in the most common handler pattern, where there are only two arguments.\r\n * (e.g.  `on(name, fn)`, `off(name, fn)`, `addListener(name, fn)`, or `removeListener(name, fn)`)\r\n * @param target The target we're calling methods on\r\n * @param eventName The event name for the event we're creating register or unregister functions for\r\n */\r\nfunction toCommonHandlerRegistry(target: any, eventName: string) {\r\n  return (methodName: string) => (handler: any) => target[methodName](eventName, handler);\r\n}\r\n\r\n/**\r\n * Checks to see if the target implements the required node-style EventEmitter methods\r\n * for adding and removing event handlers.\r\n * @param target the object to check\r\n */\r\nfunction isNodeStyleEventEmitter(target: any): target is NodeStyleEventEmitter {\r\n  return isFunction(target.addListener) && isFunction(target.removeListener);\r\n}\r\n\r\n/**\r\n * Checks to see if the target implements the required jQuery-style EventEmitter methods\r\n * for adding and removing event handlers.\r\n * @param target the object to check\r\n */\r\nfunction isJQueryStyleEventEmitter(target: any): target is JQueryStyleEventEmitter<any, any> {\r\n  return isFunction(target.on) && isFunction(target.off);\r\n}\r\n\r\n/**\r\n * Checks to see if the target implements the required EventTarget methods\r\n * for adding and removing event handlers.\r\n * @param target the object to check\r\n */\r\nfunction isEventTarget(target: any): target is HasEventTargetAddRemove<any> {\r\n  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { isFunction } from '../util/isFunction';\r\nimport { NodeEventHandler } from './fromEvent';\r\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\r\n\r\n/* tslint:disable:max-line-length */\r\nexport function fromEventPattern<T>(\r\n  addHandler: (handler: NodeEventHandler) => any,\r\n  removeHandler?: (handler: NodeEventHandler, signal?: any) => void\r\n): Observable<T>;\r\nexport function fromEventPattern<T>(\r\n  addHandler: (handler: NodeEventHandler) => any,\r\n  removeHandler?: (handler: NodeEventHandler, signal?: any) => void,\r\n  resultSelector?: (...args: any[]) => T\r\n): Observable<T>;\r\n/* tslint:enable:max-line-length */\r\n\r\n/**\r\n * Creates an Observable from an arbitrary API for registering event handlers.\r\n *\r\n * <span class=\"informal\">When that method for adding event handler was something {@link fromEvent}\r\n * was not prepared for.</span>\r\n *\r\n * ![](fromEventPattern.png)\r\n *\r\n * `fromEventPattern` allows you to convert into an Observable any API that supports registering handler functions\r\n * for events. It is similar to {@link fromEvent}, but far\r\n * more flexible. In fact, all use cases of {@link fromEvent} could be easily handled by\r\n * `fromEventPattern` (although in slightly more verbose way).\r\n *\r\n * This operator accepts as a first argument an `addHandler` function, which will be injected with\r\n * handler parameter. That handler is actually an event handler function that you now can pass\r\n * to API expecting it. `addHandler` will be called whenever Observable\r\n * returned by the operator is subscribed, so registering handler in API will not\r\n * necessarily happen when `fromEventPattern` is called.\r\n *\r\n * After registration, every time an event that we listen to happens,\r\n * Observable returned by `fromEventPattern` will emit value that event handler\r\n * function was called with. Note that if event handler was called with more\r\n * than one argument, second and following arguments will not appear in the Observable.\r\n *\r\n * If API you are using allows to unregister event handlers as well, you can pass to `fromEventPattern`\r\n * another function - `removeHandler` - as a second parameter. It will be injected\r\n * with the same handler function as before, which now you can use to unregister\r\n * it from the API. `removeHandler` will be called when consumer of resulting Observable\r\n * unsubscribes from it.\r\n *\r\n * In some APIs unregistering is actually handled differently. Method registering an event handler\r\n * returns some kind of token, which is later used to identify which function should\r\n * be unregistered or it itself has method that unregisters event handler.\r\n * If that is the case with your API, make sure token returned\r\n * by registering method is returned by `addHandler`. Then it will be passed\r\n * as a second argument to `removeHandler`, where you will be able to use it.\r\n *\r\n * If you need access to all event handler parameters (not only the first one),\r\n * or you need to transform them in any way, you can call `fromEventPattern` with optional\r\n * third parameter - project function which will accept all arguments passed to\r\n * event handler when it is called. Whatever is returned from project function will appear on\r\n * resulting stream instead of usual event handlers first argument. This means\r\n * that default project can be thought of as function that takes its first parameter\r\n * and ignores the rest.\r\n *\r\n * ## Examples\r\n *\r\n * Emits clicks happening on the DOM document\r\n *\r\n * ```ts\r\n * import { fromEventPattern } from 'rxjs';\r\n *\r\n * function addClickHandler(handler) {\r\n *   document.addEventListener('click', handler);\r\n * }\r\n *\r\n * function removeClickHandler(handler) {\r\n *   document.removeEventListener('click', handler);\r\n * }\r\n *\r\n * const clicks = fromEventPattern(\r\n *   addClickHandler,\r\n *   removeClickHandler\r\n * );\r\n * clicks.subscribe(x => console.log(x));\r\n *\r\n * // Whenever you click anywhere in the browser, DOM MouseEvent\r\n * // object will be logged.\r\n * ```\r\n *\r\n * Use with API that returns cancellation token\r\n *\r\n * ```ts\r\n * import { fromEventPattern } from 'rxjs';\r\n *\r\n * const token = someAPI.registerEventHandler(function() {});\r\n * someAPI.unregisterEventHandler(token); // this APIs cancellation method accepts\r\n *                                        // not handler itself, but special token.\r\n *\r\n * const someAPIObservable = fromEventPattern(\r\n *   function(handler) { return someAPI.registerEventHandler(handler); }, // Note that we return the token here...\r\n *   function(handler, token) { someAPI.unregisterEventHandler(token); }  // ...to then use it here.\r\n * );\r\n * ```\r\n *\r\n * Use with project function\r\n *\r\n * ```ts\r\n * import { fromEventPattern } from 'rxjs';\r\n *\r\n * someAPI.registerEventHandler((eventType, eventMessage) => {\r\n *   console.log(eventType, eventMessage); // Logs 'EVENT_TYPE' 'EVENT_MESSAGE' to console.\r\n * });\r\n *\r\n * const someAPIObservable = fromEventPattern(\r\n *   handler => someAPI.registerEventHandler(handler),\r\n *   handler => someAPI.unregisterEventHandler(handler)\r\n *   (eventType, eventMessage) => eventType + ' --- ' + eventMessage // without that function only 'EVENT_TYPE'\r\n * );                                                                // would be emitted by the Observable\r\n *\r\n * someAPIObservable.subscribe(value => console.log(value));\r\n *\r\n * // Logs:\r\n * // 'EVENT_TYPE --- EVENT_MESSAGE'\r\n * ```\r\n *\r\n * @see {@link fromEvent}\r\n * @see {@link bindCallback}\r\n * @see {@link bindNodeCallback}\r\n *\r\n * @param addHandler A function that takes a `handler` function as argument and attaches it\r\n * somehow to the actual source of events.\r\n * @param removeHandler A function that takes a `handler` function as an argument and removes\r\n * it from the event source. If `addHandler` returns some kind of token, `removeHandler` function\r\n * will have it as a second parameter.\r\n * @param resultSelector A function to transform results. It takes the arguments from the event\r\n * handler and should return a single value.\r\n * @return Observable which, when an event happens, emits first parameter passed to registered\r\n * event handler. Alternatively it emits whatever project function returns at that moment.\r\n */\r\nexport function fromEventPattern<T>(\r\n  addHandler: (handler: NodeEventHandler) => any,\r\n  removeHandler?: (handler: NodeEventHandler, signal?: any) => void,\r\n  resultSelector?: (...args: any[]) => T\r\n): Observable<T | T[]> {\r\n  if (resultSelector) {\r\n    return fromEventPattern<T>(addHandler, removeHandler).pipe(mapOneOrManyArgs(resultSelector));\r\n  }\r\n\r\n  return new Observable<T | T[]>((subscriber) => {\r\n    const handler = (...e: T[]) => subscriber.next(e.length === 1 ? e[0] : e);\r\n    const retValue = addHandler(handler);\r\n    return isFunction(removeHandler) ? () => removeHandler(handler, retValue) : undefined;\r\n  });\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { identity } from '../util/identity';\r\nimport { ObservableInput, SchedulerLike } from '../types';\r\nimport { isScheduler } from '../util/isScheduler';\r\nimport { defer } from './defer';\r\nimport { scheduleIterable } from '../scheduled/scheduleIterable';\r\n\r\ntype ConditionFunc<S> = (state: S) => boolean;\r\ntype IterateFunc<S> = (state: S) => S;\r\ntype ResultFunc<S, T> = (state: S) => T;\r\n\r\nexport interface GenerateBaseOptions<S> {\r\n  /**\r\n   * Initial state.\r\n   */\r\n  initialState: S;\r\n  /**\r\n   * Condition function that accepts state and returns boolean.\r\n   * When it returns false, the generator stops.\r\n   * If not specified, a generator never stops.\r\n   */\r\n  condition?: ConditionFunc<S>;\r\n  /**\r\n   * Iterate function that accepts state and returns new state.\r\n   */\r\n  iterate: IterateFunc<S>;\r\n  /**\r\n   * SchedulerLike to use for generation process.\r\n   * By default, a generator starts immediately.\r\n   */\r\n  scheduler?: SchedulerLike;\r\n}\r\n\r\nexport interface GenerateOptions<T, S> extends GenerateBaseOptions<S> {\r\n  /**\r\n   * Result selection function that accepts state and returns a value to emit.\r\n   */\r\n  resultSelector: ResultFunc<S, T>;\r\n}\r\n\r\n/**\r\n * Generates an observable sequence by running a state-driven loop\r\n * producing the sequence's elements, using the specified scheduler\r\n * to send out observer messages.\r\n *\r\n * ![](generate.png)\r\n *\r\n * ## Examples\r\n *\r\n * Produces sequence of numbers\r\n *\r\n * ```ts\r\n * import { generate } from 'rxjs';\r\n *\r\n * const result = generate(0, x => x < 3, x => x + 1, x => x);\r\n *\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1\r\n * // 2\r\n * ```\r\n *\r\n * Use `asapScheduler`\r\n *\r\n * ```ts\r\n * import { generate, asapScheduler } from 'rxjs';\r\n *\r\n * const result = generate(1, x => x < 5, x => x * 2, x => x + 1, asapScheduler);\r\n *\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Logs:\r\n * // 2\r\n * // 3\r\n * // 5\r\n * ```\r\n *\r\n * @see {@link from}\r\n * @see {@link Observable}\r\n *\r\n * @param initialState Initial state.\r\n * @param condition Condition to terminate generation (upon returning false).\r\n * @param iterate Iteration step function.\r\n * @param resultSelector Selector function for results produced in the sequence.\r\n * @param scheduler A {@link SchedulerLike} on which to run the generator loop.\r\n * If not provided, defaults to emit immediately.\r\n * @returns The generated sequence.\r\n * @deprecated Instead of passing separate arguments, use the options argument.\r\n * Signatures taking separate arguments will be removed in v8.\r\n */\r\nexport function generate<T, S>(\r\n  initialState: S,\r\n  condition: ConditionFunc<S>,\r\n  iterate: IterateFunc<S>,\r\n  resultSelector: ResultFunc<S, T>,\r\n  scheduler?: SchedulerLike\r\n): Observable<T>;\r\n\r\n/**\r\n * Generates an Observable by running a state-driven loop\r\n * that emits an element on each iteration.\r\n *\r\n * <span class=\"informal\">Use it instead of nexting values in a for loop.</span>\r\n *\r\n * ![](generate.png)\r\n *\r\n * `generate` allows you to create a stream of values generated with a loop very similar to\r\n * a traditional for loop. The first argument of `generate` is a beginning value. The second argument\r\n * is a function that accepts this value and tests if some condition still holds. If it does,\r\n * then the loop continues, if not, it stops. The third value is a function which takes the\r\n * previously defined value and modifies it in some way on each iteration. Note how these three parameters\r\n * are direct equivalents of three expressions in a traditional for loop: the first expression\r\n * initializes some state (for example, a numeric index), the second tests if the loop can perform the next\r\n * iteration (for example, if the index is lower than 10) and the third states how the defined value\r\n * will be modified on every step (for example, the index will be incremented by one).\r\n *\r\n * Return value of a `generate` operator is an Observable that on each loop iteration\r\n * emits a value. First of all, the condition function is ran. If it returns true, then the Observable\r\n * emits the currently stored value (initial value at the first iteration) and finally updates\r\n * that value with iterate function. If at some point the condition returns false, then the Observable\r\n * completes at that moment.\r\n *\r\n * Optionally you can pass a fourth parameter to `generate` - a result selector function which allows you\r\n * to immediately map the value that would normally be emitted by an Observable.\r\n *\r\n * If you find three anonymous functions in `generate` call hard to read, you can provide\r\n * a single object to the operator instead where the object has the properties: `initialState`,\r\n * `condition`, `iterate` and `resultSelector`, which should have respective values that you\r\n * would normally pass to `generate`. `resultSelector` is still optional, but that form\r\n * of calling `generate` allows you to omit `condition` as well. If you omit it, that means\r\n * condition always holds, or in other words the resulting Observable will never complete.\r\n *\r\n * Both forms of `generate` can optionally accept a scheduler. In case of a multi-parameter call,\r\n * scheduler simply comes as a last argument (no matter if there is a `resultSelector`\r\n * function or not). In case of a single-parameter call, you can provide it as a\r\n * `scheduler` property on the object passed to the operator. In both cases, a scheduler decides when\r\n * the next iteration of the loop will happen and therefore when the next value will be emitted\r\n * by the Observable. For example, to ensure that each value is pushed to the Observer\r\n * on a separate task in the event loop, you could use the `async` scheduler. Note that\r\n * by default (when no scheduler is passed) values are simply emitted synchronously.\r\n *\r\n *\r\n * ## Examples\r\n *\r\n * Use with condition and iterate functions\r\n *\r\n * ```ts\r\n * import { generate } from 'rxjs';\r\n *\r\n * const result = generate(0, x => x < 3, x => x + 1);\r\n *\r\n * result.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!')\r\n * });\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1\r\n * // 2\r\n * // 'Complete!'\r\n * ```\r\n *\r\n * Use with condition, iterate and resultSelector functions\r\n *\r\n * ```ts\r\n * import { generate } from 'rxjs';\r\n *\r\n * const result = generate(0, x => x < 3, x => x + 1, x => x * 1000);\r\n *\r\n * result.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!')\r\n * });\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1000\r\n * // 2000\r\n * // 'Complete!'\r\n * ```\r\n *\r\n * Use with options object\r\n *\r\n * ```ts\r\n * import { generate } from 'rxjs';\r\n *\r\n * const result = generate({\r\n *   initialState: 0,\r\n *   condition(value) { return value < 3; },\r\n *   iterate(value) { return value + 1; },\r\n *   resultSelector(value) { return value * 1000; }\r\n * });\r\n *\r\n * result.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!')\r\n * });\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1000\r\n * // 2000\r\n * // 'Complete!'\r\n * ```\r\n *\r\n * Use options object without condition function\r\n *\r\n * ```ts\r\n * import { generate } from 'rxjs';\r\n *\r\n * const result = generate({\r\n *   initialState: 0,\r\n *   iterate(value) { return value + 1; },\r\n *   resultSelector(value) { return value * 1000; }\r\n * });\r\n *\r\n * result.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!') // This will never run\r\n * });\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1000\r\n * // 2000\r\n * // 3000\r\n * // ...and never stops.\r\n * ```\r\n *\r\n * @see {@link from}\r\n *\r\n * @param initialState Initial state.\r\n * @param condition Condition to terminate generation (upon returning false).\r\n * @param iterate Iteration step function.\r\n * @param scheduler A {@link Scheduler} on which to run the generator loop. If not\r\n * provided, defaults to emitting immediately.\r\n * @return The generated sequence.\r\n * @deprecated Instead of passing separate arguments, use the options argument.\r\n * Signatures taking separate arguments will be removed in v8.\r\n */\r\nexport function generate<S>(\r\n  initialState: S,\r\n  condition: ConditionFunc<S>,\r\n  iterate: IterateFunc<S>,\r\n  scheduler?: SchedulerLike\r\n): Observable<S>;\r\n\r\n/**\r\n * Generates an observable sequence by running a state-driven loop\r\n * producing the sequence's elements, using the specified scheduler\r\n * to send out observer messages.\r\n * The overload accepts options object that might contain initial state, iterate,\r\n * condition and scheduler.\r\n *\r\n * ![](generate.png)\r\n *\r\n * ## Examples\r\n *\r\n * Use options object with condition function\r\n *\r\n * ```ts\r\n * import { generate } from 'rxjs';\r\n *\r\n * const result = generate({\r\n *   initialState: 0,\r\n *   condition: x => x < 3,\r\n *   iterate: x => x + 1\r\n * });\r\n *\r\n * result.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!')\r\n * });\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1\r\n * // 2\r\n * // 'Complete!'\r\n * ```\r\n *\r\n * @see {@link from}\r\n * @see {@link Observable}\r\n *\r\n * @param options Object that must contain initialState, iterate and might contain condition and scheduler.\r\n * @returns The generated sequence.\r\n */\r\nexport function generate<S>(options: GenerateBaseOptions<S>): Observable<S>;\r\n\r\n/**\r\n * Generates an observable sequence by running a state-driven loop\r\n * producing the sequence's elements, using the specified scheduler\r\n * to send out observer messages.\r\n * The overload accepts options object that might contain initial state, iterate,\r\n * condition, result selector and scheduler.\r\n *\r\n * ![](generate.png)\r\n *\r\n * ## Examples\r\n *\r\n * Use options object with condition and iterate function\r\n *\r\n * ```ts\r\n * import { generate } from 'rxjs';\r\n *\r\n * const result = generate({\r\n *   initialState: 0,\r\n *   condition: x => x < 3,\r\n *   iterate: x => x + 1,\r\n *   resultSelector: x => x\r\n * });\r\n *\r\n * result.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!')\r\n * });\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1\r\n * // 2\r\n * // 'Complete!'\r\n * ```\r\n *\r\n * @see {@link from}\r\n * @see {@link Observable}\r\n *\r\n * @param options Object that must contain initialState, iterate, resultSelector and might contain condition and scheduler.\r\n * @returns The generated sequence.\r\n */\r\nexport function generate<T, S>(options: GenerateOptions<T, S>): Observable<T>;\r\n\r\nexport function generate<T, S>(\r\n  initialStateOrOptions: S | GenerateOptions<T, S>,\r\n  condition?: ConditionFunc<S>,\r\n  iterate?: IterateFunc<S>,\r\n  resultSelectorOrScheduler?: ResultFunc<S, T> | SchedulerLike,\r\n  scheduler?: SchedulerLike\r\n): Observable<T> {\r\n  let resultSelector: ResultFunc<S, T>;\r\n  let initialState: S;\r\n\r\n  // TODO: Remove this as we move away from deprecated signatures\r\n  // and move towards a configuration object argument.\r\n  if (arguments.length === 1) {\r\n    // If we only have one argument, we can assume it is a configuration object.\r\n    // Note that folks not using TypeScript may trip over this.\r\n    ({\r\n      initialState,\r\n      condition,\r\n      iterate,\r\n      resultSelector = identity as ResultFunc<S, T>,\r\n      scheduler,\r\n    } = initialStateOrOptions as GenerateOptions<T, S>);\r\n  } else {\r\n    // Deprecated arguments path. Figure out what the user\r\n    // passed and set it here.\r\n    initialState = initialStateOrOptions as S;\r\n    if (!resultSelectorOrScheduler || isScheduler(resultSelectorOrScheduler)) {\r\n      resultSelector = identity as ResultFunc<S, T>;\r\n      scheduler = resultSelectorOrScheduler as SchedulerLike;\r\n    } else {\r\n      resultSelector = resultSelectorOrScheduler as ResultFunc<S, T>;\r\n    }\r\n  }\r\n\r\n  // The actual generator used to \"generate\" values.\r\n  function* gen() {\r\n    for (let state = initialState; !condition || condition(state); state = iterate!(state)) {\r\n      yield resultSelector(state);\r\n    }\r\n  }\r\n\r\n  // We use `defer` because we want to defer the creation of the iterator from the iterable.\r\n  return defer(\r\n    (scheduler\r\n      ? // If a scheduler was provided, use `scheduleIterable` to ensure that iteration/generation\r\n        // happens on the scheduler.\r\n        () => scheduleIterable(gen(), scheduler!)\r\n      : // Otherwise, if there's no scheduler, we can just use the generator function directly in\r\n        // `defer` and executing it will return the generator (which is iterable).\r\n        gen) as () => ObservableInput<T>\r\n  );\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { defer } from './defer';\r\nimport { ObservableInput } from '../types';\r\n\r\n/**\r\n * Checks a boolean at subscription time, and chooses between one of two observable sources\r\n *\r\n * `iif` expects a function that returns a boolean (the `condition` function), and two sources,\r\n * the `trueResult` and the `falseResult`, and returns an Observable.\r\n *\r\n * At the moment of subscription, the `condition` function is called. If the result is `true`, the\r\n * subscription will be to the source passed as the `trueResult`, otherwise, the subscription will be\r\n * to the source passed as the `falseResult`.\r\n *\r\n * If you need to check more than two options to choose between more than one observable, have a look at the {@link defer} creation method.\r\n *\r\n * ## Examples\r\n *\r\n * Change at runtime which Observable will be subscribed\r\n *\r\n * ```ts\r\n * import { iif, of } from 'rxjs';\r\n *\r\n * let subscribeToFirst;\r\n * const firstOrSecond = iif(\r\n *   () => subscribeToFirst,\r\n *   of('first'),\r\n *   of('second')\r\n * );\r\n *\r\n * subscribeToFirst = true;\r\n * firstOrSecond.subscribe(value => console.log(value));\r\n *\r\n * // Logs:\r\n * // 'first'\r\n *\r\n * subscribeToFirst = false;\r\n * firstOrSecond.subscribe(value => console.log(value));\r\n *\r\n * // Logs:\r\n * // 'second'\r\n * ```\r\n *\r\n * Control access to an Observable\r\n *\r\n * ```ts\r\n * import { iif, of, EMPTY } from 'rxjs';\r\n *\r\n * let accessGranted;\r\n * const observableIfYouHaveAccess = iif(\r\n *   () => accessGranted,\r\n *   of('It seems you have an access...'),\r\n *   EMPTY\r\n * );\r\n *\r\n * accessGranted = true;\r\n * observableIfYouHaveAccess.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('The end')\r\n * });\r\n *\r\n * // Logs:\r\n * // 'It seems you have an access...'\r\n * // 'The end'\r\n *\r\n * accessGranted = false;\r\n * observableIfYouHaveAccess.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('The end')\r\n * });\r\n *\r\n * // Logs:\r\n * // 'The end'\r\n * ```\r\n *\r\n * @see {@link defer}\r\n *\r\n * @param condition Condition which Observable should be chosen.\r\n * @param trueResult An Observable that will be subscribed if condition is true.\r\n * @param falseResult An Observable that will be subscribed if condition is false.\r\n * @return An observable that proxies to `trueResult` or `falseResult`, depending on the result of the `condition` function.\r\n */\r\nexport function iif<T, F>(condition: () => boolean, trueResult: ObservableInput<T>, falseResult: ObservableInput<F>): Observable<T | F> {\r\n  return defer(() => (condition() ? trueResult : falseResult));\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { ObservableInput, ObservableInputTuple, SchedulerLike } from '../types';\r\nimport { mergeAll } from '../operators/mergeAll';\r\nimport { innerFrom } from './innerFrom';\r\nimport { EMPTY } from './empty';\r\nimport { popNumber, popScheduler } from '../util/args';\r\nimport { from } from './from';\r\n\r\nexport function merge<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\r\nexport function merge<A extends readonly unknown[]>(...sourcesAndConcurrency: [...ObservableInputTuple<A>, number?]): Observable<A[number]>;\r\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\r\nexport function merge<A extends readonly unknown[]>(\r\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike?]\r\n): Observable<A[number]>;\r\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\r\nexport function merge<A extends readonly unknown[]>(\r\n  ...sourcesAndConcurrencyAndScheduler: [...ObservableInputTuple<A>, number?, SchedulerLike?]\r\n): Observable<A[number]>;\r\n\r\n/**\r\n * Creates an output Observable which concurrently emits all values from every\r\n * given input Observable.\r\n *\r\n * <span class=\"informal\">Flattens multiple Observables together by blending\r\n * their values into one Observable.</span>\r\n *\r\n * ![](merge.png)\r\n *\r\n * `merge` subscribes to each given input Observable (as arguments), and simply\r\n * forwards (without doing any transformation) all the values from all the input\r\n * Observables to the output Observable. The output Observable only completes\r\n * once all input Observables have completed. Any error delivered by an input\r\n * Observable will be immediately emitted on the output Observable.\r\n *\r\n * ## Examples\r\n *\r\n * Merge together two Observables: 1s interval and clicks\r\n *\r\n * ```ts\r\n * import { merge, fromEvent, interval } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const timer = interval(1000);\r\n * const clicksOrTimer = merge(clicks, timer);\r\n * clicksOrTimer.subscribe(x => console.log(x));\r\n *\r\n * // Results in the following:\r\n * // timer will emit ascending values, one every second(1000ms) to console\r\n * // clicks logs MouseEvents to console every time the \"document\" is clicked\r\n * // Since the two streams are merged you see these happening\r\n * // as they occur.\r\n * ```\r\n *\r\n * Merge together 3 Observables, but run only 2 concurrently\r\n *\r\n * ```ts\r\n * import { interval, take, merge } from 'rxjs';\r\n *\r\n * const timer1 = interval(1000).pipe(take(10));\r\n * const timer2 = interval(2000).pipe(take(6));\r\n * const timer3 = interval(500).pipe(take(10));\r\n *\r\n * const concurrent = 2; // the argument\r\n * const merged = merge(timer1, timer2, timer3, concurrent);\r\n * merged.subscribe(x => console.log(x));\r\n *\r\n * // Results in the following:\r\n * // - First timer1 and timer2 will run concurrently\r\n * // - timer1 will emit a value every 1000ms for 10 iterations\r\n * // - timer2 will emit a value every 2000ms for 6 iterations\r\n * // - after timer1 hits its max iteration, timer2 will\r\n * //   continue, and timer3 will start to run concurrently with timer2\r\n * // - when timer2 hits its max iteration it terminates, and\r\n * //   timer3 will continue to emit a value every 500ms until it is complete\r\n * ```\r\n *\r\n * @see {@link mergeAll}\r\n * @see {@link mergeMap}\r\n * @see {@link mergeMapTo}\r\n * @see {@link mergeScan}\r\n *\r\n * @param args `ObservableInput`s to merge together. If the last parameter\r\n * is of type number, `merge` will use it to limit number of concurrently\r\n * subscribed `ObservableInput`s. If the last parameter is {@link SchedulerLike},\r\n * it will be used for scheduling the emission of values.\r\n * @return An Observable that emits items that are the result of every input Observable.\r\n */\r\nexport function merge(...args: (ObservableInput<unknown> | number | SchedulerLike)[]): Observable<unknown> {\r\n  const scheduler = popScheduler(args);\r\n  const concurrent = popNumber(args, Infinity);\r\n  const sources = args as ObservableInput<unknown>[];\r\n  return !sources.length\r\n    ? // No source provided\r\n      EMPTY\r\n    : sources.length === 1\r\n    ? // One source? Just return it.\r\n      innerFrom(sources[0])\r\n    : // Merge all sources\r\n      mergeAll(concurrent)(from(sources, scheduler));\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { noop } from '../util/noop';\r\n\r\n/**\r\n * An Observable that emits no items to the Observer and never completes.\r\n *\r\n * ![](never.png)\r\n *\r\n * A simple Observable that emits neither values nor errors nor the completion\r\n * notification. It can be used for testing purposes or for composing with other\r\n * Observables. Please note that by never emitting a complete notification, this\r\n * Observable keeps the subscription from being disposed automatically.\r\n * Subscriptions need to be manually disposed.\r\n *\r\n * ##  Example\r\n *\r\n * Emit the number 7, then never emit anything else (not even complete)\r\n *\r\n * ```ts\r\n * import { NEVER, startWith } from 'rxjs';\r\n *\r\n * const info = () => console.log('Will not be called');\r\n *\r\n * const result = NEVER.pipe(startWith(7));\r\n * result.subscribe({\r\n *   next: x => console.log(x),\r\n *   error: info,\r\n *   complete: info\r\n * });\r\n * ```\r\n *\r\n * @see {@link Observable}\r\n * @see {@link EMPTY}\r\n * @see {@link of}\r\n * @see {@link throwError}\r\n */\r\nexport const NEVER = new Observable<never>(noop);\r\n\r\n/**\r\n * @deprecated Replaced with the {@link NEVER} constant. Will be removed in v8.\r\n */\r\nexport function never() {\r\n  return NEVER;\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { SchedulerLike } from '../types';\r\nimport { from } from './from';\r\n\r\n/**\r\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\r\n */\r\nexport function pairs<T>(arr: readonly T[], scheduler?: SchedulerLike): Observable<[string, T]>;\r\n/**\r\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\r\n */\r\nexport function pairs<O extends Record<string, unknown>>(obj: O, scheduler?: SchedulerLike): Observable<[keyof O, O[keyof O]]>;\r\n/**\r\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\r\n */\r\nexport function pairs<T>(iterable: Iterable<T>, scheduler?: SchedulerLike): Observable<[string, T]>;\r\n/**\r\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\r\n */\r\nexport function pairs(\r\n  n: number | bigint | boolean | ((...args: any[]) => any) | symbol,\r\n  scheduler?: SchedulerLike\r\n): Observable<[never, never]>;\r\n\r\n/**\r\n * Convert an object into an Observable of `[key, value]` pairs.\r\n *\r\n * <span class=\"informal\">Turn entries of an object into a stream.</span>\r\n *\r\n * ![](pairs.png)\r\n *\r\n * `pairs` takes an arbitrary object and returns an Observable that emits arrays. Each\r\n * emitted array has exactly two elements - the first is a key from the object\r\n * and the second is a value corresponding to that key. Keys are extracted from\r\n * an object via `Object.keys` function, which means that they will be only\r\n * enumerable keys that are present on an object directly - not ones inherited\r\n * via prototype chain.\r\n *\r\n * By default, these arrays are emitted synchronously. To change that you can\r\n * pass a {@link SchedulerLike} as a second argument to `pairs`.\r\n *\r\n * ## Example\r\n *\r\n * Converts an object to an Observable\r\n *\r\n * ```ts\r\n * import { pairs } from 'rxjs';\r\n *\r\n * const obj = {\r\n *   foo: 42,\r\n *   bar: 56,\r\n *   baz: 78\r\n * };\r\n *\r\n * pairs(obj).subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!')\r\n * });\r\n *\r\n * // Logs:\r\n * // ['foo', 42]\r\n * // ['bar', 56]\r\n * // ['baz', 78]\r\n * // 'Complete!'\r\n * ```\r\n *\r\n * ### Object.entries required\r\n *\r\n * In IE, you will need to polyfill `Object.entries` in order to use this.\r\n * [MDN has a polyfill here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)\r\n *\r\n * @param obj The object to inspect and turn into an Observable sequence.\r\n * @param scheduler An optional IScheduler to schedule when resulting\r\n * Observable will emit values.\r\n * @returns An observable sequence of [key, value] pairs from the object.\r\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\r\n */\r\nexport function pairs(obj: any, scheduler?: SchedulerLike) {\r\n  return from(Object.entries(obj), scheduler as any);\r\n}\r\n", "import { not } from '../util/not';\r\nimport { filter } from '../operators/filter';\r\nimport { ObservableInput } from '../types';\r\nimport { Observable } from '../Observable';\r\nimport { innerFrom } from './innerFrom';\r\n\r\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\r\nexport function partition<T, U extends T, A>(\r\n  source: ObservableInput<T>,\r\n  predicate: (this: A, value: T, index: number) => value is U,\r\n  thisArg: A\r\n): [Observable<U>, Observable<Exclude<T, U>>];\r\nexport function partition<T, U extends T>(\r\n  source: ObservableInput<T>,\r\n  predicate: (value: T, index: number) => value is U\r\n): [Observable<U>, Observable<Exclude<T, U>>];\r\n\r\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\r\nexport function partition<T, A>(\r\n  source: ObservableInput<T>,\r\n  predicate: (this: A, value: T, index: number) => boolean,\r\n  thisArg: A\r\n): [Observable<T>, Observable<T>];\r\nexport function partition<T>(source: ObservableInput<T>, predicate: (value: T, index: number) => boolean): [Observable<T>, Observable<T>];\r\n\r\n/**\r\n * Splits the source Observable into two, one with values that satisfy a\r\n * predicate, and another with values that don't satisfy the predicate.\r\n *\r\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\r\n * one like the output of {@link filter}, and the other with values that did not\r\n * pass the condition.</span>\r\n *\r\n * ![](partition.png)\r\n *\r\n * `partition` outputs an array with two Observables that partition the values\r\n * from the source Observable through the given `predicate` function. The first\r\n * Observable in that array emits source values for which the predicate argument\r\n * returns true. The second Observable emits source values for which the\r\n * predicate returns false. The first behaves like {@link filter} and the second\r\n * behaves like {@link filter} with the predicate negated.\r\n *\r\n * ## Example\r\n *\r\n * Partition a set of numbers into odds and evens observables\r\n *\r\n * ```ts\r\n * import { of, partition } from 'rxjs';\r\n *\r\n * const observableValues = of(1, 2, 3, 4, 5, 6);\r\n * const [evens$, odds$] = partition(observableValues, value => value % 2 === 0);\r\n *\r\n * odds$.subscribe(x => console.log('odds', x));\r\n * evens$.subscribe(x => console.log('evens', x));\r\n *\r\n * // Logs:\r\n * // odds 1\r\n * // odds 3\r\n * // odds 5\r\n * // evens 2\r\n * // evens 4\r\n * // evens 6\r\n * ```\r\n *\r\n * @see {@link filter}\r\n *\r\n * @param source The source `ObservableInput` that will be split into a tuple of\r\n * two Observable elements.\r\n * @param predicate A function that evaluates each value emitted by the source\r\n * Observable. If it returns `true`, the value is emitted on the first Observable\r\n * in the returned array, if `false` the value is emitted on the second Observable\r\n * in the array. The `index` parameter is the number `i` for the i-th source\r\n * emission that has happened since the subscription, starting from the number `0`.\r\n * @param thisArg An optional argument to determine the value of `this` in the\r\n * `predicate` function.\r\n * @return An array with two Observables: one with values that passed the\r\n * predicate, and another with values that did not pass the predicate.\r\n */\r\nexport function partition<T>(\r\n  source: ObservableInput<T>,\r\n  predicate: (this: any, value: T, index: number) => boolean,\r\n  thisArg?: any\r\n): [Observable<T>, Observable<T>] {\r\n  return [filter(predicate, thisArg)(innerFrom(source)), filter(not(predicate, thisArg))(innerFrom(source))] as [\r\n    Observable<T>,\r\n    Observable<T>\r\n  ];\r\n}\r\n", "import { SchedulerLike } from '../types';\r\nimport { Observable } from '../Observable';\r\nimport { EMPTY } from './empty';\r\n\r\nexport function range(start: number, count?: number): Observable<number>;\r\n\r\n/**\r\n * @deprecated The `scheduler` parameter will be removed in v8. Use `range(start, count).pipe(observeOn(scheduler))` instead. Details: Details: https://rxjs.dev/deprecations/scheduler-argument\r\n */\r\nexport function range(start: number, count: number | undefined, scheduler: SchedulerLike): Observable<number>;\r\n\r\n/**\r\n * Creates an Observable that emits a sequence of numbers within a specified\r\n * range.\r\n *\r\n * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\r\n *\r\n * ![](range.png)\r\n *\r\n * `range` operator emits a range of sequential integers, in order, where you\r\n * select the `start` of the range and its `length`. By default, uses no\r\n * {@link SchedulerLike} and just delivers the notifications synchronously, but may use\r\n * an optional {@link SchedulerLike} to regulate those deliveries.\r\n *\r\n * ## Example\r\n *\r\n * Produce a range of numbers\r\n *\r\n * ```ts\r\n * import { range } from 'rxjs';\r\n *\r\n * const numbers = range(1, 3);\r\n *\r\n * numbers.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!')\r\n * });\r\n *\r\n * // Logs:\r\n * // 1\r\n * // 2\r\n * // 3\r\n * // 'Complete!'\r\n * ```\r\n *\r\n * @see {@link timer}\r\n * @see {@link interval}\r\n *\r\n * @param start The value of the first integer in the sequence.\r\n * @param count The number of sequential integers to generate.\r\n * @param scheduler A {@link SchedulerLike} to use for scheduling the emissions\r\n * of the notifications.\r\n * @return An Observable of numbers that emits a finite range of sequential integers.\r\n */\r\nexport function range(start: number, count?: number, scheduler?: SchedulerLike): Observable<number> {\r\n  if (count == null) {\r\n    // If one argument was passed, it's the count, not the start.\r\n    count = start;\r\n    start = 0;\r\n  }\r\n\r\n  if (count <= 0) {\r\n    // No count? We're going nowhere. Return EMPTY.\r\n    return EMPTY;\r\n  }\r\n\r\n  // Where the range should stop.\r\n  const end = count + start;\r\n\r\n  return new Observable(\r\n    scheduler\r\n      ? // The deprecated scheduled path.\r\n        (subscriber) => {\r\n          let n = start;\r\n          return scheduler.schedule(function () {\r\n            if (n < end) {\r\n              subscriber.next(n++);\r\n              this.schedule();\r\n            } else {\r\n              subscriber.complete();\r\n            }\r\n          });\r\n        }\r\n      : // Standard synchronous range.\r\n        (subscriber) => {\r\n          let n = start;\r\n          while (n < end && !subscriber.closed) {\r\n            subscriber.next(n++);\r\n          }\r\n          subscriber.complete();\r\n        }\r\n  );\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { Unsubscribable, ObservableInput, ObservedValueOf } from '../types';\r\nimport { innerFrom } from './innerFrom';\r\nimport { EMPTY } from './empty';\r\n\r\n/**\r\n * Creates an Observable that uses a resource which will be disposed at the same time as the Observable.\r\n *\r\n * <span class=\"informal\">Use it when you catch yourself cleaning up after an Observable.</span>\r\n *\r\n * `using` is a factory operator, which accepts two functions. First function returns a disposable resource.\r\n * It can be an arbitrary object that implements `unsubscribe` method. Second function will be injected with\r\n * that object and should return an Observable. That Observable can use resource object during its execution.\r\n * Both functions passed to `using` will be called every time someone subscribes - neither an Observable nor\r\n * resource object will be shared in any way between subscriptions.\r\n *\r\n * When Observable returned by `using` is subscribed, Observable returned from the second function will be subscribed\r\n * as well. All its notifications (nexted values, completion and error events) will be emitted unchanged by the output\r\n * Observable. If however someone unsubscribes from the Observable or source Observable completes or errors by itself,\r\n * the `unsubscribe` method on resource object will be called. This can be used to do any necessary clean up, which\r\n * otherwise would have to be handled by hand. Note that complete or error notifications are not emitted when someone\r\n * cancels subscription to an Observable via `unsubscribe`, so `using` can be used as a hook, allowing you to make\r\n * sure that all resources which need to exist during an Observable execution will be disposed at appropriate time.\r\n *\r\n * @see {@link defer}\r\n *\r\n * @param resourceFactory A function which creates any resource object that implements `unsubscribe` method.\r\n * @param observableFactory A function which creates an Observable, that can use injected resource object.\r\n * @return An Observable that behaves the same as Observable returned by `observableFactory`, but\r\n * which - when completed, errored or unsubscribed - will also call `unsubscribe` on created resource object.\r\n */\r\nexport function using<T extends ObservableInput<any>>(\r\n  resourceFactory: () => Unsubscribable | void,\r\n  observableFactory: (resource: Unsubscribable | void) => T | void\r\n): Observable<ObservedValueOf<T>> {\r\n  return new Observable<ObservedValueOf<T>>((subscriber) => {\r\n    const resource = resourceFactory();\r\n    const result = observableFactory(resource);\r\n    const source = result ? innerFrom(result) : EMPTY;\r\n    source.subscribe(subscriber);\r\n    return () => {\r\n      // NOTE: Optional chaining did not work here.\r\n      // Related TS Issue: https://github.com/microsoft/TypeScript/issues/40818\r\n      if (resource) {\r\n        resource.unsubscribe();\r\n      }\r\n    };\r\n  });\r\n}\r\n"],
  "mappings": "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",
  "names": ["timestamp", "timestamp", "AsapAction", "delay", "AsapScheduler", "QueueAction", "delay", "QueueScheduler", "AnimationFrameAction", "delay", "AnimationFrameScheduler", "VirtualTimeScheduler", "VirtualAction", "delay", "config", "config", "_i", "config", "sourceIndex", "_a", "count"]
}
