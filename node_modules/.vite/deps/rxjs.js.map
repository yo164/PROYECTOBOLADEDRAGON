{
  "version": 3,
  "sources": ["../../rxjs/src/internal/util/lift.ts", "../../rxjs/src/internal/operators/refCount.ts", "../../rxjs/src/internal/observable/ConnectableObservable.ts", "../../rxjs/src/internal/scheduler/performanceTimestampProvider.ts", "../../rxjs/src/internal/scheduler/animationFrameProvider.ts", "../../rxjs/src/internal/observable/dom/animationFrames.ts", "../../rxjs/src/internal/util/ObjectUnsubscribedError.ts", "../../rxjs/src/internal/Subject.ts", "../../rxjs/src/internal/BehaviorSubject.ts", "../../rxjs/src/internal/scheduler/dateTimestampProvider.ts", "../../rxjs/src/internal/ReplaySubject.ts", "../../rxjs/src/internal/AsyncSubject.ts", "../../rxjs/src/internal/scheduler/Action.ts", "../../rxjs/src/internal/scheduler/intervalProvider.ts", "../../rxjs/src/internal/scheduler/AsyncAction.ts", "../../rxjs/src/internal/util/Immediate.ts", "../../rxjs/src/internal/scheduler/immediateProvider.ts", "../../rxjs/src/internal/scheduler/AsapAction.ts", "../../rxjs/src/internal/Scheduler.ts", "../../rxjs/src/internal/scheduler/AsyncScheduler.ts", "../../rxjs/src/internal/scheduler/AsapScheduler.ts", "../../rxjs/src/internal/scheduler/asap.ts", "../../rxjs/src/internal/scheduler/async.ts", "../../rxjs/src/internal/scheduler/QueueAction.ts", "../../rxjs/src/internal/scheduler/QueueScheduler.ts", "../../rxjs/src/internal/scheduler/queue.ts", "../../rxjs/src/internal/scheduler/AnimationFrameAction.ts", "../../rxjs/src/internal/scheduler/AnimationFrameScheduler.ts", "../../rxjs/src/internal/scheduler/animationFrame.ts", "../../rxjs/src/internal/scheduler/VirtualTimeScheduler.ts", "../../rxjs/src/internal/observable/empty.ts", "../../rxjs/src/internal/util/isScheduler.ts", "../../rxjs/src/internal/util/args.ts", "../../rxjs/src/internal/util/executeSchedule.ts", "../../rxjs/src/internal/operators/observeOn.ts", "../../rxjs/src/internal/operators/subscribeOn.ts", "../../rxjs/src/internal/scheduled/scheduleObservable.ts", "../../rxjs/src/internal/scheduled/schedulePromise.ts", "../../rxjs/src/internal/scheduled/scheduleArray.ts", "../../rxjs/src/internal/scheduled/scheduleIterable.ts", "../../rxjs/src/internal/scheduled/scheduleAsyncIterable.ts", "../../rxjs/src/internal/scheduled/scheduleReadableStreamLike.ts", "../../rxjs/src/internal/scheduled/scheduled.ts", "../../rxjs/src/internal/observable/from.ts", "../../rxjs/src/internal/observable/of.ts", "../../rxjs/src/internal/observable/throwError.ts", "../../rxjs/src/internal/Notification.ts", "../../rxjs/src/internal/util/isObservable.ts", "../../rxjs/src/internal/util/EmptyError.ts", "../../rxjs/src/internal/lastValueFrom.ts", "../../rxjs/src/internal/firstValueFrom.ts", "../../rxjs/src/internal/util/ArgumentOutOfRangeError.ts", "../../rxjs/src/internal/util/NotFoundError.ts", "../../rxjs/src/internal/util/SequenceError.ts", "../../rxjs/src/internal/util/isDate.ts", "../../rxjs/src/internal/operators/timeout.ts", "../../rxjs/src/internal/operators/map.ts", "../../rxjs/src/internal/util/mapOneOrManyArgs.ts", "../../rxjs/src/internal/observable/bindCallbackInternals.ts", "../../rxjs/src/internal/observable/bindCallback.ts", "../../rxjs/src/internal/observable/bindNodeCallback.ts", "../../rxjs/src/internal/util/argsArgArrayOrObject.ts", "../../rxjs/src/internal/util/createObject.ts", "../../rxjs/src/internal/observable/combineLatest.ts", "../../rxjs/src/internal/operators/mergeInternals.ts", "../../rxjs/src/internal/operators/mergeMap.ts", "../../rxjs/src/internal/operators/mergeAll.ts", "../../rxjs/src/internal/operators/concatAll.ts", "../../rxjs/src/internal/observable/concat.ts", "../../rxjs/src/internal/observable/defer.ts", "../../rxjs/src/internal/observable/connectable.ts", "../../rxjs/src/internal/observable/forkJoin.ts", "../../rxjs/src/internal/observable/fromEvent.ts", "../../rxjs/src/internal/observable/fromEventPattern.ts", "../../rxjs/src/internal/observable/generate.ts", "../../rxjs/src/internal/observable/iif.ts", "../../rxjs/src/internal/observable/timer.ts", "../../rxjs/src/internal/observable/interval.ts", "../../rxjs/src/internal/observable/merge.ts", "../../rxjs/src/internal/observable/never.ts", "../../rxjs/src/internal/util/argsOrArgArray.ts", "../../rxjs/src/internal/observable/onErrorResumeNext.ts", "../../rxjs/src/internal/observable/pairs.ts", "../../rxjs/src/internal/util/not.ts", "../../rxjs/src/internal/operators/filter.ts", "../../rxjs/src/internal/observable/partition.ts", "../../rxjs/src/internal/observable/race.ts", "../../rxjs/src/internal/observable/range.ts", "../../rxjs/src/internal/observable/using.ts", "../../rxjs/src/internal/observable/zip.ts", "../../rxjs/src/internal/operators/audit.ts", "../../rxjs/src/internal/operators/auditTime.ts", "../../rxjs/src/internal/operators/buffer.ts", "../../rxjs/src/internal/operators/bufferCount.ts", "../../rxjs/src/internal/operators/bufferTime.ts", "../../rxjs/src/internal/operators/bufferToggle.ts", "../../rxjs/src/internal/operators/bufferWhen.ts", "../../rxjs/src/internal/operators/catchError.ts", "../../rxjs/src/internal/operators/scanInternals.ts", "../../rxjs/src/internal/operators/reduce.ts", "../../rxjs/src/internal/operators/toArray.ts", "../../rxjs/src/internal/operators/joinAllInternals.ts", "../../rxjs/src/internal/operators/combineLatestAll.ts", "../../rxjs/src/internal/operators/combineAll.ts", "../../rxjs/src/internal/operators/combineLatest.ts", "../../rxjs/src/internal/operators/combineLatestWith.ts", "../../rxjs/src/internal/operators/concatMap.ts", "../../rxjs/src/internal/operators/concatMapTo.ts", "../../rxjs/src/internal/operators/concat.ts", "../../rxjs/src/internal/operators/concatWith.ts", "../../rxjs/src/internal/observable/fromSubscribable.ts", "../../rxjs/src/internal/operators/connect.ts", "../../rxjs/src/internal/operators/count.ts", "../../rxjs/src/internal/operators/debounce.ts", "../../rxjs/src/internal/operators/debounceTime.ts", "../../rxjs/src/internal/operators/defaultIfEmpty.ts", "../../rxjs/src/internal/operators/take.ts", "../../rxjs/src/internal/operators/ignoreElements.ts", "../../rxjs/src/internal/operators/mapTo.ts", "../../rxjs/src/internal/operators/delayWhen.ts", "../../rxjs/src/internal/operators/delay.ts", "../../rxjs/src/internal/operators/dematerialize.ts", "../../rxjs/src/internal/operators/distinct.ts", "../../rxjs/src/internal/operators/distinctUntilChanged.ts", "../../rxjs/src/internal/operators/distinctUntilKeyChanged.ts", "../../rxjs/src/internal/operators/throwIfEmpty.ts", "../../rxjs/src/internal/operators/elementAt.ts", "../../rxjs/src/internal/operators/endWith.ts", "../../rxjs/src/internal/operators/every.ts", "../../rxjs/src/internal/operators/exhaustMap.ts", "../../rxjs/src/internal/operators/exhaustAll.ts", "../../rxjs/src/internal/operators/exhaust.ts", "../../rxjs/src/internal/operators/expand.ts", "../../rxjs/src/internal/operators/finalize.ts", "../../rxjs/src/internal/operators/find.ts", "../../rxjs/src/internal/operators/findIndex.ts", "../../rxjs/src/internal/operators/first.ts", "../../rxjs/src/internal/operators/groupBy.ts", "../../rxjs/src/internal/operators/isEmpty.ts", "../../rxjs/src/internal/operators/takeLast.ts", "../../rxjs/src/internal/operators/last.ts", "../../rxjs/src/internal/operators/materialize.ts", "../../rxjs/src/internal/operators/max.ts", "../../rxjs/src/internal/operators/flatMap.ts", "../../rxjs/src/internal/operators/mergeMapTo.ts", "../../rxjs/src/internal/operators/mergeScan.ts", "../../rxjs/src/internal/operators/merge.ts", "../../rxjs/src/internal/operators/mergeWith.ts", "../../rxjs/src/internal/operators/min.ts", "../../rxjs/src/internal/operators/multicast.ts", "../../rxjs/src/internal/operators/onErrorResumeNextWith.ts", "../../rxjs/src/internal/operators/pairwise.ts", "../../rxjs/src/internal/operators/pluck.ts", "../../rxjs/src/internal/operators/publish.ts", "../../rxjs/src/internal/operators/publishBehavior.ts", "../../rxjs/src/internal/operators/publishLast.ts", "../../rxjs/src/internal/operators/publishReplay.ts", "../../rxjs/src/internal/operators/raceWith.ts", "../../rxjs/src/internal/operators/repeat.ts", "../../rxjs/src/internal/operators/repeatWhen.ts", "../../rxjs/src/internal/operators/retry.ts", "../../rxjs/src/internal/operators/retryWhen.ts", "../../rxjs/src/internal/operators/sample.ts", "../../rxjs/src/internal/operators/sampleTime.ts", "../../rxjs/src/internal/operators/scan.ts", "../../rxjs/src/internal/operators/sequenceEqual.ts", "../../rxjs/src/internal/operators/share.ts", "../../rxjs/src/internal/operators/shareReplay.ts", "../../rxjs/src/internal/operators/single.ts", "../../rxjs/src/internal/operators/skip.ts", "../../rxjs/src/internal/operators/skipLast.ts", "../../rxjs/src/internal/operators/skipUntil.ts", "../../rxjs/src/internal/operators/skipWhile.ts", "../../rxjs/src/internal/operators/startWith.ts", "../../rxjs/src/internal/operators/switchMap.ts", "../../rxjs/src/internal/operators/switchAll.ts", "../../rxjs/src/internal/operators/switchMapTo.ts", "../../rxjs/src/internal/operators/switchScan.ts", "../../rxjs/src/internal/operators/takeUntil.ts", "../../rxjs/src/internal/operators/takeWhile.ts", "../../rxjs/src/internal/operators/tap.ts", "../../rxjs/src/internal/operators/throttle.ts", "../../rxjs/src/internal/operators/throttleTime.ts", "../../rxjs/src/internal/operators/timeInterval.ts", "../../rxjs/src/internal/operators/timeoutWith.ts", "../../rxjs/src/internal/operators/timestamp.ts", "../../rxjs/src/internal/operators/window.ts", "../../rxjs/src/internal/operators/windowCount.ts", "../../rxjs/src/internal/operators/windowTime.ts", "../../rxjs/src/internal/operators/windowToggle.ts", "../../rxjs/src/internal/operators/windowWhen.ts", "../../rxjs/src/internal/operators/withLatestFrom.ts", "../../rxjs/src/internal/operators/zipAll.ts", "../../rxjs/src/internal/operators/zip.ts", "../../rxjs/src/internal/operators/zipWith.ts"],
  "sourcesContent": ["import { Observable } from '../Observable';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { OperatorFunction } from '../types';\r\nimport { isFunction } from './isFunction';\r\n\r\n/**\r\n * Used to determine if an object is an Observable with a lift function.\r\n */\r\nexport function hasLift(source: any): source is { lift: InstanceType<typeof Observable>['lift'] } {\r\n  return isFunction(source?.lift);\r\n}\r\n\r\n/**\r\n * Creates an `OperatorFunction`. Used to define operators throughout the library in a concise way.\r\n * @param init The logic to connect the liftedSource to the subscriber at the moment of subscription.\r\n */\r\nexport function operate<T, R>(\r\n  init: (liftedSource: Observable<T>, subscriber: Subscriber<R>) => (() => void) | void\r\n): OperatorFunction<T, R> {\r\n  return (source: Observable<T>) => {\r\n    if (hasLift(source)) {\r\n      return source.lift(function (this: Subscriber<R>, liftedSource: Observable<T>) {\r\n        try {\r\n          return init(liftedSource, this);\r\n        } catch (err) {\r\n          this.error(err);\r\n        }\r\n      });\r\n    }\r\n    throw new TypeError('Unable to lift unknown Observable type');\r\n  };\r\n}\r\n", "import { ConnectableObservable } from '../observable/ConnectableObservable';\r\nimport { Subscription } from '../Subscription';\r\nimport { MonoTypeOperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Make a {@link ConnectableObservable} behave like a ordinary observable and automates the way\r\n * you can connect to it.\r\n *\r\n * Internally it counts the subscriptions to the observable and subscribes (only once) to the source if\r\n * the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it\r\n * unsubscribes from the source. This way you can make sure that everything before the *published*\r\n * refCount has only a single subscription independently of the number of subscribers to the target\r\n * observable.\r\n *\r\n * Note that using the {@link share} operator is exactly the same as using the `multicast(() => new Subject())` operator\r\n * (making the observable hot) and the *refCount* operator in a sequence.\r\n *\r\n * ![](refCount.png)\r\n *\r\n * ## Example\r\n *\r\n * In the following example there are two intervals turned into connectable observables\r\n * by using the *publish* operator. The first one uses the *refCount* operator, the\r\n * second one does not use it. You will notice that a connectable observable does nothing\r\n * until you call its connect function.\r\n *\r\n * ```ts\r\n * import { interval, tap, publish, refCount } from 'rxjs';\r\n *\r\n * // Turn the interval observable into a ConnectableObservable (hot)\r\n * const refCountInterval = interval(400).pipe(\r\n *   tap(num => console.log(`refCount ${ num }`)),\r\n *   publish(),\r\n *   refCount()\r\n * );\r\n *\r\n * const publishedInterval = interval(400).pipe(\r\n *   tap(num => console.log(`publish ${ num }`)),\r\n *   publish()\r\n * );\r\n *\r\n * refCountInterval.subscribe();\r\n * refCountInterval.subscribe();\r\n * // 'refCount 0' -----> 'refCount 1' -----> etc\r\n * // All subscriptions will receive the same value and the tap (and\r\n * // every other operator) before the `publish` operator will be executed\r\n * // only once per event independently of the number of subscriptions.\r\n *\r\n * publishedInterval.subscribe();\r\n * // Nothing happens until you call .connect() on the observable.\r\n * ```\r\n *\r\n * @return A function that returns an Observable that automates the connection\r\n * to ConnectableObservable.\r\n * @see {@link ConnectableObservable}\r\n * @see {@link share}\r\n * @see {@link publish}\r\n * @deprecated Replaced with the {@link share} operator. How `share` is used\r\n * will depend on the connectable observable you created just prior to the\r\n * `refCount` operator.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    let connection: Subscription | null = null;\r\n\r\n    (source as any)._refCount++;\r\n\r\n    const refCounter = createOperatorSubscriber(subscriber, undefined, undefined, undefined, () => {\r\n      if (!source || (source as any)._refCount <= 0 || 0 < --(source as any)._refCount) {\r\n        connection = null;\r\n        return;\r\n      }\r\n\r\n      ///\r\n      // Compare the local RefCountSubscriber's connection Subscription to the\r\n      // connection Subscription on the shared ConnectableObservable. In cases\r\n      // where the ConnectableObservable source synchronously emits values, and\r\n      // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\r\n      // execution continues to here before the RefCountOperator has a chance to\r\n      // supply the RefCountSubscriber with the shared connection Subscription.\r\n      // For example:\r\n      // ```\r\n      // range(0, 10).pipe(\r\n      //   publish(),\r\n      //   refCount(),\r\n      //   take(5),\r\n      // )\r\n      // .subscribe();\r\n      // ```\r\n      // In order to account for this case, RefCountSubscriber should only dispose\r\n      // the ConnectableObservable's shared connection Subscription if the\r\n      // connection Subscription exists, *and* either:\r\n      //   a. RefCountSubscriber doesn't have a reference to the shared connection\r\n      //      Subscription yet, or,\r\n      //   b. RefCountSubscriber's connection Subscription reference is identical\r\n      //      to the shared connection Subscription\r\n      ///\r\n\r\n      const sharedConnection = (source as any)._connection;\r\n      const conn = connection;\r\n      connection = null;\r\n\r\n      if (sharedConnection && (!conn || sharedConnection === conn)) {\r\n        sharedConnection.unsubscribe();\r\n      }\r\n\r\n      subscriber.unsubscribe();\r\n    });\r\n\r\n    source.subscribe(refCounter);\r\n\r\n    if (!refCounter.closed) {\r\n      connection = (source as ConnectableObservable<T>).connect();\r\n    }\r\n  });\r\n}\r\n", "import { Subject } from '../Subject';\r\nimport { Observable } from '../Observable';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { Subscription } from '../Subscription';\r\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\r\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\r\nimport { hasLift } from '../util/lift';\r\n\r\n/**\r\n * @class ConnectableObservable<T>\r\n * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\r\n * If you are using the `refCount` method of `ConnectableObservable`, use the {@link share} operator\r\n * instead.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport class ConnectableObservable<T> extends Observable<T> {\r\n  protected _subject: Subject<T> | null = null;\r\n  protected _refCount: number = 0;\r\n  protected _connection: Subscription | null = null;\r\n\r\n  /**\r\n   * @param source The source observable\r\n   * @param subjectFactory The factory that creates the subject used internally.\r\n   * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\r\n   * `new ConnectableObservable(source, factory)` is equivalent to\r\n   * `connectable(source, { connector: factory })`.\r\n   * When the `refCount()` method is needed, the {@link share} operator should be used instead:\r\n   * `new ConnectableObservable(source, factory).refCount()` is equivalent to\r\n   * `source.pipe(share({ connector: factory }))`.\r\n   * Details: https://rxjs.dev/deprecations/multicasting\r\n   */\r\n  constructor(public source: Observable<T>, protected subjectFactory: () => Subject<T>) {\r\n    super();\r\n    // If we have lift, monkey patch that here. This is done so custom observable\r\n    // types will compose through multicast. Otherwise the resulting observable would\r\n    // simply be an instance of `ConnectableObservable`.\r\n    if (hasLift(source)) {\r\n      this.lift = source.lift;\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  protected _subscribe(subscriber: Subscriber<T>) {\r\n    return this.getSubject().subscribe(subscriber);\r\n  }\r\n\r\n  protected getSubject(): Subject<T> {\r\n    const subject = this._subject;\r\n    if (!subject || subject.isStopped) {\r\n      this._subject = this.subjectFactory();\r\n    }\r\n    return this._subject!;\r\n  }\r\n\r\n  protected _teardown() {\r\n    this._refCount = 0;\r\n    const { _connection } = this;\r\n    this._subject = this._connection = null;\r\n    _connection?.unsubscribe();\r\n  }\r\n\r\n  /**\r\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use {@link connectable} instead.\r\n   * Details: https://rxjs.dev/deprecations/multicasting\r\n   */\r\n  connect(): Subscription {\r\n    let connection = this._connection;\r\n    if (!connection) {\r\n      connection = this._connection = new Subscription();\r\n      const subject = this.getSubject();\r\n      connection.add(\r\n        this.source.subscribe(\r\n          createOperatorSubscriber(\r\n            subject as any,\r\n            undefined,\r\n            () => {\r\n              this._teardown();\r\n              subject.complete();\r\n            },\r\n            (err) => {\r\n              this._teardown();\r\n              subject.error(err);\r\n            },\r\n            () => this._teardown()\r\n          )\r\n        )\r\n      );\r\n\r\n      if (connection.closed) {\r\n        this._connection = null;\r\n        connection = Subscription.EMPTY;\r\n      }\r\n    }\r\n    return connection;\r\n  }\r\n\r\n  /**\r\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use the {@link share} operator instead.\r\n   * Details: https://rxjs.dev/deprecations/multicasting\r\n   */\r\n  refCount(): Observable<T> {\r\n    return higherOrderRefCount()(this) as Observable<T>;\r\n  }\r\n}\r\n", "import { TimestampProvider } from '../types';\r\n\r\ninterface PerformanceTimestampProvider extends TimestampProvider {\r\n  delegate: TimestampProvider | undefined;\r\n}\r\n\r\nexport const performanceTimestampProvider: PerformanceTimestampProvider = {\r\n  now() {\r\n    // Use the variable rather than `this` so that the function can be called\r\n    // without being bound to the provider.\r\n    return (performanceTimestampProvider.delegate || performance).now();\r\n  },\r\n  delegate: undefined,\r\n};\r\n", "import { Subscription } from '../Subscription';\r\n\r\ninterface AnimationFrameProvider {\r\n  schedule(callback: FrameRequestCallback): Subscription;\r\n  requestAnimationFrame: typeof requestAnimationFrame;\r\n  cancelAnimationFrame: typeof cancelAnimationFrame;\r\n  delegate:\r\n    | {\r\n        requestAnimationFrame: typeof requestAnimationFrame;\r\n        cancelAnimationFrame: typeof cancelAnimationFrame;\r\n      }\r\n    | undefined;\r\n}\r\n\r\nexport const animationFrameProvider: AnimationFrameProvider = {\r\n  // When accessing the delegate, use the variable rather than `this` so that\r\n  // the functions can be called without being bound to the provider.\r\n  schedule(callback) {\r\n    let request = requestAnimationFrame;\r\n    let cancel: typeof cancelAnimationFrame | undefined = cancelAnimationFrame;\r\n    const { delegate } = animationFrameProvider;\r\n    if (delegate) {\r\n      request = delegate.requestAnimationFrame;\r\n      cancel = delegate.cancelAnimationFrame;\r\n    }\r\n    const handle = request((timestamp) => {\r\n      // Clear the cancel function. The request has been fulfilled, so\r\n      // attempting to cancel the request upon unsubscription would be\r\n      // pointless.\r\n      cancel = undefined;\r\n      callback(timestamp);\r\n    });\r\n    return new Subscription(() => cancel?.(handle));\r\n  },\r\n  requestAnimationFrame(...args) {\r\n    const { delegate } = animationFrameProvider;\r\n    return (delegate?.requestAnimationFrame || requestAnimationFrame)(...args);\r\n  },\r\n  cancelAnimationFrame(...args) {\r\n    const { delegate } = animationFrameProvider;\r\n    return (delegate?.cancelAnimationFrame || cancelAnimationFrame)(...args);\r\n  },\r\n  delegate: undefined,\r\n};\r\n", "import { Observable } from '../../Observable';\r\nimport { TimestampProvider } from '../../types';\r\nimport { performanceTimestampProvider } from '../../scheduler/performanceTimestampProvider';\r\nimport { animationFrameProvider } from '../../scheduler/animationFrameProvider';\r\n\r\n/**\r\n * An observable of animation frames\r\n *\r\n * Emits the amount of time elapsed since subscription and the timestamp on each animation frame.\r\n * Defaults to milliseconds provided to the requestAnimationFrame's callback. Does not end on its own.\r\n *\r\n * Every subscription will start a separate animation loop. Since animation frames are always scheduled\r\n * by the browser to occur directly before a repaint, scheduling more than one animation frame synchronously\r\n * should not be much different or have more overhead than looping over an array of events during\r\n * a single animation frame. However, if for some reason the developer would like to ensure the\r\n * execution of animation-related handlers are all executed during the same task by the engine,\r\n * the `share` operator can be used.\r\n *\r\n * This is useful for setting up animations with RxJS.\r\n *\r\n * ## Examples\r\n *\r\n * Tweening a div to move it on the screen\r\n *\r\n * ```ts\r\n * import { animationFrames, map, takeWhile, endWith } from 'rxjs';\r\n *\r\n * function tween(start: number, end: number, duration: number) {\r\n *   const diff = end - start;\r\n *   return animationFrames().pipe(\r\n *     // Figure out what percentage of time has passed\r\n *     map(({ elapsed }) => elapsed / duration),\r\n *     // Take the vector while less than 100%\r\n *     takeWhile(v => v < 1),\r\n *     // Finish with 100%\r\n *     endWith(1),\r\n *     // Calculate the distance traveled between start and end\r\n *     map(v => v * diff + start)\r\n *   );\r\n * }\r\n *\r\n * // Setup a div for us to move around\r\n * const div = document.createElement('div');\r\n * document.body.appendChild(div);\r\n * div.style.position = 'absolute';\r\n * div.style.width = '40px';\r\n * div.style.height = '40px';\r\n * div.style.backgroundColor = 'lime';\r\n * div.style.transform = 'translate3d(10px, 0, 0)';\r\n *\r\n * tween(10, 200, 4000).subscribe(x => {\r\n *   div.style.transform = `translate3d(${ x }px, 0, 0)`;\r\n * });\r\n * ```\r\n *\r\n * Providing a custom timestamp provider\r\n *\r\n * ```ts\r\n * import { animationFrames, TimestampProvider } from 'rxjs';\r\n *\r\n * // A custom timestamp provider\r\n * let now = 0;\r\n * const customTSProvider: TimestampProvider = {\r\n *   now() { return now++; }\r\n * };\r\n *\r\n * const source$ = animationFrames(customTSProvider);\r\n *\r\n * // Log increasing numbers 0...1...2... on every animation frame.\r\n * source$.subscribe(({ elapsed }) => console.log(elapsed));\r\n * ```\r\n *\r\n * @param timestampProvider An object with a `now` method that provides a numeric timestamp\r\n */\r\nexport function animationFrames(timestampProvider?: TimestampProvider) {\r\n  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;\r\n}\r\n\r\n/**\r\n * Does the work of creating the observable for `animationFrames`.\r\n * @param timestampProvider The timestamp provider to use to create the observable\r\n */\r\nfunction animationFramesFactory(timestampProvider?: TimestampProvider) {\r\n  return new Observable<{ timestamp: number; elapsed: number }>((subscriber) => {\r\n    // If no timestamp provider is specified, use performance.now() - as it\r\n    // will return timestamps 'compatible' with those passed to the run\r\n    // callback and won't be affected by NTP adjustments, etc.\r\n    const provider = timestampProvider || performanceTimestampProvider;\r\n\r\n    // Capture the start time upon subscription, as the run callback can remain\r\n    // queued for a considerable period of time and the elapsed time should\r\n    // represent the time elapsed since subscription - not the time since the\r\n    // first rendered animation frame.\r\n    const start = provider.now();\r\n\r\n    let id = 0;\r\n    const run = () => {\r\n      if (!subscriber.closed) {\r\n        id = animationFrameProvider.requestAnimationFrame((timestamp: DOMHighResTimeStamp | number) => {\r\n          id = 0;\r\n          // Use the provider's timestamp to calculate the elapsed time. Note that\r\n          // this means - if the caller hasn't passed a provider - that\r\n          // performance.now() will be used instead of the timestamp that was\r\n          // passed to the run callback. The reason for this is that the timestamp\r\n          // passed to the callback can be earlier than the start time, as it\r\n          // represents the time at which the browser decided it would render any\r\n          // queued frames - and that time can be earlier the captured start time.\r\n          const now = provider.now();\r\n          subscriber.next({\r\n            timestamp: timestampProvider ? now : timestamp,\r\n            elapsed: now - start,\r\n          });\r\n          run();\r\n        });\r\n      }\r\n    };\r\n\r\n    run();\r\n\r\n    return () => {\r\n      if (id) {\r\n        animationFrameProvider.cancelAnimationFrame(id);\r\n      }\r\n    };\r\n  });\r\n}\r\n\r\n/**\r\n * In the common case, where the timestamp provided by the rAF API is used,\r\n * we use this shared observable to reduce overhead.\r\n */\r\nconst DEFAULT_ANIMATION_FRAMES = animationFramesFactory();\r\n", "import { createErrorClass } from './createErrorClass';\r\n\r\nexport interface ObjectUnsubscribedError extends Error {}\r\n\r\nexport interface ObjectUnsubscribedErrorCtor {\r\n  /**\r\n   * @deprecated Internal implementation detail. Do not construct error instances.\r\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\r\n   */\r\n  new (): ObjectUnsubscribedError;\r\n}\r\n\r\n/**\r\n * An error thrown when an action is invalid because the object has been\r\n * unsubscribed.\r\n *\r\n * @see {@link Subject}\r\n * @see {@link BehaviorSubject}\r\n *\r\n * @class ObjectUnsubscribedError\r\n */\r\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = createErrorClass(\r\n  (_super) =>\r\n    function ObjectUnsubscribedErrorImpl(this: any) {\r\n      _super(this);\r\n      this.name = 'ObjectUnsubscribedError';\r\n      this.message = 'object unsubscribed';\r\n    }\r\n);\r\n", "import { Operator } from './Operator';\r\nimport { Observable } from './Observable';\r\nimport { Subscriber } from './Subscriber';\r\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\r\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\r\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\r\nimport { arrRemove } from './util/arrRemove';\r\nimport { errorContext } from './util/errorContext';\r\n\r\n/**\r\n * A Subject is a special type of Observable that allows values to be\r\n * multicasted to many Observers. Subjects are like EventEmitters.\r\n *\r\n * Every Subject is an Observable and an Observer. You can subscribe to a\r\n * Subject, and you can call next to feed values as well as error and complete.\r\n */\r\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\r\n  closed = false;\r\n\r\n  private currentObservers: Observer<T>[] | null = null;\r\n\r\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\r\n  observers: Observer<T>[] = [];\r\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\r\n  isStopped = false;\r\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\r\n  hasError = false;\r\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\r\n  thrownError: any = null;\r\n\r\n  /**\r\n   * Creates a \"subject\" by basically gluing an observer to an observable.\r\n   *\r\n   * @deprecated Recommended you do not use. Will be removed at some point in the future. Plans for replacement still under discussion.\r\n   */\r\n  static create: (...args: any[]) => any = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\r\n    return new AnonymousSubject<T>(destination, source);\r\n  };\r\n\r\n  constructor() {\r\n    // NOTE: This must be here to obscure Observable's constructor.\r\n    super();\r\n  }\r\n\r\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\r\n  lift<R>(operator: Operator<T, R>): Observable<R> {\r\n    const subject = new AnonymousSubject(this, this);\r\n    subject.operator = operator as any;\r\n    return subject as any;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _throwIfClosed() {\r\n    if (this.closed) {\r\n      throw new ObjectUnsubscribedError();\r\n    }\r\n  }\r\n\r\n  next(value: T) {\r\n    errorContext(() => {\r\n      this._throwIfClosed();\r\n      if (!this.isStopped) {\r\n        if (!this.currentObservers) {\r\n          this.currentObservers = Array.from(this.observers);\r\n        }\r\n        for (const observer of this.currentObservers) {\r\n          observer.next(value);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  error(err: any) {\r\n    errorContext(() => {\r\n      this._throwIfClosed();\r\n      if (!this.isStopped) {\r\n        this.hasError = this.isStopped = true;\r\n        this.thrownError = err;\r\n        const { observers } = this;\r\n        while (observers.length) {\r\n          observers.shift()!.error(err);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  complete() {\r\n    errorContext(() => {\r\n      this._throwIfClosed();\r\n      if (!this.isStopped) {\r\n        this.isStopped = true;\r\n        const { observers } = this;\r\n        while (observers.length) {\r\n          observers.shift()!.complete();\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  unsubscribe() {\r\n    this.isStopped = this.closed = true;\r\n    this.observers = this.currentObservers = null!;\r\n  }\r\n\r\n  get observed() {\r\n    return this.observers?.length > 0;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\r\n    this._throwIfClosed();\r\n    return super._trySubscribe(subscriber);\r\n  }\r\n\r\n  /** @internal */\r\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\r\n    this._throwIfClosed();\r\n    this._checkFinalizedStatuses(subscriber);\r\n    return this._innerSubscribe(subscriber);\r\n  }\r\n\r\n  /** @internal */\r\n  protected _innerSubscribe(subscriber: Subscriber<any>) {\r\n    const { hasError, isStopped, observers } = this;\r\n    if (hasError || isStopped) {\r\n      return EMPTY_SUBSCRIPTION;\r\n    }\r\n    this.currentObservers = null;\r\n    observers.push(subscriber);\r\n    return new Subscription(() => {\r\n      this.currentObservers = null;\r\n      arrRemove(observers, subscriber);\r\n    });\r\n  }\r\n\r\n  /** @internal */\r\n  protected _checkFinalizedStatuses(subscriber: Subscriber<any>) {\r\n    const { hasError, thrownError, isStopped } = this;\r\n    if (hasError) {\r\n      subscriber.error(thrownError);\r\n    } else if (isStopped) {\r\n      subscriber.complete();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new Observable with this Subject as the source. You can do this\r\n   * to create custom Observer-side logic of the Subject and conceal it from\r\n   * code that uses the Observable.\r\n   * @return Observable that this Subject casts to.\r\n   */\r\n  asObservable(): Observable<T> {\r\n    const observable: any = new Observable<T>();\r\n    observable.source = this;\r\n    return observable;\r\n  }\r\n}\r\n\r\nexport class AnonymousSubject<T> extends Subject<T> {\r\n  constructor(\r\n    /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\r\n    public destination?: Observer<T>,\r\n    source?: Observable<T>\r\n  ) {\r\n    super();\r\n    this.source = source;\r\n  }\r\n\r\n  next(value: T) {\r\n    this.destination?.next?.(value);\r\n  }\r\n\r\n  error(err: any) {\r\n    this.destination?.error?.(err);\r\n  }\r\n\r\n  complete() {\r\n    this.destination?.complete?.();\r\n  }\r\n\r\n  /** @internal */\r\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\r\n    return this.source?.subscribe(subscriber) ?? EMPTY_SUBSCRIPTION;\r\n  }\r\n}\r\n", "import { Subject } from './Subject';\r\nimport { Subscriber } from './Subscriber';\r\nimport { Subscription } from './Subscription';\r\n\r\n/**\r\n * A variant of Subject that requires an initial value and emits its current\r\n * value whenever it is subscribed to.\r\n */\r\nexport class BehaviorSubject<T> extends Subject<T> {\r\n  constructor(private _value: T) {\r\n    super();\r\n  }\r\n\r\n  get value(): T {\r\n    return this.getValue();\r\n  }\r\n\r\n  /** @internal */\r\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\r\n    const subscription = super._subscribe(subscriber);\r\n    !subscription.closed && subscriber.next(this._value);\r\n    return subscription;\r\n  }\r\n\r\n  getValue(): T {\r\n    const { hasError, thrownError, _value } = this;\r\n    if (hasError) {\r\n      throw thrownError;\r\n    }\r\n    this._throwIfClosed();\r\n    return _value;\r\n  }\r\n\r\n  next(value: T): void {\r\n    super.next((this._value = value));\r\n  }\r\n}\r\n", "import { TimestampProvider } from '../types';\r\n\r\ninterface DateTimestampProvider extends TimestampProvider {\r\n  delegate: TimestampProvider | undefined;\r\n}\r\n\r\nexport const dateTimestampProvider: DateTimestampProvider = {\r\n  now() {\r\n    // Use the variable rather than `this` so that the function can be called\r\n    // without being bound to the provider.\r\n    return (dateTimestampProvider.delegate || Date).now();\r\n  },\r\n  delegate: undefined,\r\n};\r\n", "import { Subject } from './Subject';\r\nimport { TimestampProvider } from './types';\r\nimport { Subscriber } from './Subscriber';\r\nimport { Subscription } from './Subscription';\r\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\r\n\r\n/**\r\n * A variant of {@link Subject} that \"replays\" old values to new subscribers by emitting them when they first subscribe.\r\n *\r\n * `ReplaySubject` has an internal buffer that will store a specified number of values that it has observed. Like `Subject`,\r\n * `ReplaySubject` \"observes\" values by having them passed to its `next` method. When it observes a value, it will store that\r\n * value for a time determined by the configuration of the `ReplaySubject`, as passed to its constructor.\r\n *\r\n * When a new subscriber subscribes to the `ReplaySubject` instance, it will synchronously emit all values in its buffer in\r\n * a First-In-First-Out (FIFO) manner. The `ReplaySubject` will also complete, if it has observed completion; and it will\r\n * error if it has observed an error.\r\n *\r\n * There are two main configuration items to be concerned with:\r\n *\r\n * 1. `bufferSize` - This will determine how many items are stored in the buffer, defaults to infinite.\r\n * 2. `windowTime` - The amount of time to hold a value in the buffer before removing it from the buffer.\r\n *\r\n * Both configurations may exist simultaneously. So if you would like to buffer a maximum of 3 values, as long as the values\r\n * are less than 2 seconds old, you could do so with a `new ReplaySubject(3, 2000)`.\r\n *\r\n * ### Differences with BehaviorSubject\r\n *\r\n * `BehaviorSubject` is similar to `new ReplaySubject(1)`, with a couple of exceptions:\r\n *\r\n * 1. `BehaviorSubject` comes \"primed\" with a single value upon construction.\r\n * 2. `ReplaySubject` will replay values, even after observing an error, where `BehaviorSubject` will not.\r\n *\r\n * @see {@link Subject}\r\n * @see {@link BehaviorSubject}\r\n * @see {@link shareReplay}\r\n */\r\nexport class ReplaySubject<T> extends Subject<T> {\r\n  private _buffer: (T | number)[] = [];\r\n  private _infiniteTimeWindow = true;\r\n\r\n  /**\r\n   * @param _bufferSize The size of the buffer to replay on subscription\r\n   * @param _windowTime The amount of time the buffered items will stay buffered\r\n   * @param _timestampProvider An object with a `now()` method that provides the current timestamp. This is used to\r\n   * calculate the amount of time something has been buffered.\r\n   */\r\n  constructor(\r\n    private _bufferSize = Infinity,\r\n    private _windowTime = Infinity,\r\n    private _timestampProvider: TimestampProvider = dateTimestampProvider\r\n  ) {\r\n    super();\r\n    this._infiniteTimeWindow = _windowTime === Infinity;\r\n    this._bufferSize = Math.max(1, _bufferSize);\r\n    this._windowTime = Math.max(1, _windowTime);\r\n  }\r\n\r\n  next(value: T): void {\r\n    const { isStopped, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;\r\n    if (!isStopped) {\r\n      _buffer.push(value);\r\n      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);\r\n    }\r\n    this._trimBuffer();\r\n    super.next(value);\r\n  }\r\n\r\n  /** @internal */\r\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\r\n    this._throwIfClosed();\r\n    this._trimBuffer();\r\n\r\n    const subscription = this._innerSubscribe(subscriber);\r\n\r\n    const { _infiniteTimeWindow, _buffer } = this;\r\n    // We use a copy here, so reentrant code does not mutate our array while we're\r\n    // emitting it to a new subscriber.\r\n    const copy = _buffer.slice();\r\n    for (let i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {\r\n      subscriber.next(copy[i] as T);\r\n    }\r\n\r\n    this._checkFinalizedStatuses(subscriber);\r\n\r\n    return subscription;\r\n  }\r\n\r\n  private _trimBuffer() {\r\n    const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;\r\n    // If we don't have an infinite buffer size, and we're over the length,\r\n    // use splice to truncate the old buffer values off. Note that we have to\r\n    // double the size for instances where we're not using an infinite time window\r\n    // because we're storing the values and the timestamps in the same array.\r\n    const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;\r\n    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);\r\n\r\n    // Now, if we're not in an infinite time window, remove all values where the time is\r\n    // older than what is allowed.\r\n    if (!_infiniteTimeWindow) {\r\n      const now = _timestampProvider.now();\r\n      let last = 0;\r\n      // Search the array for the first timestamp that isn't expired and\r\n      // truncate the buffer up to that point.\r\n      for (let i = 1; i < _buffer.length && (_buffer[i] as number) <= now; i += 2) {\r\n        last = i;\r\n      }\r\n      last && _buffer.splice(0, last + 1);\r\n    }\r\n  }\r\n}\r\n", "import { Subject } from './Subject';\r\nimport { Subscriber } from './Subscriber';\r\n\r\n/**\r\n * A variant of Subject that only emits a value when it completes. It will emit\r\n * its latest value to all its observers on completion.\r\n */\r\nexport class AsyncSubject<T> extends Subject<T> {\r\n  private _value: T | null = null;\r\n  private _hasValue = false;\r\n  private _isComplete = false;\r\n\r\n  /** @internal */\r\n  protected _checkFinalizedStatuses(subscriber: Subscriber<T>) {\r\n    const { hasError, _hasValue, _value, thrownError, isStopped, _isComplete } = this;\r\n    if (hasError) {\r\n      subscriber.error(thrownError);\r\n    } else if (isStopped || _isComplete) {\r\n      _hasValue && subscriber.next(_value!);\r\n      subscriber.complete();\r\n    }\r\n  }\r\n\r\n  next(value: T): void {\r\n    if (!this.isStopped) {\r\n      this._value = value;\r\n      this._hasValue = true;\r\n    }\r\n  }\r\n\r\n  complete(): void {\r\n    const { _hasValue, _value, _isComplete } = this;\r\n    if (!_isComplete) {\r\n      this._isComplete = true;\r\n      _hasValue && super.next(_value!);\r\n      super.complete();\r\n    }\r\n  }\r\n}\r\n", "import { Scheduler } from '../Scheduler';\r\nimport { Subscription } from '../Subscription';\r\nimport { SchedulerAction } from '../types';\r\n\r\n/**\r\n * A unit of work to be executed in a `scheduler`. An action is typically\r\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\r\n * themselves about creating and manipulating an Action.\r\n *\r\n * ```ts\r\n * class Action<T> extends Subscription {\r\n *   new (scheduler: Scheduler, work: (state?: T) => void);\r\n *   schedule(state?: T, delay: number = 0): Subscription;\r\n * }\r\n * ```\r\n */\r\nexport class Action<T> extends Subscription {\r\n  constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void) {\r\n    super();\r\n  }\r\n  /**\r\n   * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\r\n   * some context object, `state`. May happen at some point in the future,\r\n   * according to the `delay` parameter, if specified.\r\n   * @param state Some contextual data that the `work` function uses when called by the\r\n   * Scheduler.\r\n   * @param delay Time to wait before executing the work, where the time unit is implicit\r\n   * and defined by the Scheduler.\r\n   * @return A subscription in order to be able to unsubscribe the scheduled work.\r\n   */\r\n  public schedule(state?: T, delay: number = 0): Subscription {\r\n    return this;\r\n  }\r\n}\r\n", "import type { TimerHandle } from './timerHandle';\r\ntype SetIntervalFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\r\ntype ClearIntervalFunction = (handle: TimerHandle) => void;\r\n\r\ninterface IntervalProvider {\r\n  setInterval: SetIntervalFunction;\r\n  clearInterval: ClearIntervalFunction;\r\n  delegate:\r\n    | {\r\n        setInterval: SetIntervalFunction;\r\n        clearInterval: ClearIntervalFunction;\r\n      }\r\n    | undefined;\r\n}\r\n\r\nexport const intervalProvider: IntervalProvider = {\r\n  // When accessing the delegate, use the variable rather than `this` so that\r\n  // the functions can be called without being bound to the provider.\r\n  setInterval(handler: () => void, timeout?: number, ...args) {\r\n    const { delegate } = intervalProvider;\r\n    if (delegate?.setInterval) {\r\n      return delegate.setInterval(handler, timeout, ...args);\r\n    }\r\n    return setInterval(handler, timeout, ...args);\r\n  },\r\n  clearInterval(handle) {\r\n    const { delegate } = intervalProvider;\r\n    return (delegate?.clearInterval || clearInterval)(handle as any);\r\n  },\r\n  delegate: undefined,\r\n};\r\n", "import { Action } from './Action';\r\nimport { SchedulerAction } from '../types';\r\nimport { Subscription } from '../Subscription';\r\nimport { AsyncScheduler } from './AsyncScheduler';\r\nimport { intervalProvider } from './intervalProvider';\r\nimport { arrRemove } from '../util/arrRemove';\r\nimport { TimerHandle } from './timerHandle';\r\n\r\nexport class AsyncAction<T> extends Action<T> {\r\n  public id: TimerHandle | undefined;\r\n  public state?: T;\r\n  // @ts-ignore: Property has no initializer and is not definitely assigned\r\n  public delay: number;\r\n  protected pending: boolean = false;\r\n\r\n  constructor(protected scheduler: AsyncScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\r\n    super(scheduler, work);\r\n  }\r\n\r\n  public schedule(state?: T, delay: number = 0): Subscription {\r\n    if (this.closed) {\r\n      return this;\r\n    }\r\n\r\n    // Always replace the current state with the new state.\r\n    this.state = state;\r\n\r\n    const id = this.id;\r\n    const scheduler = this.scheduler;\r\n\r\n    //\r\n    // Important implementation note:\r\n    //\r\n    // Actions only execute once by default, unless rescheduled from within the\r\n    // scheduled callback. This allows us to implement single and repeat\r\n    // actions via the same code path, without adding API surface area, as well\r\n    // as mimic traditional recursion but across asynchronous boundaries.\r\n    //\r\n    // However, JS runtimes and timers distinguish between intervals achieved by\r\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\r\n    // serial `setTimeout` calls can be individually delayed, which delays\r\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\r\n    // guarantee the interval callback will be invoked more precisely to the\r\n    // interval period, regardless of load.\r\n    //\r\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\r\n    // If the action reschedules itself with the same delay, the interval is not\r\n    // canceled. If the action doesn't reschedule, or reschedules with a\r\n    // different delay, the interval will be canceled after scheduled callback\r\n    // execution.\r\n    //\r\n    if (id != null) {\r\n      this.id = this.recycleAsyncId(scheduler, id, delay);\r\n    }\r\n\r\n    // Set the pending flag indicating that this action has been scheduled, or\r\n    // has recursively rescheduled itself.\r\n    this.pending = true;\r\n\r\n    this.delay = delay;\r\n    // If this action has already an async Id, don't request a new one.\r\n    this.id = this.id ?? this.requestAsyncId(scheduler, this.id, delay);\r\n\r\n    return this;\r\n  }\r\n\r\n  protected requestAsyncId(scheduler: AsyncScheduler, _id?: TimerHandle, delay: number = 0): TimerHandle {\r\n    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\r\n  }\r\n\r\n  protected recycleAsyncId(_scheduler: AsyncScheduler, id?: TimerHandle, delay: number | null = 0): TimerHandle | undefined {\r\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\r\n    if (delay != null && this.delay === delay && this.pending === false) {\r\n      return id;\r\n    }\r\n    // Otherwise, if the action's delay time is different from the current delay,\r\n    // or the action has been rescheduled before it's executed, clear the interval id\r\n    if (id != null) {\r\n      intervalProvider.clearInterval(id);\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Immediately executes this action and the `work` it contains.\r\n   */\r\n  public execute(state: T, delay: number): any {\r\n    if (this.closed) {\r\n      return new Error('executing a cancelled action');\r\n    }\r\n\r\n    this.pending = false;\r\n    const error = this._execute(state, delay);\r\n    if (error) {\r\n      return error;\r\n    } else if (this.pending === false && this.id != null) {\r\n      // Dequeue if the action didn't reschedule itself. Don't call\r\n      // unsubscribe(), because the action could reschedule later.\r\n      // For example:\r\n      // ```\r\n      // scheduler.schedule(function doWork(counter) {\r\n      //   /* ... I'm a busy worker bee ... */\r\n      //   var originalAction = this;\r\n      //   /* wait 100ms before rescheduling the action */\r\n      //   setTimeout(function () {\r\n      //     originalAction.schedule(counter + 1);\r\n      //   }, 100);\r\n      // }, 1000);\r\n      // ```\r\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\r\n    }\r\n  }\r\n\r\n  protected _execute(state: T, _delay: number): any {\r\n    let errored: boolean = false;\r\n    let errorValue: any;\r\n    try {\r\n      this.work(state);\r\n    } catch (e) {\r\n      errored = true;\r\n      // HACK: Since code elsewhere is relying on the \"truthiness\" of the\r\n      // return here, we can't have it return \"\" or 0 or false.\r\n      // TODO: Clean this up when we refactor schedulers mid-version-8 or so.\r\n      errorValue = e ? e : new Error('Scheduled action threw falsy error');\r\n    }\r\n    if (errored) {\r\n      this.unsubscribe();\r\n      return errorValue;\r\n    }\r\n  }\r\n\r\n  unsubscribe() {\r\n    if (!this.closed) {\r\n      const { id, scheduler } = this;\r\n      const { actions } = scheduler;\r\n\r\n      this.work = this.state = this.scheduler = null!;\r\n      this.pending = false;\r\n\r\n      arrRemove(actions, this);\r\n      if (id != null) {\r\n        this.id = this.recycleAsyncId(scheduler, id, null);\r\n      }\r\n\r\n      this.delay = null!;\r\n      super.unsubscribe();\r\n    }\r\n  }\r\n}\r\n", "let nextHandle = 1;\r\n// The promise needs to be created lazily otherwise it won't be patched by Zones\r\nlet resolved: Promise<any>;\r\nconst activeHandles: { [key: number]: any } = {};\r\n\r\n/**\r\n * Finds the handle in the list of active handles, and removes it.\r\n * Returns `true` if found, `false` otherwise. Used both to clear\r\n * Immediate scheduled tasks, and to identify if a task should be scheduled.\r\n */\r\nfunction findAndClearHandle(handle: number): boolean {\r\n  if (handle in activeHandles) {\r\n    delete activeHandles[handle];\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Helper functions to schedule and unschedule microtasks.\r\n */\r\nexport const Immediate = {\r\n  setImmediate(cb: () => void): number {\r\n    const handle = nextHandle++;\r\n    activeHandles[handle] = true;\r\n    if (!resolved) {\r\n      resolved = Promise.resolve();\r\n    }\r\n    resolved.then(() => findAndClearHandle(handle) && cb());\r\n    return handle;\r\n  },\r\n\r\n  clearImmediate(handle: number): void {\r\n    findAndClearHandle(handle);\r\n  },\r\n};\r\n\r\n/**\r\n * Used for internal testing purposes only. Do not export from library.\r\n */\r\nexport const TestTools = {\r\n  pending() {\r\n    return Object.keys(activeHandles).length;\r\n  }\r\n};\r\n", "import { Immediate } from '../util/Immediate';\r\nimport type { TimerHandle } from './timerHandle';\r\nconst { setImmediate, clearImmediate } = Immediate;\r\n\r\ntype SetImmediateFunction = (handler: () => void, ...args: any[]) => TimerHandle;\r\ntype ClearImmediateFunction = (handle: TimerHandle) => void;\r\n\r\ninterface ImmediateProvider {\r\n  setImmediate: SetImmediateFunction;\r\n  clearImmediate: ClearImmediateFunction;\r\n  delegate:\r\n    | {\r\n        setImmediate: SetImmediateFunction;\r\n        clearImmediate: ClearImmediateFunction;\r\n      }\r\n    | undefined;\r\n}\r\n\r\nexport const immediateProvider: ImmediateProvider = {\r\n  // When accessing the delegate, use the variable rather than `this` so that\r\n  // the functions can be called without being bound to the provider.\r\n  setImmediate(...args) {\r\n    const { delegate } = immediateProvider;\r\n    return (delegate?.setImmediate || setImmediate)(...args);\r\n  },\r\n  clearImmediate(handle) {\r\n    const { delegate } = immediateProvider;\r\n    return (delegate?.clearImmediate || clearImmediate)(handle as any);\r\n  },\r\n  delegate: undefined,\r\n};\r\n", "import { AsyncAction } from './AsyncAction';\r\nimport { AsapScheduler } from './AsapScheduler';\r\nimport { SchedulerAction } from '../types';\r\nimport { immediateProvider } from './immediateProvider';\r\nimport { TimerHandle } from './timerHandle';\r\n\r\nexport class AsapAction<T> extends AsyncAction<T> {\r\n  constructor(protected scheduler: AsapScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\r\n    super(scheduler, work);\r\n  }\r\n\r\n  protected requestAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\r\n    // If delay is greater than 0, request as an async action.\r\n    if (delay !== null && delay > 0) {\r\n      return super.requestAsyncId(scheduler, id, delay);\r\n    }\r\n    // Push the action to the end of the scheduler queue.\r\n    scheduler.actions.push(this);\r\n    // If a microtask has already been scheduled, don't schedule another\r\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\r\n    // the current scheduled microtask id.\r\n    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));\r\n  }\r\n\r\n  protected recycleAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\r\n    // If delay exists and is greater than 0, or if the delay is null (the\r\n    // action wasn't rescheduled) but was originally scheduled as an async\r\n    // action, then recycle as an async action.\r\n    if (delay != null ? delay > 0 : this.delay > 0) {\r\n      return super.recycleAsyncId(scheduler, id, delay);\r\n    }\r\n    // If the scheduler queue has no remaining actions with the same async id,\r\n    // cancel the requested microtask and set the scheduled flag to undefined\r\n    // so the next AsapAction will request its own.\r\n    const { actions } = scheduler;\r\n    if (id != null && actions[actions.length - 1]?.id !== id) {\r\n      immediateProvider.clearImmediate(id);\r\n      if (scheduler._scheduled === id) {\r\n        scheduler._scheduled = undefined;\r\n      }\r\n    }\r\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\r\n    return undefined;\r\n  }\r\n}\r\n", "import { Action } from './scheduler/Action';\r\nimport { Subscription } from './Subscription';\r\nimport { SchedulerLike, SchedulerAction } from './types';\r\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\r\n\r\n/**\r\n * An execution context and a data structure to order tasks and schedule their\r\n * execution. Provides a notion of (potentially virtual) time, through the\r\n * `now()` getter method.\r\n *\r\n * Each unit of work in a Scheduler is called an `Action`.\r\n *\r\n * ```ts\r\n * class Scheduler {\r\n *   now(): number;\r\n *   schedule(work, delay?, state?): Subscription;\r\n * }\r\n * ```\r\n *\r\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\r\n * should not be used directly. Rather, create your own class and implement\r\n * {@link SchedulerLike}. Will be made internal in v8.\r\n */\r\nexport class Scheduler implements SchedulerLike {\r\n  public static now: () => number = dateTimestampProvider.now;\r\n\r\n  constructor(private schedulerActionCtor: typeof Action, now: () => number = Scheduler.now) {\r\n    this.now = now;\r\n  }\r\n\r\n  /**\r\n   * A getter method that returns a number representing the current time\r\n   * (at the time this function was called) according to the scheduler's own\r\n   * internal clock.\r\n   * @return A number that represents the current time. May or may not\r\n   * have a relation to wall-clock time. May or may not refer to a time unit\r\n   * (e.g. milliseconds).\r\n   */\r\n  public now: () => number;\r\n\r\n  /**\r\n   * Schedules a function, `work`, for execution. May happen at some point in\r\n   * the future, according to the `delay` parameter, if specified. May be passed\r\n   * some context object, `state`, which will be passed to the `work` function.\r\n   *\r\n   * The given arguments will be processed an stored as an Action object in a\r\n   * queue of actions.\r\n   *\r\n   * @param work A function representing a task, or some unit of work to be\r\n   * executed by the Scheduler.\r\n   * @param delay Time to wait before executing the work, where the time unit is\r\n   * implicit and defined by the Scheduler itself.\r\n   * @param state Some contextual data that the `work` function uses when called\r\n   * by the Scheduler.\r\n   * @return A subscription in order to be able to unsubscribe the scheduled work.\r\n   */\r\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\r\n    return new this.schedulerActionCtor<T>(this, work).schedule(state, delay);\r\n  }\r\n}\r\n", "import { Scheduler } from '../Scheduler';\r\nimport { Action } from './Action';\r\nimport { AsyncAction } from './AsyncAction';\r\nimport { TimerHandle } from './timerHandle';\r\n\r\nexport class AsyncScheduler extends Scheduler {\r\n  public actions: Array<AsyncAction<any>> = [];\r\n  /**\r\n   * A flag to indicate whether the Scheduler is currently executing a batch of\r\n   * queued actions.\r\n   * @internal\r\n   */\r\n  public _active: boolean = false;\r\n  /**\r\n   * An internal ID used to track the latest asynchronous task such as those\r\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\r\n   * others.\r\n   * @internal\r\n   */\r\n  public _scheduled: TimerHandle | undefined;\r\n\r\n  constructor(SchedulerAction: typeof Action, now: () => number = Scheduler.now) {\r\n    super(SchedulerAction, now);\r\n  }\r\n\r\n  public flush(action: AsyncAction<any>): void {\r\n    const { actions } = this;\r\n\r\n    if (this._active) {\r\n      actions.push(action);\r\n      return;\r\n    }\r\n\r\n    let error: any;\r\n    this._active = true;\r\n\r\n    do {\r\n      if ((error = action.execute(action.state, action.delay))) {\r\n        break;\r\n      }\r\n    } while ((action = actions.shift()!)); // exhaust the scheduler queue\r\n\r\n    this._active = false;\r\n\r\n    if (error) {\r\n      while ((action = actions.shift()!)) {\r\n        action.unsubscribe();\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n", "import { AsyncAction } from './AsyncAction';\r\nimport { AsyncScheduler } from './AsyncScheduler';\r\n\r\nexport class AsapScheduler extends AsyncScheduler {\r\n  public flush(action?: AsyncAction<any>): void {\r\n    this._active = true;\r\n    // The async id that effects a call to flush is stored in _scheduled.\r\n    // Before executing an action, it's necessary to check the action's async\r\n    // id to determine whether it's supposed to be executed in the current\r\n    // flush.\r\n    // Previous implementations of this method used a count to determine this,\r\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\r\n    // are removed from the actions array and that can shift actions that are\r\n    // scheduled to be executed in a subsequent flush into positions at which\r\n    // they are executed within the current flush.\r\n    const flushId = this._scheduled;\r\n    this._scheduled = undefined;\r\n\r\n    const { actions } = this;\r\n    let error: any;\r\n    action = action || actions.shift()!;\r\n\r\n    do {\r\n      if ((error = action.execute(action.state, action.delay))) {\r\n        break;\r\n      }\r\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\r\n\r\n    this._active = false;\r\n\r\n    if (error) {\r\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\r\n        action.unsubscribe();\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n", "import { AsapAction } from './AsapAction';\r\nimport { AsapScheduler } from './AsapScheduler';\r\n\r\n/**\r\n *\r\n * Asap Scheduler\r\n *\r\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\r\n *\r\n * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task\r\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\r\n * code to end and then it will try to execute given task as fast as possible.\r\n *\r\n * `asap` scheduler will do its best to minimize time between end of currently executing code\r\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\r\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\r\n * some (although minimal) unwanted delay.\r\n *\r\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\r\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\r\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\r\n * as soon as possible, `asap` scheduler is your best bet.\r\n *\r\n * ## Example\r\n * Compare async and asap scheduler<\r\n * ```ts\r\n * import { asapScheduler, asyncScheduler } from 'rxjs';\r\n *\r\n * asyncScheduler.schedule(() => console.log('async')); // scheduling 'async' first...\r\n * asapScheduler.schedule(() => console.log('asap'));\r\n *\r\n * // Logs:\r\n * // \"asap\"\r\n * // \"async\"\r\n * // ... but 'asap' goes first!\r\n * ```\r\n */\r\n\r\nexport const asapScheduler = new AsapScheduler(AsapAction);\r\n\r\n/**\r\n * @deprecated Renamed to {@link asapScheduler}. Will be removed in v8.\r\n */\r\nexport const asap = asapScheduler;\r\n", "import { AsyncAction } from './AsyncAction';\r\nimport { AsyncScheduler } from './AsyncScheduler';\r\n\r\n/**\r\n *\r\n * Async Scheduler\r\n *\r\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\r\n *\r\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\r\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\r\n * in intervals.\r\n *\r\n * If you just want to \"defer\" task, that is to perform it right after currently\r\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\r\n * better choice will be the {@link asapScheduler} scheduler.\r\n *\r\n * ## Examples\r\n * Use async scheduler to delay task\r\n * ```ts\r\n * import { asyncScheduler } from 'rxjs';\r\n *\r\n * const task = () => console.log('it works!');\r\n *\r\n * asyncScheduler.schedule(task, 2000);\r\n *\r\n * // After 2 seconds logs:\r\n * // \"it works!\"\r\n * ```\r\n *\r\n * Use async scheduler to repeat task in intervals\r\n * ```ts\r\n * import { asyncScheduler } from 'rxjs';\r\n *\r\n * function task(state) {\r\n *   console.log(state);\r\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\r\n *                                   // which we reschedule with new state and delay\r\n * }\r\n *\r\n * asyncScheduler.schedule(task, 3000, 0);\r\n *\r\n * // Logs:\r\n * // 0 after 3s\r\n * // 1 after 4s\r\n * // 2 after 5s\r\n * // 3 after 6s\r\n * ```\r\n */\r\n\r\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\r\n\r\n/**\r\n * @deprecated Renamed to {@link asyncScheduler}. Will be removed in v8.\r\n */\r\nexport const async = asyncScheduler;\r\n", "import { AsyncAction } from './AsyncAction';\r\nimport { Subscription } from '../Subscription';\r\nimport { QueueScheduler } from './QueueScheduler';\r\nimport { SchedulerAction } from '../types';\r\nimport { TimerHandle } from './timerHandle';\r\n\r\nexport class QueueAction<T> extends AsyncAction<T> {\r\n  constructor(protected scheduler: QueueScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\r\n    super(scheduler, work);\r\n  }\r\n\r\n  public schedule(state?: T, delay: number = 0): Subscription {\r\n    if (delay > 0) {\r\n      return super.schedule(state, delay);\r\n    }\r\n    this.delay = delay;\r\n    this.state = state;\r\n    this.scheduler.flush(this);\r\n    return this;\r\n  }\r\n\r\n  public execute(state: T, delay: number): any {\r\n    return delay > 0 || this.closed ? super.execute(state, delay) : this._execute(state, delay);\r\n  }\r\n\r\n  protected requestAsyncId(scheduler: QueueScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\r\n    // If delay exists and is greater than 0, or if the delay is null (the\r\n    // action wasn't rescheduled) but was originally scheduled as an async\r\n    // action, then recycle as an async action.\r\n\r\n    if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {\r\n      return super.requestAsyncId(scheduler, id, delay);\r\n    }\r\n\r\n    // Otherwise flush the scheduler starting with this action.\r\n    scheduler.flush(this);\r\n\r\n    // HACK: In the past, this was returning `void`. However, `void` isn't a valid\r\n    // `TimerHandle`, and generally the return value here isn't really used. So the\r\n    // compromise is to return `0` which is both \"falsy\" and a valid `TimerHandle`,\r\n    // as opposed to refactoring every other instanceo of `requestAsyncId`.\r\n    return 0;\r\n  }\r\n}\r\n", "import { AsyncScheduler } from './AsyncScheduler';\r\n\r\nexport class QueueScheduler extends AsyncScheduler {\r\n}\r\n", "import { QueueAction } from './QueueAction';\r\nimport { QueueScheduler } from './QueueScheduler';\r\n\r\n/**\r\n *\r\n * Queue Scheduler\r\n *\r\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\r\n *\r\n * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\r\n *\r\n * When used without delay, it schedules given task synchronously - executes it right when\r\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\r\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\r\n * that task will be put on a queue and wait for current one to finish.\r\n *\r\n * This means that when you execute task with `queue` scheduler, you are sure it will end\r\n * before any other task scheduled with that scheduler will start.\r\n *\r\n * ## Examples\r\n * Schedule recursively first, then do something\r\n * ```ts\r\n * import { queueScheduler } from 'rxjs';\r\n *\r\n * queueScheduler.schedule(() => {\r\n *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\r\n *\r\n *   console.log('first');\r\n * });\r\n *\r\n * // Logs:\r\n * // \"first\"\r\n * // \"second\"\r\n * ```\r\n *\r\n * Reschedule itself recursively\r\n * ```ts\r\n * import { queueScheduler } from 'rxjs';\r\n *\r\n * queueScheduler.schedule(function(state) {\r\n *   if (state !== 0) {\r\n *     console.log('before', state);\r\n *     this.schedule(state - 1); // `this` references currently executing Action,\r\n *                               // which we reschedule with new state\r\n *     console.log('after', state);\r\n *   }\r\n * }, 0, 3);\r\n *\r\n * // In scheduler that runs recursively, you would expect:\r\n * // \"before\", 3\r\n * // \"before\", 2\r\n * // \"before\", 1\r\n * // \"after\", 1\r\n * // \"after\", 2\r\n * // \"after\", 3\r\n *\r\n * // But with queue it logs:\r\n * // \"before\", 3\r\n * // \"after\", 3\r\n * // \"before\", 2\r\n * // \"after\", 2\r\n * // \"before\", 1\r\n * // \"after\", 1\r\n * ```\r\n */\r\n\r\nexport const queueScheduler = new QueueScheduler(QueueAction);\r\n\r\n/**\r\n * @deprecated Renamed to {@link queueScheduler}. Will be removed in v8.\r\n */\r\nexport const queue = queueScheduler;\r\n", "import { AsyncAction } from './AsyncAction';\r\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\r\nimport { SchedulerAction } from '../types';\r\nimport { animationFrameProvider } from './animationFrameProvider';\r\nimport { TimerHandle } from './timerHandle';\r\n\r\nexport class AnimationFrameAction<T> extends AsyncAction<T> {\r\n  constructor(protected scheduler: AnimationFrameScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\r\n    super(scheduler, work);\r\n  }\r\n\r\n  protected requestAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\r\n    // If delay is greater than 0, request as an async action.\r\n    if (delay !== null && delay > 0) {\r\n      return super.requestAsyncId(scheduler, id, delay);\r\n    }\r\n    // Push the action to the end of the scheduler queue.\r\n    scheduler.actions.push(this);\r\n    // If an animation frame has already been requested, don't request another\r\n    // one. If an animation frame hasn't been requested yet, request one. Return\r\n    // the current animation frame request id.\r\n    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(() => scheduler.flush(undefined)));\r\n  }\r\n\r\n  protected recycleAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\r\n    // If delay exists and is greater than 0, or if the delay is null (the\r\n    // action wasn't rescheduled) but was originally scheduled as an async\r\n    // action, then recycle as an async action.\r\n    if (delay != null ? delay > 0 : this.delay > 0) {\r\n      return super.recycleAsyncId(scheduler, id, delay);\r\n    }\r\n    // If the scheduler queue has no remaining actions with the same async id,\r\n    // cancel the requested animation frame and set the scheduled flag to\r\n    // undefined so the next AnimationFrameAction will request its own.\r\n    const { actions } = scheduler;\r\n    if (id != null && id === scheduler._scheduled && actions[actions.length - 1]?.id !== id) {\r\n      animationFrameProvider.cancelAnimationFrame(id as number);\r\n      scheduler._scheduled = undefined;\r\n    }\r\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\r\n    return undefined;\r\n  }\r\n}\r\n", "import { AsyncAction } from './AsyncAction';\r\nimport { AsyncScheduler } from './AsyncScheduler';\r\n\r\nexport class AnimationFrameScheduler extends AsyncScheduler {\r\n  public flush(action?: AsyncAction<any>): void {\r\n    this._active = true;\r\n    // The async id that effects a call to flush is stored in _scheduled.\r\n    // Before executing an action, it's necessary to check the action's async\r\n    // id to determine whether it's supposed to be executed in the current\r\n    // flush.\r\n    // Previous implementations of this method used a count to determine this,\r\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\r\n    // are removed from the actions array and that can shift actions that are\r\n    // scheduled to be executed in a subsequent flush into positions at which\r\n    // they are executed within the current flush.\r\n    let flushId;\r\n    if (action) {\r\n      flushId = action.id;\r\n    } else {\r\n      flushId = this._scheduled;\r\n      this._scheduled = undefined;\r\n    }\r\n\r\n    const { actions } = this;\r\n    let error: any;\r\n    action = action || actions.shift()!;\r\n\r\n    do {\r\n      if ((error = action.execute(action.state, action.delay))) {\r\n        break;\r\n      }\r\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\r\n\r\n    this._active = false;\r\n\r\n    if (error) {\r\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\r\n        action.unsubscribe();\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n", "import { AnimationFrameAction } from './AnimationFrameAction';\r\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\r\n\r\n/**\r\n *\r\n * Animation Frame Scheduler\r\n *\r\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\r\n *\r\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler\r\n * behaviour.\r\n *\r\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\r\n * It makes sure scheduled task will happen just before next browser content repaint,\r\n * thus performing animations as efficiently as possible.\r\n *\r\n * ## Example\r\n * Schedule div height animation\r\n * ```ts\r\n * // html: <div style=\"background: #0ff;\"></div>\r\n * import { animationFrameScheduler } from 'rxjs';\r\n *\r\n * const div = document.querySelector('div');\r\n *\r\n * animationFrameScheduler.schedule(function(height) {\r\n *   div.style.height = height + \"px\";\r\n *\r\n *   this.schedule(height + 1);  // `this` references currently executing Action,\r\n *                               // which we reschedule with new state\r\n * }, 0, 0);\r\n *\r\n * // You will see a div element growing in height\r\n * ```\r\n */\r\n\r\nexport const animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);\r\n\r\n/**\r\n * @deprecated Renamed to {@link animationFrameScheduler}. Will be removed in v8.\r\n */\r\nexport const animationFrame = animationFrameScheduler;\r\n", "import { AsyncAction } from './AsyncAction';\r\nimport { Subscription } from '../Subscription';\r\nimport { AsyncScheduler } from './AsyncScheduler';\r\nimport { SchedulerAction } from '../types';\r\nimport { TimerHandle } from './timerHandle';\r\n\r\nexport class VirtualTimeScheduler extends AsyncScheduler {\r\n  /** @deprecated Not used in VirtualTimeScheduler directly. Will be removed in v8. */\r\n  static frameTimeFactor = 10;\r\n\r\n  /**\r\n   * The current frame for the state of the virtual scheduler instance. The difference\r\n   * between two \"frames\" is synonymous with the passage of \"virtual time units\". So if\r\n   * you record `scheduler.frame` to be `1`, then later, observe `scheduler.frame` to be at `11`,\r\n   * that means `10` virtual time units have passed.\r\n   */\r\n  public frame: number = 0;\r\n\r\n  /**\r\n   * Used internally to examine the current virtual action index being processed.\r\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\r\n   */\r\n  public index: number = -1;\r\n\r\n  /**\r\n   * This creates an instance of a `VirtualTimeScheduler`. Experts only. The signature of\r\n   * this constructor is likely to change in the long run.\r\n   *\r\n   * @param schedulerActionCtor The type of Action to initialize when initializing actions during scheduling.\r\n   * @param maxFrames The maximum number of frames to process before stopping. Used to prevent endless flush cycles.\r\n   */\r\n  constructor(schedulerActionCtor: typeof AsyncAction = VirtualAction as any, public maxFrames: number = Infinity) {\r\n    super(schedulerActionCtor, () => this.frame);\r\n  }\r\n\r\n  /**\r\n   * Prompt the Scheduler to execute all of its queued actions, therefore\r\n   * clearing its queue.\r\n   */\r\n  public flush(): void {\r\n    const { actions, maxFrames } = this;\r\n    let error: any;\r\n    let action: AsyncAction<any> | undefined;\r\n\r\n    while ((action = actions[0]) && action.delay <= maxFrames) {\r\n      actions.shift();\r\n      this.frame = action.delay;\r\n\r\n      if ((error = action.execute(action.state, action.delay))) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (error) {\r\n      while ((action = actions.shift())) {\r\n        action.unsubscribe();\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\nexport class VirtualAction<T> extends AsyncAction<T> {\r\n  protected active: boolean = true;\r\n\r\n  constructor(\r\n    protected scheduler: VirtualTimeScheduler,\r\n    protected work: (this: SchedulerAction<T>, state?: T) => void,\r\n    protected index: number = (scheduler.index += 1)\r\n  ) {\r\n    super(scheduler, work);\r\n    this.index = scheduler.index = index;\r\n  }\r\n\r\n  public schedule(state?: T, delay: number = 0): Subscription {\r\n    if (Number.isFinite(delay)) {\r\n      if (!this.id) {\r\n        return super.schedule(state, delay);\r\n      }\r\n      this.active = false;\r\n      // If an action is rescheduled, we save allocations by mutating its state,\r\n      // pushing it to the end of the scheduler queue, and recycling the action.\r\n      // But since the VirtualTimeScheduler is used for testing, VirtualActions\r\n      // must be immutable so they can be inspected later.\r\n      const action = new VirtualAction(this.scheduler, this.work);\r\n      this.add(action);\r\n      return action.schedule(state, delay);\r\n    } else {\r\n      // If someone schedules something with Infinity, it'll never happen. So we\r\n      // don't even schedule it.\r\n      return Subscription.EMPTY;\r\n    }\r\n  }\r\n\r\n  protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle {\r\n    this.delay = scheduler.frame + delay;\r\n    const { actions } = scheduler;\r\n    actions.push(this);\r\n    (actions as Array<VirtualAction<T>>).sort(VirtualAction.sortActions);\r\n    return 1;\r\n  }\r\n\r\n  protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle | undefined {\r\n    return undefined;\r\n  }\r\n\r\n  protected _execute(state: T, delay: number): any {\r\n    if (this.active === true) {\r\n      return super._execute(state, delay);\r\n    }\r\n  }\r\n\r\n  private static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>) {\r\n    if (a.delay === b.delay) {\r\n      if (a.index === b.index) {\r\n        return 0;\r\n      } else if (a.index > b.index) {\r\n        return 1;\r\n      } else {\r\n        return -1;\r\n      }\r\n    } else if (a.delay > b.delay) {\r\n      return 1;\r\n    } else {\r\n      return -1;\r\n    }\r\n  }\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { SchedulerLike } from '../types';\r\n\r\n/**\r\n * A simple Observable that emits no items to the Observer and immediately\r\n * emits a complete notification.\r\n *\r\n * <span class=\"informal\">Just emits 'complete', and nothing else.</span>\r\n *\r\n * ![](empty.png)\r\n *\r\n * A simple Observable that only emits the complete notification. It can be used\r\n * for composing with other Observables, such as in a {@link mergeMap}.\r\n *\r\n * ## Examples\r\n *\r\n * Log complete notification\r\n *\r\n * ```ts\r\n * import { EMPTY } from 'rxjs';\r\n *\r\n * EMPTY.subscribe({\r\n *   next: () => console.log('Next'),\r\n *   complete: () => console.log('Complete!')\r\n * });\r\n *\r\n * // Outputs\r\n * // Complete!\r\n * ```\r\n *\r\n * Emit the number 7, then complete\r\n *\r\n * ```ts\r\n * import { EMPTY, startWith } from 'rxjs';\r\n *\r\n * const result = EMPTY.pipe(startWith(7));\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Outputs\r\n * // 7\r\n * ```\r\n *\r\n * Map and flatten only odd numbers to the sequence `'a'`, `'b'`, `'c'`\r\n *\r\n * ```ts\r\n * import { interval, mergeMap, of, EMPTY } from 'rxjs';\r\n *\r\n * const interval$ = interval(1000);\r\n * const result = interval$.pipe(\r\n *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : EMPTY),\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Results in the following to the console:\r\n * // x is equal to the count on the interval, e.g. (0, 1, 2, 3, ...)\r\n * // x will occur every 1000ms\r\n * // if x % 2 is equal to 1, print a, b, c (each on its own)\r\n * // if x % 2 is not equal to 1, nothing will be output\r\n * ```\r\n *\r\n * @see {@link Observable}\r\n * @see {@link NEVER}\r\n * @see {@link of}\r\n * @see {@link throwError}\r\n */\r\nexport const EMPTY = new Observable<never>((subscriber) => subscriber.complete());\r\n\r\n/**\r\n * @param scheduler A {@link SchedulerLike} to use for scheduling\r\n * the emission of the complete notification.\r\n * @deprecated Replaced with the {@link EMPTY} constant or {@link scheduled} (e.g. `scheduled([], scheduler)`). Will be removed in v8.\r\n */\r\nexport function empty(scheduler?: SchedulerLike) {\r\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\r\n}\r\n\r\nfunction emptyScheduled(scheduler: SchedulerLike) {\r\n  return new Observable<never>((subscriber) => scheduler.schedule(() => subscriber.complete()));\r\n}\r\n", "import { SchedulerLike } from '../types';\r\nimport { isFunction } from './isFunction';\r\n\r\nexport function isScheduler(value: any): value is SchedulerLike {\r\n  return value && isFunction(value.schedule);\r\n}\r\n", "import { SchedulerLike } from '../types';\r\nimport { isFunction } from './isFunction';\r\nimport { isScheduler } from './isScheduler';\r\n\r\nfunction last<T>(arr: T[]): T | undefined {\r\n  return arr[arr.length - 1];\r\n}\r\n\r\nexport function popResultSelector(args: any[]): ((...args: unknown[]) => unknown) | undefined {\r\n  return isFunction(last(args)) ? args.pop() : undefined;\r\n}\r\n\r\nexport function popScheduler(args: any[]): SchedulerLike | undefined {\r\n  return isScheduler(last(args)) ? args.pop() : undefined;\r\n}\r\n\r\nexport function popNumber(args: any[], defaultValue: number): number {\r\n  return typeof last(args) === 'number' ? args.pop()! : defaultValue;\r\n}\r\n", "import { Subscription } from '../Subscription';\r\nimport { SchedulerAction, SchedulerLike } from '../types';\r\n\r\nexport function executeSchedule(\r\n  parentSubscription: Subscription,\r\n  scheduler: SchedulerLike,\r\n  work: () => void,\r\n  delay: number,\r\n  repeat: true\r\n): void;\r\nexport function executeSchedule(\r\n  parentSubscription: Subscription,\r\n  scheduler: SchedulerLike,\r\n  work: () => void,\r\n  delay?: number,\r\n  repeat?: false\r\n): Subscription;\r\n\r\nexport function executeSchedule(\r\n  parentSubscription: Subscription,\r\n  scheduler: SchedulerLike,\r\n  work: () => void,\r\n  delay = 0,\r\n  repeat = false\r\n): Subscription | void {\r\n  const scheduleSubscription = scheduler.schedule(function (this: SchedulerAction<any>) {\r\n    work();\r\n    if (repeat) {\r\n      parentSubscription.add(this.schedule(null, delay));\r\n    } else {\r\n      this.unsubscribe();\r\n    }\r\n  }, delay);\r\n\r\n  parentSubscription.add(scheduleSubscription);\r\n\r\n  if (!repeat) {\r\n    // Because user-land scheduler implementations are unlikely to properly reuse\r\n    // Actions for repeat scheduling, we can't trust that the returned subscription\r\n    // will control repeat subscription scenarios. So we're trying to avoid using them\r\n    // incorrectly within this library.\r\n    return scheduleSubscription;\r\n  }\r\n}\r\n", "/** @prettier */\r\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\r\nimport { executeSchedule } from '../util/executeSchedule';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Re-emits all notifications from source Observable with specified scheduler.\r\n *\r\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\r\n *\r\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\r\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\r\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\r\n *\r\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\r\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\r\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\r\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\r\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\r\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\r\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\r\n * little bit more, to ensure that they are emitted at expected moments.\r\n *\r\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\r\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\r\n * will delay all notifications - including error notifications - while `delay` will pass through error\r\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\r\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\r\n * for notification emissions in general.\r\n *\r\n * ## Example\r\n *\r\n * Ensure values in subscribe are called just before browser repaint\r\n *\r\n * ```ts\r\n * import { interval, observeOn, animationFrameScheduler } from 'rxjs';\r\n *\r\n * const someDiv = document.createElement('div');\r\n * someDiv.style.cssText = 'width: 200px;background: #09c';\r\n * document.body.appendChild(someDiv);\r\n * const intervals = interval(10);      // Intervals are scheduled\r\n *                                      // with async scheduler by default...\r\n * intervals.pipe(\r\n *   observeOn(animationFrameScheduler) // ...but we will observe on animationFrame\r\n * )                                    // scheduler to ensure smooth animation.\r\n * .subscribe(val => {\r\n *   someDiv.style.height = val + 'px';\r\n * });\r\n * ```\r\n *\r\n * @see {@link delay}\r\n *\r\n * @param scheduler Scheduler that will be used to reschedule notifications from source Observable.\r\n * @param delay Number of milliseconds that states with what delay every notification should be rescheduled.\r\n * @return A function that returns an Observable that emits the same\r\n * notifications as the source Observable, but with provided scheduler.\r\n */\r\nexport function observeOn<T>(scheduler: SchedulerLike, delay = 0): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value) => executeSchedule(subscriber, scheduler, () => subscriber.next(value), delay),\r\n        () => executeSchedule(subscriber, scheduler, () => subscriber.complete(), delay),\r\n        (err) => executeSchedule(subscriber, scheduler, () => subscriber.error(err), delay)\r\n      )\r\n    );\r\n  });\r\n}\r\n", "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\r\nimport { operate } from '../util/lift';\r\n\r\n/**\r\n * Asynchronously subscribes Observers to this Observable on the specified {@link SchedulerLike}.\r\n *\r\n * With `subscribeOn` you can decide what type of scheduler a specific Observable will be using when it is subscribed to.\r\n *\r\n * Schedulers control the speed and order of emissions to observers from an Observable stream.\r\n *\r\n * ![](subscribeOn.png)\r\n *\r\n * ## Example\r\n *\r\n * Given the following code:\r\n *\r\n * ```ts\r\n * import { of, merge } from 'rxjs';\r\n *\r\n * const a = of(1, 2, 3);\r\n * const b = of(4, 5, 6);\r\n *\r\n * merge(a, b).subscribe(console.log);\r\n *\r\n * // Outputs\r\n * // 1\r\n * // 2\r\n * // 3\r\n * // 4\r\n * // 5\r\n * // 6\r\n * ```\r\n *\r\n * Both Observable `a` and `b` will emit their values directly and synchronously once they are subscribed to.\r\n *\r\n * If we instead use the `subscribeOn` operator declaring that we want to use the {@link asyncScheduler} for values emitted by Observable `a`:\r\n *\r\n * ```ts\r\n * import { of, subscribeOn, asyncScheduler, merge } from 'rxjs';\r\n *\r\n * const a = of(1, 2, 3).pipe(subscribeOn(asyncScheduler));\r\n * const b = of(4, 5, 6);\r\n *\r\n * merge(a, b).subscribe(console.log);\r\n *\r\n * // Outputs\r\n * // 4\r\n * // 5\r\n * // 6\r\n * // 1\r\n * // 2\r\n * // 3\r\n * ```\r\n *\r\n * The reason for this is that Observable `b` emits its values directly and synchronously like before\r\n * but the emissions from `a` are scheduled on the event loop because we are now using the {@link asyncScheduler} for that specific Observable.\r\n *\r\n * @param scheduler The {@link SchedulerLike} to perform subscription actions on.\r\n * @param delay A delay to pass to the scheduler to delay subscriptions\r\n * @return A function that returns an Observable modified so that its\r\n * subscriptions happen on the specified {@link SchedulerLike}.\r\n */\r\nexport function subscribeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));\r\n  });\r\n}\r\n", "import { innerFrom } from '../observable/innerFrom';\r\nimport { observeOn } from '../operators/observeOn';\r\nimport { subscribeOn } from '../operators/subscribeOn';\r\nimport { InteropObservable, SchedulerLike } from '../types';\r\n\r\nexport function scheduleObservable<T>(input: InteropObservable<T>, scheduler: SchedulerLike) {\r\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\r\n}\r\n", "import { innerFrom } from '../observable/innerFrom';\r\nimport { observeOn } from '../operators/observeOn';\r\nimport { subscribeOn } from '../operators/subscribeOn';\r\nimport { SchedulerLike } from '../types';\r\n\r\nexport function schedulePromise<T>(input: PromiseLike<T>, scheduler: SchedulerLike) {\r\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { SchedulerLike } from '../types';\r\n\r\nexport function scheduleArray<T>(input: ArrayLike<T>, scheduler: SchedulerLike) {\r\n  return new Observable<T>((subscriber) => {\r\n    // The current array index.\r\n    let i = 0;\r\n    // Start iterating over the array like on a schedule.\r\n    return scheduler.schedule(function () {\r\n      if (i === input.length) {\r\n        // If we have hit the end of the array like in the\r\n        // previous job, we can complete.\r\n        subscriber.complete();\r\n      } else {\r\n        // Otherwise let's next the value at the current index,\r\n        // then increment our index.\r\n        subscriber.next(input[i++]);\r\n        // If the last emission didn't cause us to close the subscriber\r\n        // (via take or some side effect), reschedule the job and we'll\r\n        // make another pass.\r\n        if (!subscriber.closed) {\r\n          this.schedule();\r\n        }\r\n      }\r\n    });\r\n  });\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { SchedulerLike } from '../types';\r\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\r\nimport { isFunction } from '../util/isFunction';\r\nimport { executeSchedule } from '../util/executeSchedule';\r\n\r\n/**\r\n * Used in {@link scheduled} to create an observable from an Iterable.\r\n * @param input The iterable to create an observable from\r\n * @param scheduler The scheduler to use\r\n */\r\nexport function scheduleIterable<T>(input: Iterable<T>, scheduler: SchedulerLike) {\r\n  return new Observable<T>((subscriber) => {\r\n    let iterator: Iterator<T, T>;\r\n\r\n    // Schedule the initial creation of the iterator from\r\n    // the iterable. This is so the code in the iterable is\r\n    // not called until the scheduled job fires.\r\n    executeSchedule(subscriber, scheduler, () => {\r\n      // Create the iterator.\r\n      iterator = (input as any)[Symbol_iterator]();\r\n\r\n      executeSchedule(\r\n        subscriber,\r\n        scheduler,\r\n        () => {\r\n          let value: T;\r\n          let done: boolean | undefined;\r\n          try {\r\n            // Pull the value out of the iterator\r\n            ({ value, done } = iterator.next());\r\n          } catch (err) {\r\n            // We got an error while pulling from the iterator\r\n            subscriber.error(err);\r\n            return;\r\n          }\r\n\r\n          if (done) {\r\n            // If it is \"done\" we just complete. This mimics the\r\n            // behavior of JavaScript's `for..of` consumption of\r\n            // iterables, which will not emit the value from an iterator\r\n            // result of `{ done: true: value: 'here' }`.\r\n            subscriber.complete();\r\n          } else {\r\n            // The iterable is not done, emit the value.\r\n            subscriber.next(value);\r\n          }\r\n        },\r\n        0,\r\n        true\r\n      );\r\n    });\r\n\r\n    // During finalization, if we see this iterator has a `return` method,\r\n    // then we know it is a Generator, and not just an Iterator. So we call\r\n    // the `return()` function. This will ensure that any `finally { }` blocks\r\n    // inside of the generator we can hit will be hit properly.\r\n    return () => isFunction(iterator?.return) && iterator.return();\r\n  });\r\n}\r\n", "import { SchedulerLike } from '../types';\r\nimport { Observable } from '../Observable';\r\nimport { executeSchedule } from '../util/executeSchedule';\r\n\r\nexport function scheduleAsyncIterable<T>(input: AsyncIterable<T>, scheduler: SchedulerLike) {\r\n  if (!input) {\r\n    throw new Error('Iterable cannot be null');\r\n  }\r\n  return new Observable<T>((subscriber) => {\r\n    executeSchedule(subscriber, scheduler, () => {\r\n      const iterator = input[Symbol.asyncIterator]();\r\n      executeSchedule(\r\n        subscriber,\r\n        scheduler,\r\n        () => {\r\n          iterator.next().then((result) => {\r\n            if (result.done) {\r\n              // This will remove the subscriptions from\r\n              // the parent subscription.\r\n              subscriber.complete();\r\n            } else {\r\n              subscriber.next(result.value);\r\n            }\r\n          });\r\n        },\r\n        0,\r\n        true\r\n      );\r\n    });\r\n  });\r\n}\r\n", "import { SchedulerLike, ReadableStreamLike } from '../types';\r\nimport { Observable } from '../Observable';\r\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\r\nimport { readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\r\n\r\nexport function scheduleReadableStreamLike<T>(input: ReadableStreamLike<T>, scheduler: SchedulerLike): Observable<T> {\r\n  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);\r\n}\r\n", "import { scheduleObservable } from './scheduleObservable';\r\nimport { schedulePromise } from './schedulePromise';\r\nimport { scheduleArray } from './scheduleArray';\r\nimport { scheduleIterable } from './scheduleIterable';\r\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\r\nimport { isInteropObservable } from '../util/isInteropObservable';\r\nimport { isPromise } from '../util/isPromise';\r\nimport { isArrayLike } from '../util/isArrayLike';\r\nimport { isIterable } from '../util/isIterable';\r\nimport { ObservableInput, SchedulerLike } from '../types';\r\nimport { Observable } from '../Observable';\r\nimport { isAsyncIterable } from '../util/isAsyncIterable';\r\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\r\nimport { isReadableStreamLike } from '../util/isReadableStreamLike';\r\nimport { scheduleReadableStreamLike } from './scheduleReadableStreamLike';\r\n\r\n/**\r\n * Converts from a common {@link ObservableInput} type to an observable where subscription and emissions\r\n * are scheduled on the provided scheduler.\r\n *\r\n * @see {@link from}\r\n * @see {@link of}\r\n *\r\n * @param input The observable, array, promise, iterable, etc you would like to schedule\r\n * @param scheduler The scheduler to use to schedule the subscription and emissions from\r\n * the returned observable.\r\n */\r\nexport function scheduled<T>(input: ObservableInput<T>, scheduler: SchedulerLike): Observable<T> {\r\n  if (input != null) {\r\n    if (isInteropObservable(input)) {\r\n      return scheduleObservable(input, scheduler);\r\n    }\r\n    if (isArrayLike(input)) {\r\n      return scheduleArray(input, scheduler);\r\n    }\r\n    if (isPromise(input)) {\r\n      return schedulePromise(input, scheduler);\r\n    }\r\n    if (isAsyncIterable(input)) {\r\n      return scheduleAsyncIterable(input, scheduler);\r\n    }\r\n    if (isIterable(input)) {\r\n      return scheduleIterable(input, scheduler);\r\n    }\r\n    if (isReadableStreamLike(input)) {\r\n      return scheduleReadableStreamLike(input, scheduler);\r\n    }\r\n  }\r\n  throw createInvalidObservableTypeError(input);\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { ObservableInput, SchedulerLike, ObservedValueOf } from '../types';\r\nimport { scheduled } from '../scheduled/scheduled';\r\nimport { innerFrom } from './innerFrom';\r\n\r\nexport function from<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\r\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\r\nexport function from<O extends ObservableInput<any>>(input: O, scheduler: SchedulerLike | undefined): Observable<ObservedValueOf<O>>;\r\n\r\n/**\r\n * Creates an Observable from an Array, an array-like object, a Promise, an iterable object, or an Observable-like object.\r\n *\r\n * <span class=\"informal\">Converts almost anything to an Observable.</span>\r\n *\r\n * ![](from.png)\r\n *\r\n * `from` converts various other objects and data types into Observables. It also converts a Promise, an array-like, or an\r\n * <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable\" target=\"_blank\">iterable</a>\r\n * object into an Observable that emits the items in that promise, array, or iterable. A String, in this context, is treated\r\n * as an array of characters. Observable-like objects (contains a function named with the ES2015 Symbol for Observable) can also be\r\n * converted through this operator.\r\n *\r\n * ## Examples\r\n *\r\n * Converts an array to an Observable\r\n *\r\n * ```ts\r\n * import { from } from 'rxjs';\r\n *\r\n * const array = [10, 20, 30];\r\n * const result = from(array);\r\n *\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Logs:\r\n * // 10\r\n * // 20\r\n * // 30\r\n * ```\r\n *\r\n * Convert an infinite iterable (from a generator) to an Observable\r\n *\r\n * ```ts\r\n * import { from, take } from 'rxjs';\r\n *\r\n * function* generateDoubles(seed) {\r\n *    let i = seed;\r\n *    while (true) {\r\n *      yield i;\r\n *      i = 2 * i; // double it\r\n *    }\r\n * }\r\n *\r\n * const iterator = generateDoubles(3);\r\n * const result = from(iterator).pipe(take(10));\r\n *\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Logs:\r\n * // 3\r\n * // 6\r\n * // 12\r\n * // 24\r\n * // 48\r\n * // 96\r\n * // 192\r\n * // 384\r\n * // 768\r\n * // 1536\r\n * ```\r\n *\r\n * With `asyncScheduler`\r\n *\r\n * ```ts\r\n * import { from, asyncScheduler } from 'rxjs';\r\n *\r\n * console.log('start');\r\n *\r\n * const array = [10, 20, 30];\r\n * const result = from(array, asyncScheduler);\r\n *\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * console.log('end');\r\n *\r\n * // Logs:\r\n * // 'start'\r\n * // 'end'\r\n * // 10\r\n * // 20\r\n * // 30\r\n * ```\r\n *\r\n * @see {@link fromEvent}\r\n * @see {@link fromEventPattern}\r\n *\r\n * @param input A subscription object, a Promise, an Observable-like,\r\n * an Array, an iterable, or an array-like object to be converted.\r\n * @param scheduler An optional {@link SchedulerLike} on which to schedule the emission of values.\r\n * @return An Observable converted from {@link ObservableInput}.\r\n */\r\nexport function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T> {\r\n  return scheduler ? scheduled(input, scheduler) : innerFrom(input);\r\n}\r\n", "import { SchedulerLike, ValueFromArray } from '../types';\r\nimport { Observable } from '../Observable';\r\nimport { popScheduler } from '../util/args';\r\nimport { from } from './from';\r\n\r\n// Devs are more likely to pass null or undefined than they are a scheduler\r\n// without accompanying values. To make things easier for (naughty) devs who\r\n// use the `strictNullChecks: false` TypeScript compiler option, these\r\n// overloads with explicit null and undefined values are included.\r\n\r\nexport function of(value: null): Observable<null>;\r\nexport function of(value: undefined): Observable<undefined>;\r\n\r\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\r\nexport function of(scheduler: SchedulerLike): Observable<never>;\r\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\r\nexport function of<A extends readonly unknown[]>(...valuesAndScheduler: [...A, SchedulerLike]): Observable<ValueFromArray<A>>;\r\n\r\nexport function of(): Observable<never>;\r\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\r\nexport function of<T>(): Observable<T>;\r\nexport function of<T>(value: T): Observable<T>;\r\nexport function of<A extends readonly unknown[]>(...values: A): Observable<ValueFromArray<A>>;\r\n\r\n/**\r\n * Converts the arguments to an observable sequence.\r\n *\r\n * <span class=\"informal\">Each argument becomes a `next` notification.</span>\r\n *\r\n * ![](of.png)\r\n *\r\n * Unlike {@link from}, it does not do any flattening and emits each argument in whole\r\n * as a separate `next` notification.\r\n *\r\n * ## Examples\r\n *\r\n * Emit the values `10, 20, 30`\r\n *\r\n * ```ts\r\n * import { of } from 'rxjs';\r\n *\r\n * of(10, 20, 30)\r\n *   .subscribe({\r\n *     next: value => console.log('next:', value),\r\n *     error: err => console.log('error:', err),\r\n *     complete: () => console.log('the end'),\r\n *   });\r\n *\r\n * // Outputs\r\n * // next: 10\r\n * // next: 20\r\n * // next: 30\r\n * // the end\r\n * ```\r\n *\r\n * Emit the array `[1, 2, 3]`\r\n *\r\n * ```ts\r\n * import { of } from 'rxjs';\r\n *\r\n * of([1, 2, 3])\r\n *   .subscribe({\r\n *     next: value => console.log('next:', value),\r\n *     error: err => console.log('error:', err),\r\n *     complete: () => console.log('the end'),\r\n *   });\r\n *\r\n * // Outputs\r\n * // next: [1, 2, 3]\r\n * // the end\r\n * ```\r\n *\r\n * @see {@link from}\r\n * @see {@link range}\r\n *\r\n * @param args A comma separated list of arguments you want to be emitted.\r\n * @return An Observable that synchronously emits the arguments described\r\n * above and then immediately completes.\r\n */\r\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T> {\r\n  const scheduler = popScheduler(args);\r\n  return from(args as T[], scheduler);\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { SchedulerLike } from '../types';\r\nimport { isFunction } from '../util/isFunction';\r\n\r\n/**\r\n * Creates an observable that will create an error instance and push it to the consumer as an error\r\n * immediately upon subscription.\r\n *\r\n * <span class=\"informal\">Just errors and does nothing else</span>\r\n *\r\n * ![](throw.png)\r\n *\r\n * This creation function is useful for creating an observable that will create an error and error every\r\n * time it is subscribed to. Generally, inside of most operators when you might want to return an errored\r\n * observable, this is unnecessary. In most cases, such as in the inner return of {@link concatMap},\r\n * {@link mergeMap}, {@link defer}, and many others, you can simply throw the error, and RxJS will pick\r\n * that up and notify the consumer of the error.\r\n *\r\n * ## Example\r\n *\r\n * Create a simple observable that will create a new error with a timestamp and log it\r\n * and the message every time you subscribe to it\r\n *\r\n * ```ts\r\n * import { throwError } from 'rxjs';\r\n *\r\n * let errorCount = 0;\r\n *\r\n * const errorWithTimestamp$ = throwError(() => {\r\n *   const error: any = new Error(`This is error number ${ ++errorCount }`);\r\n *   error.timestamp = Date.now();\r\n *   return error;\r\n * });\r\n *\r\n * errorWithTimestamp$.subscribe({\r\n *   error: err => console.log(err.timestamp, err.message)\r\n * });\r\n *\r\n * errorWithTimestamp$.subscribe({\r\n *   error: err => console.log(err.timestamp, err.message)\r\n * });\r\n *\r\n * // Logs the timestamp and a new error message for each subscription\r\n * ```\r\n *\r\n * ### Unnecessary usage\r\n *\r\n * Using `throwError` inside of an operator or creation function\r\n * with a callback, is usually not necessary\r\n *\r\n * ```ts\r\n * import { of, concatMap, timer, throwError } from 'rxjs';\r\n *\r\n * const delays$ = of(1000, 2000, Infinity, 3000);\r\n *\r\n * delays$.pipe(\r\n *   concatMap(ms => {\r\n *     if (ms < 10000) {\r\n *       return timer(ms);\r\n *     } else {\r\n *       // This is probably overkill.\r\n *       return throwError(() => new Error(`Invalid time ${ ms }`));\r\n *     }\r\n *   })\r\n * )\r\n * .subscribe({\r\n *   next: console.log,\r\n *   error: console.error\r\n * });\r\n * ```\r\n *\r\n * You can just throw the error instead\r\n *\r\n * ```ts\r\n * import { of, concatMap, timer } from 'rxjs';\r\n *\r\n * const delays$ = of(1000, 2000, Infinity, 3000);\r\n *\r\n * delays$.pipe(\r\n *   concatMap(ms => {\r\n *     if (ms < 10000) {\r\n *       return timer(ms);\r\n *     } else {\r\n *       // Cleaner and easier to read for most folks.\r\n *       throw new Error(`Invalid time ${ ms }`);\r\n *     }\r\n *   })\r\n * )\r\n * .subscribe({\r\n *   next: console.log,\r\n *   error: console.error\r\n * });\r\n * ```\r\n *\r\n * @param errorFactory A factory function that will create the error instance that is pushed.\r\n */\r\nexport function throwError(errorFactory: () => any): Observable<never>;\r\n\r\n/**\r\n * Returns an observable that will error with the specified error immediately upon subscription.\r\n *\r\n * @param error The error instance to emit\r\n * @deprecated Support for passing an error value will be removed in v8. Instead, pass a factory function to `throwError(() => new Error('test'))`. This is\r\n * because it will create the error at the moment it should be created and capture a more appropriate stack trace. If\r\n * for some reason you need to create the error ahead of time, you can still do that: `const err = new Error('test'); throwError(() => err);`.\r\n */\r\nexport function throwError(error: any): Observable<never>;\r\n\r\n/**\r\n * Notifies the consumer of an error using a given scheduler by scheduling it at delay `0` upon subscription.\r\n *\r\n * @param errorOrErrorFactory An error instance or error factory\r\n * @param scheduler A scheduler to use to schedule the error notification\r\n * @deprecated The `scheduler` parameter will be removed in v8.\r\n * Use `throwError` in combination with {@link observeOn}: `throwError(() => new Error('test')).pipe(observeOn(scheduler));`.\r\n * Details: https://rxjs.dev/deprecations/scheduler-argument\r\n */\r\nexport function throwError(errorOrErrorFactory: any, scheduler: SchedulerLike): Observable<never>;\r\n\r\nexport function throwError(errorOrErrorFactory: any, scheduler?: SchedulerLike): Observable<never> {\r\n  const errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : () => errorOrErrorFactory;\r\n  const init = (subscriber: Subscriber<never>) => subscriber.error(errorFactory());\r\n  return new Observable(scheduler ? (subscriber) => scheduler.schedule(init as any, 0, subscriber) : init);\r\n}\r\n", "import { PartialObserver, ObservableNotification, CompleteNotification, NextNotification, ErrorNotification } from './types';\r\nimport { Observable } from './Observable';\r\nimport { EMPTY } from './observable/empty';\r\nimport { of } from './observable/of';\r\nimport { throwError } from './observable/throwError';\r\nimport { isFunction } from './util/isFunction';\r\n\r\n// TODO: When this enum is removed, replace it with a type alias. See #4556.\r\n/**\r\n * @deprecated Use a string literal instead. `NotificationKind` will be replaced with a type alias in v8.\r\n * It will not be replaced with a const enum as those are not compatible with isolated modules.\r\n */\r\nexport enum NotificationKind {\r\n  NEXT = 'N',\r\n  ERROR = 'E',\r\n  COMPLETE = 'C',\r\n}\r\n\r\n/**\r\n * Represents a push-based event or value that an {@link Observable} can emit.\r\n * This class is particularly useful for operators that manage notifications,\r\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\r\n * others. Besides wrapping the actual delivered value, it also annotates it\r\n * with metadata of, for instance, what type of push message it is (`next`,\r\n * `error`, or `complete`).\r\n *\r\n * @see {@link materialize}\r\n * @see {@link dematerialize}\r\n * @see {@link observeOn}\r\n * @deprecated It is NOT recommended to create instances of `Notification` directly.\r\n * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\r\n * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\r\n * Will be removed in v8.\r\n */\r\nexport class Notification<T> {\r\n  /**\r\n   * A value signifying that the notification will \"next\" if observed. In truth,\r\n   * This is really synonymous with just checking `kind === \"N\"`.\r\n   * @deprecated Will be removed in v8. Instead, just check to see if the value of `kind` is `\"N\"`.\r\n   */\r\n  readonly hasValue: boolean;\r\n\r\n  /**\r\n   * Creates a \"Next\" notification object.\r\n   * @param kind Always `'N'`\r\n   * @param value The value to notify with if observed.\r\n   * @deprecated Internal implementation detail. Use {@link Notification#createNext createNext} instead.\r\n   */\r\n  constructor(kind: 'N', value?: T);\r\n  /**\r\n   * Creates an \"Error\" notification object.\r\n   * @param kind Always `'E'`\r\n   * @param value Always `undefined`\r\n   * @param error The error to notify with if observed.\r\n   * @deprecated Internal implementation detail. Use {@link Notification#createError createError} instead.\r\n   */\r\n  constructor(kind: 'E', value: undefined, error: any);\r\n  /**\r\n   * Creates a \"completion\" notification object.\r\n   * @param kind Always `'C'`\r\n   * @deprecated Internal implementation detail. Use {@link Notification#createComplete createComplete} instead.\r\n   */\r\n  constructor(kind: 'C');\r\n  constructor(public readonly kind: 'N' | 'E' | 'C', public readonly value?: T, public readonly error?: any) {\r\n    this.hasValue = kind === 'N';\r\n  }\r\n\r\n  /**\r\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\r\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\r\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\r\n   * @param observer The observer to notify.\r\n   */\r\n  observe(observer: PartialObserver<T>): void {\r\n    return observeNotification(this as ObservableNotification<T>, observer);\r\n  }\r\n\r\n  /**\r\n   * Executes a notification on the appropriate handler from a list provided.\r\n   * If a handler is missing for the kind of notification, nothing is called\r\n   * and no error is thrown, it will be a noop.\r\n   * @param next A next handler\r\n   * @param error An error handler\r\n   * @param complete A complete handler\r\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\r\n   */\r\n  do(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\r\n  /**\r\n   * Executes a notification on the appropriate handler from a list provided.\r\n   * If a handler is missing for the kind of notification, nothing is called\r\n   * and no error is thrown, it will be a noop.\r\n   * @param next A next handler\r\n   * @param error An error handler\r\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\r\n   */\r\n  do(next: (value: T) => void, error: (err: any) => void): void;\r\n  /**\r\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\r\n   * this will not error, and it will be a noop.\r\n   * @param next The next handler\r\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\r\n   */\r\n  do(next: (value: T) => void): void;\r\n  do(nextHandler: (value: T) => void, errorHandler?: (err: any) => void, completeHandler?: () => void): void {\r\n    const { kind, value, error } = this;\r\n    return kind === 'N' ? nextHandler?.(value!) : kind === 'E' ? errorHandler?.(error) : completeHandler?.();\r\n  }\r\n\r\n  /**\r\n   * Executes a notification on the appropriate handler from a list provided.\r\n   * If a handler is missing for the kind of notification, nothing is called\r\n   * and no error is thrown, it will be a noop.\r\n   * @param next A next handler\r\n   * @param error An error handler\r\n   * @param complete A complete handler\r\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\r\n   */\r\n  accept(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\r\n  /**\r\n   * Executes a notification on the appropriate handler from a list provided.\r\n   * If a handler is missing for the kind of notification, nothing is called\r\n   * and no error is thrown, it will be a noop.\r\n   * @param next A next handler\r\n   * @param error An error handler\r\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\r\n   */\r\n  accept(next: (value: T) => void, error: (err: any) => void): void;\r\n  /**\r\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\r\n   * this will not error, and it will be a noop.\r\n   * @param next The next handler\r\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\r\n   */\r\n  accept(next: (value: T) => void): void;\r\n\r\n  /**\r\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\r\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\r\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\r\n   * @param observer The observer to notify.\r\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\r\n   */\r\n  accept(observer: PartialObserver<T>): void;\r\n  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) {\r\n    return isFunction((nextOrObserver as any)?.next)\r\n      ? this.observe(nextOrObserver as PartialObserver<T>)\r\n      : this.do(nextOrObserver as (value: T) => void, error as any, complete as any);\r\n  }\r\n\r\n  /**\r\n   * Returns a simple Observable that just delivers the notification represented\r\n   * by this Notification instance.\r\n   *\r\n   * @deprecated Will be removed in v8. To convert a `Notification` to an {@link Observable},\r\n   * use {@link of} and {@link dematerialize}: `of(notification).pipe(dematerialize())`.\r\n   */\r\n  toObservable(): Observable<T> {\r\n    const { kind, value, error } = this;\r\n    // Select the observable to return by `kind`\r\n    const result =\r\n      kind === 'N'\r\n        ? // Next kind. Return an observable of that value.\r\n          of(value!)\r\n        : //\r\n        kind === 'E'\r\n        ? // Error kind. Return an observable that emits the error.\r\n          throwError(() => error)\r\n        : //\r\n        kind === 'C'\r\n        ? // Completion kind. Kind is \"C\", return an observable that just completes.\r\n          EMPTY\r\n        : // Unknown kind, return falsy, so we error below.\r\n          0;\r\n    if (!result) {\r\n      // TODO: consider removing this check. The only way to cause this would be to\r\n      // use the Notification constructor directly in a way that is not type-safe.\r\n      // and direct use of the Notification constructor is deprecated.\r\n      throw new TypeError(`Unexpected notification kind ${kind}`);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private static completeNotification = new Notification('C') as Notification<never> & CompleteNotification;\r\n  /**\r\n   * A shortcut to create a Notification instance of the type `next` from a\r\n   * given value.\r\n   * @param value The `next` value.\r\n   * @return The \"next\" Notification representing the argument.\r\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\r\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\r\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\r\n   * Will be removed in v8.\r\n   */\r\n  static createNext<T>(value: T) {\r\n    return new Notification('N', value) as Notification<T> & NextNotification<T>;\r\n  }\r\n\r\n  /**\r\n   * A shortcut to create a Notification instance of the type `error` from a\r\n   * given error.\r\n   * @param err The `error` error.\r\n   * @return The \"error\" Notification representing the argument.\r\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\r\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\r\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\r\n   * Will be removed in v8.\r\n   */\r\n  static createError(err?: any) {\r\n    return new Notification('E', undefined, err) as Notification<never> & ErrorNotification;\r\n  }\r\n\r\n  /**\r\n   * A shortcut to create a Notification instance of the type `complete`.\r\n   * @return The valueless \"complete\" Notification.\r\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\r\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\r\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\r\n   * Will be removed in v8.\r\n   */\r\n  static createComplete(): Notification<never> & CompleteNotification {\r\n    return Notification.completeNotification;\r\n  }\r\n}\r\n\r\n/**\r\n * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\r\n * If the handler is missing it will do nothing. Even if the notification is an error, if\r\n * there is no error handler on the observer, an error will not be thrown, it will noop.\r\n * @param notification The notification object to observe.\r\n * @param observer The observer to notify.\r\n */\r\nexport function observeNotification<T>(notification: ObservableNotification<T>, observer: PartialObserver<T>) {\r\n  const { kind, value, error } = notification as any;\r\n  if (typeof kind !== 'string') {\r\n    throw new TypeError('Invalid notification, missing \"kind\"');\r\n  }\r\n  kind === 'N' ? observer.next?.(value!) : kind === 'E' ? observer.error?.(error) : observer.complete?.();\r\n}\r\n", "/** prettier */\r\nimport { Observable } from '../Observable';\r\nimport { isFunction } from './isFunction';\r\n\r\n/**\r\n * Tests to see if the object is an RxJS {@link Observable}\r\n * @param obj the object to test\r\n */\r\nexport function isObservable(obj: any): obj is Observable<unknown> {\r\n  // The !! is to ensure that this publicly exposed function returns\r\n  // `false` if something like `null` or `0` is passed.\r\n  return !!obj && (obj instanceof Observable || (isFunction(obj.lift) && isFunction(obj.subscribe)));\r\n}\r\n", "import { createErrorClass } from './createErrorClass';\r\n\r\nexport interface EmptyError extends Error {}\r\n\r\nexport interface EmptyErrorCtor {\r\n  /**\r\n   * @deprecated Internal implementation detail. Do not construct error instances.\r\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\r\n   */\r\n  new (): EmptyError;\r\n}\r\n\r\n/**\r\n * An error thrown when an Observable or a sequence was queried but has no\r\n * elements.\r\n *\r\n * @see {@link first}\r\n * @see {@link last}\r\n * @see {@link single}\r\n * @see {@link firstValueFrom}\r\n * @see {@link lastValueFrom}\r\n */\r\nexport const EmptyError: EmptyErrorCtor = createErrorClass(\r\n  (_super) =>\r\n    function EmptyErrorImpl(this: any) {\r\n      _super(this);\r\n      this.name = 'EmptyError';\r\n      this.message = 'no elements in sequence';\r\n    }\r\n);\r\n", "import { Observable } from './Observable';\r\nimport { EmptyError } from './util/EmptyError';\r\n\r\nexport interface LastValueFromConfig<T> {\r\n  defaultValue: T;\r\n}\r\n\r\nexport function lastValueFrom<T, D>(source: Observable<T>, config: LastValueFromConfig<D>): Promise<T | D>;\r\nexport function lastValueFrom<T>(source: Observable<T>): Promise<T>;\r\n\r\n/**\r\n * Converts an observable to a promise by subscribing to the observable,\r\n * waiting for it to complete, and resolving the returned promise with the\r\n * last value from the observed stream.\r\n *\r\n * If the observable stream completes before any values were emitted, the\r\n * returned promise will reject with {@link EmptyError} or will resolve\r\n * with the default value if a default was specified.\r\n *\r\n * If the observable stream emits an error, the returned promise will reject\r\n * with that error.\r\n *\r\n * **WARNING**: Only use this with observables you *know* will complete. If the source\r\n * observable does not complete, you will end up with a promise that is hung up, and\r\n * potentially all of the state of an async function hanging out in memory. To avoid\r\n * this situation, look into adding something like {@link timeout}, {@link take},\r\n * {@link takeWhile}, or {@link takeUntil} amongst others.\r\n *\r\n * ## Example\r\n *\r\n * Wait for the last value from a stream and emit it from a promise in\r\n * an async function\r\n *\r\n * ```ts\r\n * import { interval, take, lastValueFrom } from 'rxjs';\r\n *\r\n * async function execute() {\r\n *   const source$ = interval(2000).pipe(take(10));\r\n *   const finalNumber = await lastValueFrom(source$);\r\n *   console.log(`The final number is ${ finalNumber }`);\r\n * }\r\n *\r\n * execute();\r\n *\r\n * // Expected output:\r\n * // 'The final number is 9'\r\n * ```\r\n *\r\n * @see {@link firstValueFrom}\r\n *\r\n * @param source the observable to convert to a promise\r\n * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value\r\n */\r\nexport function lastValueFrom<T, D>(source: Observable<T>, config?: LastValueFromConfig<D>): Promise<T | D> {\r\n  const hasConfig = typeof config === 'object';\r\n  return new Promise<T | D>((resolve, reject) => {\r\n    let _hasValue = false;\r\n    let _value: T;\r\n    source.subscribe({\r\n      next: (value) => {\r\n        _value = value;\r\n        _hasValue = true;\r\n      },\r\n      error: reject,\r\n      complete: () => {\r\n        if (_hasValue) {\r\n          resolve(_value);\r\n        } else if (hasConfig) {\r\n          resolve(config!.defaultValue);\r\n        } else {\r\n          reject(new EmptyError());\r\n        }\r\n      },\r\n    });\r\n  });\r\n}\r\n", "import { Observable } from './Observable';\r\nimport { EmptyError } from './util/EmptyError';\r\nimport { SafeSubscriber } from './Subscriber';\r\n\r\nexport interface FirstValueFromConfig<T> {\r\n  defaultValue: T;\r\n}\r\n\r\nexport function firstValueFrom<T, D>(source: Observable<T>, config: FirstValueFromConfig<D>): Promise<T | D>;\r\nexport function firstValueFrom<T>(source: Observable<T>): Promise<T>;\r\n\r\n/**\r\n * Converts an observable to a promise by subscribing to the observable,\r\n * and returning a promise that will resolve as soon as the first value\r\n * arrives from the observable. The subscription will then be closed.\r\n *\r\n * If the observable stream completes before any values were emitted, the\r\n * returned promise will reject with {@link EmptyError} or will resolve\r\n * with the default value if a default was specified.\r\n *\r\n * If the observable stream emits an error, the returned promise will reject\r\n * with that error.\r\n *\r\n * **WARNING**: Only use this with observables you *know* will emit at least one value,\r\n * *OR* complete. If the source observable does not emit one value or complete, you will\r\n * end up with a promise that is hung up, and potentially all of the state of an\r\n * async function hanging out in memory. To avoid this situation, look into adding\r\n * something like {@link timeout}, {@link take}, {@link takeWhile}, or {@link takeUntil}\r\n * amongst others.\r\n *\r\n * ## Example\r\n *\r\n * Wait for the first value from a stream and emit it from a promise in\r\n * an async function\r\n *\r\n * ```ts\r\n * import { interval, firstValueFrom } from 'rxjs';\r\n *\r\n * async function execute() {\r\n *   const source$ = interval(2000);\r\n *   const firstNumber = await firstValueFrom(source$);\r\n *   console.log(`The first number is ${ firstNumber }`);\r\n * }\r\n *\r\n * execute();\r\n *\r\n * // Expected output:\r\n * // 'The first number is 0'\r\n * ```\r\n *\r\n * @see {@link lastValueFrom}\r\n *\r\n * @param source the observable to convert to a promise\r\n * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value\r\n */\r\nexport function firstValueFrom<T, D>(source: Observable<T>, config?: FirstValueFromConfig<D>): Promise<T | D> {\r\n  const hasConfig = typeof config === 'object';\r\n  return new Promise<T | D>((resolve, reject) => {\r\n    const subscriber = new SafeSubscriber<T>({\r\n      next: (value) => {\r\n        resolve(value);\r\n        subscriber.unsubscribe();\r\n      },\r\n      error: reject,\r\n      complete: () => {\r\n        if (hasConfig) {\r\n          resolve(config!.defaultValue);\r\n        } else {\r\n          reject(new EmptyError());\r\n        }\r\n      },\r\n    });\r\n    source.subscribe(subscriber);\r\n  });\r\n}\r\n", "import { createErrorClass } from './createErrorClass';\r\n\r\nexport interface ArgumentOutOfRangeError extends Error {}\r\n\r\nexport interface ArgumentOutOfRangeErrorCtor {\r\n  /**\r\n   * @deprecated Internal implementation detail. Do not construct error instances.\r\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\r\n   */\r\n  new (): ArgumentOutOfRangeError;\r\n}\r\n\r\n/**\r\n * An error thrown when an element was queried at a certain index of an\r\n * Observable, but no such index or position exists in that sequence.\r\n *\r\n * @see {@link elementAt}\r\n * @see {@link take}\r\n * @see {@link takeLast}\r\n */\r\nexport const ArgumentOutOfRangeError: ArgumentOutOfRangeErrorCtor = createErrorClass(\r\n  (_super) =>\r\n    function ArgumentOutOfRangeErrorImpl(this: any) {\r\n      _super(this);\r\n      this.name = 'ArgumentOutOfRangeError';\r\n      this.message = 'argument out of range';\r\n    }\r\n);\r\n", "import { createErrorClass } from './createErrorClass';\r\n\r\nexport interface NotFoundError extends Error {}\r\n\r\nexport interface NotFoundErrorCtor {\r\n  /**\r\n   * @deprecated Internal implementation detail. Do not construct error instances.\r\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\r\n   */\r\n  new (message: string): NotFoundError;\r\n}\r\n\r\n/**\r\n * An error thrown when a value or values are missing from an\r\n * observable sequence.\r\n *\r\n * @see {@link operators/single}\r\n */\r\nexport const NotFoundError: NotFoundErrorCtor = createErrorClass(\r\n  (_super) =>\r\n    function NotFoundErrorImpl(this: any, message: string) {\r\n      _super(this);\r\n      this.name = 'NotFoundError';\r\n      this.message = message;\r\n    }\r\n);\r\n", "import { createErrorClass } from './createErrorClass';\r\n\r\nexport interface SequenceError extends Error {}\r\n\r\nexport interface SequenceErrorCtor {\r\n  /**\r\n   * @deprecated Internal implementation detail. Do not construct error instances.\r\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\r\n   */\r\n  new (message: string): SequenceError;\r\n}\r\n\r\n/**\r\n * An error thrown when something is wrong with the sequence of\r\n * values arriving on the observable.\r\n *\r\n * @see {@link operators/single}\r\n */\r\nexport const SequenceError: SequenceErrorCtor = createErrorClass(\r\n  (_super) =>\r\n    function SequenceErrorImpl(this: any, message: string) {\r\n      _super(this);\r\n      this.name = 'SequenceError';\r\n      this.message = message;\r\n    }\r\n);\r\n", "/**\r\n * Checks to see if a value is not only a `Date` object,\r\n * but a *valid* `Date` object that can be converted to a\r\n * number. For example, `new Date('blah')` is indeed an\r\n * `instanceof Date`, however it cannot be converted to a\r\n * number.\r\n */\r\nexport function isValidDate(value: any): value is Date {\r\n  return value instanceof Date && !isNaN(value as any);\r\n}\r\n", "import { asyncScheduler } from '../scheduler/async';\r\nimport { MonoTypeOperatorFunction, SchedulerLike, OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\r\nimport { isValidDate } from '../util/isDate';\r\nimport { Subscription } from '../Subscription';\r\nimport { operate } from '../util/lift';\r\nimport { Observable } from '../Observable';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { createErrorClass } from '../util/createErrorClass';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { executeSchedule } from '../util/executeSchedule';\r\n\r\nexport interface TimeoutConfig<T, O extends ObservableInput<unknown> = ObservableInput<T>, M = unknown> {\r\n  /**\r\n   * The time allowed between values from the source before timeout is triggered.\r\n   */\r\n  each?: number;\r\n\r\n  /**\r\n   * The relative time as a `number` in milliseconds, or a specific time as a `Date` object,\r\n   * by which the first value must arrive from the source before timeout is triggered.\r\n   */\r\n  first?: number | Date;\r\n\r\n  /**\r\n   * The scheduler to use with time-related operations within this operator. Defaults to {@link asyncScheduler}\r\n   */\r\n  scheduler?: SchedulerLike;\r\n\r\n  /**\r\n   * A factory used to create observable to switch to when timeout occurs. Provides\r\n   * a {@link TimeoutInfo} about the source observable's emissions and what delay or\r\n   * exact time triggered the timeout.\r\n   */\r\n  with?: (info: TimeoutInfo<T, M>) => O;\r\n\r\n  /**\r\n   * Optional additional metadata you can provide to code that handles\r\n   * the timeout, will be provided through the {@link TimeoutError}.\r\n   * This can be used to help identify the source of a timeout or pass along\r\n   * other information related to the timeout.\r\n   */\r\n  meta?: M;\r\n}\r\n\r\nexport interface TimeoutInfo<T, M = unknown> {\r\n  /** Optional metadata that was provided to the timeout configuration. */\r\n  readonly meta: M;\r\n  /** The number of messages seen before the timeout */\r\n  readonly seen: number;\r\n  /** The last message seen */\r\n  readonly lastValue: T | null;\r\n}\r\n\r\n/**\r\n * An error emitted when a timeout occurs.\r\n */\r\nexport interface TimeoutError<T = unknown, M = unknown> extends Error {\r\n  /**\r\n   * The information provided to the error by the timeout\r\n   * operation that created the error. Will be `null` if\r\n   * used directly in non-RxJS code with an empty constructor.\r\n   * (Note that using this constructor directly is not recommended,\r\n   * you should create your own errors)\r\n   */\r\n  info: TimeoutInfo<T, M> | null;\r\n}\r\n\r\nexport interface TimeoutErrorCtor {\r\n  /**\r\n   * @deprecated Internal implementation detail. Do not construct error instances.\r\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\r\n   */\r\n  new <T = unknown, M = unknown>(info?: TimeoutInfo<T, M>): TimeoutError<T, M>;\r\n}\r\n\r\n/**\r\n * An error thrown by the {@link timeout} operator.\r\n *\r\n * Provided so users can use as a type and do quality comparisons.\r\n * We recommend you do not subclass this or create instances of this class directly.\r\n * If you have need of a error representing a timeout, you should\r\n * create your own error class and use that.\r\n *\r\n * @see {@link timeout}\r\n */\r\nexport const TimeoutError: TimeoutErrorCtor = createErrorClass(\r\n  (_super) =>\r\n    function TimeoutErrorImpl(this: any, info: TimeoutInfo<any> | null = null) {\r\n      _super(this);\r\n      this.message = 'Timeout has occurred';\r\n      this.name = 'TimeoutError';\r\n      this.info = info;\r\n    }\r\n);\r\n\r\n/**\r\n * If `with` is provided, this will return an observable that will switch to a different observable if the source\r\n * does not push values within the specified time parameters.\r\n *\r\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\r\n *\r\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\r\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\r\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\r\n * the settings in `first` and `each`.\r\n *\r\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\r\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\r\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\r\n * against the time period provided by `each`, if it was provided.\r\n *\r\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\r\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\r\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\r\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\r\n *\r\n * ## Examples\r\n *\r\n * Emit a custom error if there is too much time between values\r\n *\r\n * ```ts\r\n * import { interval, timeout, throwError } from 'rxjs';\r\n *\r\n * class CustomTimeoutError extends Error {\r\n *   constructor() {\r\n *     super('It was too slow');\r\n *     this.name = 'CustomTimeoutError';\r\n *   }\r\n * }\r\n *\r\n * const slow$ = interval(900);\r\n *\r\n * slow$.pipe(\r\n *   timeout({\r\n *     each: 1000,\r\n *     with: () => throwError(() => new CustomTimeoutError())\r\n *   })\r\n * )\r\n * .subscribe({\r\n *   error: console.error\r\n * });\r\n * ```\r\n *\r\n * Switch to a faster observable if your source is slow.\r\n *\r\n * ```ts\r\n * import { interval, timeout } from 'rxjs';\r\n *\r\n * const slow$ = interval(900);\r\n * const fast$ = interval(500);\r\n *\r\n * slow$.pipe(\r\n *   timeout({\r\n *     each: 1000,\r\n *     with: () => fast$,\r\n *   })\r\n * )\r\n * .subscribe(console.log);\r\n * ```\r\n * @param config The configuration for the timeout.\r\n */\r\nexport function timeout<T, O extends ObservableInput<unknown>, M = unknown>(\r\n  config: TimeoutConfig<T, O, M> & { with: (info: TimeoutInfo<T, M>) => O }\r\n): OperatorFunction<T, T | ObservedValueOf<O>>;\r\n\r\n/**\r\n * Returns an observable that will error or switch to a different observable if the source does not push values\r\n * within the specified time parameters.\r\n *\r\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\r\n *\r\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\r\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\r\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\r\n * the settings in `first` and `each`.\r\n *\r\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\r\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\r\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\r\n * against the time period provided by `each`, if it was provided.\r\n *\r\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\r\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\r\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\r\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\r\n *\r\n * ### Handling TimeoutErrors\r\n *\r\n * If no `with` property was provided, subscriptions to the resulting observable may emit an error of {@link TimeoutError}.\r\n * The timeout error provides useful information you can examine when you're handling the error. The most common way to handle\r\n * the error would be with {@link catchError}, although you could use {@link tap} or just the error handler in your `subscribe` call\r\n * directly, if your error handling is only a side effect (such as notifying the user, or logging).\r\n *\r\n * In this case, you would check the error for `instanceof TimeoutError` to validate that the error was indeed from `timeout`, and\r\n * not from some other source. If it's not from `timeout`, you should probably rethrow it if you're in a `catchError`.\r\n *\r\n * ## Examples\r\n *\r\n * Emit a {@link TimeoutError} if the first value, and _only_ the first value, does not arrive within 5 seconds\r\n *\r\n * ```ts\r\n * import { interval, timeout } from 'rxjs';\r\n *\r\n * // A random interval that lasts between 0 and 10 seconds per tick\r\n * const source$ = interval(Math.round(Math.random() * 10_000));\r\n *\r\n * source$.pipe(\r\n *   timeout({ first: 5_000 })\r\n * )\r\n * .subscribe({\r\n *   next: console.log,\r\n *   error: console.error\r\n * });\r\n * ```\r\n *\r\n * Emit a {@link TimeoutError} if the source waits longer than 5 seconds between any two values or the first value\r\n * and subscription.\r\n *\r\n * ```ts\r\n * import { timer, timeout, expand } from 'rxjs';\r\n *\r\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\r\n *\r\n * // An observable that waits a random amount of time between each delivered value\r\n * const source$ = timer(getRandomTime())\r\n *   .pipe(expand(() => timer(getRandomTime())));\r\n *\r\n * source$\r\n *   .pipe(timeout({ each: 5_000 }))\r\n *   .subscribe({\r\n *     next: console.log,\r\n *     error: console.error\r\n *   });\r\n * ```\r\n *\r\n * Emit a {@link TimeoutError} if the source does not emit before 7 seconds, _or_ if the source waits longer than\r\n * 5 seconds between any two values after the first.\r\n *\r\n * ```ts\r\n * import { timer, timeout, expand } from 'rxjs';\r\n *\r\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\r\n *\r\n * // An observable that waits a random amount of time between each delivered value\r\n * const source$ = timer(getRandomTime())\r\n *   .pipe(expand(() => timer(getRandomTime())));\r\n *\r\n * source$\r\n *   .pipe(timeout({ first: 7_000, each: 5_000 }))\r\n *   .subscribe({\r\n *     next: console.log,\r\n *     error: console.error\r\n *   });\r\n * ```\r\n */\r\nexport function timeout<T, M = unknown>(config: Omit<TimeoutConfig<T, any, M>, 'with'>): OperatorFunction<T, T>;\r\n\r\n/**\r\n * Returns an observable that will error if the source does not push its first value before the specified time passed as a `Date`.\r\n * This is functionally the same as `timeout({ first: someDate })`.\r\n *\r\n * <span class=\"informal\">Errors if the first value doesn't show up before the given date and time</span>\r\n *\r\n * ![](timeout.png)\r\n *\r\n * @param first The date to at which the resulting observable will timeout if the source observable\r\n * does not emit at least one value.\r\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\r\n */\r\nexport function timeout<T>(first: Date, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * Returns an observable that will error if the source does not push a value within the specified time in milliseconds.\r\n * This is functionally the same as `timeout({ each: milliseconds })`.\r\n *\r\n * <span class=\"informal\">Errors if it waits too long between any value</span>\r\n *\r\n * ![](timeout.png)\r\n *\r\n * @param each The time allowed between each pushed value from the source before the resulting observable\r\n * will timeout.\r\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\r\n */\r\nexport function timeout<T>(each: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n *\r\n * Errors if Observable does not emit a value in given time span.\r\n *\r\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\r\n *\r\n * ![](timeout.png)\r\n *\r\n * @see {@link timeoutWith}\r\n *\r\n * @return A function that returns an Observable that mirrors behaviour of the\r\n * source Observable, unless timeout happens when it throws an error.\r\n */\r\nexport function timeout<T, O extends ObservableInput<any>, M>(\r\n  config: number | Date | TimeoutConfig<T, O, M>,\r\n  schedulerArg?: SchedulerLike\r\n): OperatorFunction<T, T | ObservedValueOf<O>> {\r\n  // Intentionally terse code.\r\n  // If the first argument is a valid `Date`, then we use it as the `first` config.\r\n  // Otherwise, if the first argument is a `number`, then we use it as the `each` config.\r\n  // Otherwise, it can be assumed the first argument is the configuration object itself, and\r\n  // we destructure that into what we're going to use, setting important defaults as we do.\r\n  // NOTE: The default for `scheduler` will be the `scheduler` argument if it exists, or\r\n  // it will default to the `asyncScheduler`.\r\n  const {\r\n    first,\r\n    each,\r\n    with: _with = timeoutErrorFactory,\r\n    scheduler = schedulerArg ?? asyncScheduler,\r\n    meta = null!,\r\n  } = (isValidDate(config) ? { first: config } : typeof config === 'number' ? { each: config } : config) as TimeoutConfig<T, O, M>;\r\n\r\n  if (first == null && each == null) {\r\n    // Ensure timeout was provided at runtime.\r\n    throw new TypeError('No timeout provided.');\r\n  }\r\n\r\n  return operate((source, subscriber) => {\r\n    // This subscription encapsulates our subscription to the\r\n    // source for this operator. We're capturing it separately,\r\n    // because if there is a `with` observable to fail over to,\r\n    // we want to unsubscribe from our original subscription, and\r\n    // hand of the subscription to that one.\r\n    let originalSourceSubscription: Subscription;\r\n    // The subscription for our timeout timer. This changes\r\n    // every time we get a new value.\r\n    let timerSubscription: Subscription;\r\n    // A bit of state we pass to our with and error factories to\r\n    // tell what the last value we saw was.\r\n    let lastValue: T | null = null;\r\n    // A bit of state we pass to the with and error factories to\r\n    // tell how many values we have seen so far.\r\n    let seen = 0;\r\n    const startTimer = (delay: number) => {\r\n      timerSubscription = executeSchedule(\r\n        subscriber,\r\n        scheduler,\r\n        () => {\r\n          try {\r\n            originalSourceSubscription.unsubscribe();\r\n            innerFrom(\r\n              _with!({\r\n                meta,\r\n                lastValue,\r\n                seen,\r\n              })\r\n            ).subscribe(subscriber);\r\n          } catch (err) {\r\n            subscriber.error(err);\r\n          }\r\n        },\r\n        delay\r\n      );\r\n    };\r\n\r\n    originalSourceSubscription = source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value: T) => {\r\n          // clear the timer so we can emit and start another one.\r\n          timerSubscription?.unsubscribe();\r\n          seen++;\r\n          // Emit\r\n          subscriber.next((lastValue = value));\r\n          // null | undefined are both < 0. Thanks, JavaScript.\r\n          each! > 0 && startTimer(each!);\r\n        },\r\n        undefined,\r\n        undefined,\r\n        () => {\r\n          if (!timerSubscription?.closed) {\r\n            timerSubscription?.unsubscribe();\r\n          }\r\n          // Be sure not to hold the last value in memory after unsubscription\r\n          // it could be quite large.\r\n          lastValue = null;\r\n        }\r\n      )\r\n    );\r\n\r\n    // Intentionally terse code.\r\n    // If we've `seen` a value, that means the \"first\" clause was met already, if it existed.\r\n    //   it also means that a timer was already started for \"each\" (in the next handler above).\r\n    // If `first` was provided, and it's a number, then use it.\r\n    // If `first` was provided and it's not a number, it's a Date, and we get the difference between it and \"now\".\r\n    // If `first` was not provided at all, then our first timer will be the value from `each`.\r\n    !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler!.now()) : each!);\r\n  });\r\n}\r\n\r\n/**\r\n * The default function to use to emit an error when timeout occurs and a `with` function\r\n * is not specified.\r\n * @param info The information about the timeout to pass along to the error\r\n */\r\nfunction timeoutErrorFactory(info: TimeoutInfo<any>): Observable<never> {\r\n  throw new TimeoutError(info);\r\n}\r\n", "import { OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\nexport function map<T, R>(project: (value: T, index: number) => R): OperatorFunction<T, R>;\r\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\r\nexport function map<T, R, A>(project: (this: A, value: T, index: number) => R, thisArg: A): OperatorFunction<T, R>;\r\n\r\n/**\r\n * Applies a given `project` function to each value emitted by the source\r\n * Observable, and emits the resulting values as an Observable.\r\n *\r\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\r\n * it passes each source value through a transformation function to get\r\n * corresponding output values.</span>\r\n *\r\n * ![](map.png)\r\n *\r\n * Similar to the well known `Array.prototype.map` function, this operator\r\n * applies a projection to each value and emits that projection in the output\r\n * Observable.\r\n *\r\n * ## Example\r\n *\r\n * Map every click to the `clientX` position of that click\r\n *\r\n * ```ts\r\n * import { fromEvent, map } from 'rxjs';\r\n *\r\n * const clicks = fromEvent<PointerEvent>(document, 'click');\r\n * const positions = clicks.pipe(map(ev => ev.clientX));\r\n *\r\n * positions.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link mapTo}\r\n * @see {@link pluck}\r\n *\r\n * @param project The function to apply to each `value` emitted by the source\r\n * Observable. The `index` parameter is the number `i` for the i-th emission\r\n * that has happened since the subscription, starting from the number `0`.\r\n * @param thisArg An optional argument to define what `this` is in the\r\n * `project` function.\r\n * @return A function that returns an Observable that emits the values from the\r\n * source Observable transformed by the given `project` function.\r\n */\r\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\r\n  return operate((source, subscriber) => {\r\n    // The index of the value from the source. Used with projection.\r\n    let index = 0;\r\n    // Subscribe to the source, all errors and completions are sent along\r\n    // to the consumer.\r\n    source.subscribe(\r\n      createOperatorSubscriber(subscriber, (value: T) => {\r\n        // Call the projection function with the appropriate this context,\r\n        // and send the resulting value to the consumer.\r\n        subscriber.next(project.call(thisArg, value, index++));\r\n      })\r\n    );\r\n  });\r\n}\r\n", "import { OperatorFunction } from \"../types\";\r\nimport { map } from \"../operators/map\";\r\n\r\nconst { isArray } = Array;\r\n\r\nfunction callOrApply<T, R>(fn: ((...values: T[]) => R), args: T|T[]): R {\r\n    return isArray(args) ? fn(...args) : fn(args);\r\n}\r\n\r\n/**\r\n * Used in several -- mostly deprecated -- situations where we need to \r\n * apply a list of arguments or a single argument to a result selector.\r\n */\r\nexport function mapOneOrManyArgs<T, R>(fn: ((...values: T[]) => R)): OperatorFunction<T|T[], R> {\r\n    return map(args => callOrApply(fn, args))\r\n}", "import { SchedulerLike } from '../types';\r\nimport { isScheduler } from '../util/isScheduler';\r\nimport { Observable } from '../Observable';\r\nimport { subscribeOn } from '../operators/subscribeOn';\r\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\r\nimport { observeOn } from '../operators/observeOn';\r\nimport { AsyncSubject } from '../AsyncSubject';\r\n\r\nexport function bindCallbackInternals(\r\n  isNodeStyle: boolean,\r\n  callbackFunc: any,\r\n  resultSelector?: any,\r\n  scheduler?: SchedulerLike\r\n): (...args: any[]) => Observable<unknown> {\r\n  if (resultSelector) {\r\n    if (isScheduler(resultSelector)) {\r\n      scheduler = resultSelector;\r\n    } else {\r\n      // The user provided a result selector.\r\n      return function (this: any, ...args: any[]) {\r\n        return (bindCallbackInternals(isNodeStyle, callbackFunc, scheduler) as any)\r\n          .apply(this, args)\r\n          .pipe(mapOneOrManyArgs(resultSelector as any));\r\n      };\r\n    }\r\n  }\r\n\r\n  // If a scheduler was passed, use our `subscribeOn` and `observeOn` operators\r\n  // to compose that behavior for the user.\r\n  if (scheduler) {\r\n    return function (this: any, ...args: any[]) {\r\n      return (bindCallbackInternals(isNodeStyle, callbackFunc) as any)\r\n        .apply(this, args)\r\n        .pipe(subscribeOn(scheduler!), observeOn(scheduler!));\r\n    };\r\n  }\r\n\r\n  return function (this: any, ...args: any[]): Observable<any> {\r\n    // We're using AsyncSubject, because it emits when it completes,\r\n    // and it will play the value to all late-arriving subscribers.\r\n    const subject = new AsyncSubject<any>();\r\n\r\n    // If this is true, then we haven't called our function yet.\r\n    let uninitialized = true;\r\n    return new Observable((subscriber) => {\r\n      // Add our subscriber to the subject.\r\n      const subs = subject.subscribe(subscriber);\r\n\r\n      if (uninitialized) {\r\n        uninitialized = false;\r\n        // We're going to execute the bound function\r\n        // This bit is to signal that we are hitting the callback asynchronously.\r\n        // Because we don't have any anti-\"Zalgo\" guarantees with whatever\r\n        // function we are handed, we use this bit to figure out whether or not\r\n        // we are getting hit in a callback synchronously during our call.\r\n        let isAsync = false;\r\n\r\n        // This is used to signal that the callback completed synchronously.\r\n        let isComplete = false;\r\n\r\n        // Call our function that has a callback. If at any time during this\r\n        // call, an error is thrown, it will be caught by the Observable\r\n        // subscription process and sent to the consumer.\r\n        callbackFunc.apply(\r\n          // Pass the appropriate `this` context.\r\n          this,\r\n          [\r\n            // Pass the arguments.\r\n            ...args,\r\n            // And our callback handler.\r\n            (...results: any[]) => {\r\n              if (isNodeStyle) {\r\n                // If this is a node callback, shift the first value off of the\r\n                // results and check it, as it is the error argument. By shifting,\r\n                // we leave only the argument(s) we want to pass to the consumer.\r\n                const err = results.shift();\r\n                if (err != null) {\r\n                  subject.error(err);\r\n                  // If we've errored, we can stop processing this function\r\n                  // as there's nothing else to do. Just return to escape.\r\n                  return;\r\n                }\r\n              }\r\n              // If we have one argument, notify the consumer\r\n              // of it as a single value, otherwise, if there's more than one, pass\r\n              // them as an array. Note that if there are no arguments, `undefined`\r\n              // will be emitted.\r\n              subject.next(1 < results.length ? results : results[0]);\r\n              // Flip this flag, so we know we can complete it in the synchronous\r\n              // case below.\r\n              isComplete = true;\r\n              // If we're not asynchronous, we need to defer the `complete` call\r\n              // until after the call to the function is over. This is because an\r\n              // error could be thrown in the function after it calls our callback,\r\n              // and if that is the case, if we complete here, we are unable to notify\r\n              // the consumer than an error occurred.\r\n              if (isAsync) {\r\n                subject.complete();\r\n              }\r\n            },\r\n          ]\r\n        );\r\n        // If we flipped `isComplete` during the call, we resolved synchronously,\r\n        // notify complete, because we skipped it in the callback to wait\r\n        // to make sure there were no errors during the call.\r\n        if (isComplete) {\r\n          subject.complete();\r\n        }\r\n\r\n        // We're no longer synchronous. If the callback is called at this point\r\n        // we can notify complete on the spot.\r\n        isAsync = true;\r\n      }\r\n\r\n      // Return the subscription from adding our subscriber to the subject.\r\n      return subs;\r\n    });\r\n  };\r\n}\r\n", "/* @prettier */\r\nimport { SchedulerLike } from '../types';\r\nimport { Observable } from '../Observable';\r\nimport { bindCallbackInternals } from './bindCallbackInternals';\r\n\r\nexport function bindCallback(\r\n  callbackFunc: (...args: any[]) => void,\r\n  resultSelector: (...args: any[]) => any,\r\n  scheduler?: SchedulerLike\r\n): (...args: any[]) => Observable<any>;\r\n\r\n// args is the arguments array and we push the callback on the rest tuple since the rest parameter must be last (only item) in a parameter list\r\nexport function bindCallback<A extends readonly unknown[], R extends readonly unknown[]>(\r\n  callbackFunc: (...args: [...A, (...res: R) => void]) => void,\r\n  schedulerLike?: SchedulerLike\r\n): (...arg: A) => Observable<R extends [] ? void : R extends [any] ? R[0] : R>;\r\n\r\n/**\r\n * Converts a callback API to a function that returns an Observable.\r\n *\r\n * <span class=\"informal\">Give it a function `f` of type `f(x, callback)` and\r\n * it will return a function `g` that when called as `g(x)` will output an\r\n * Observable.</span>\r\n *\r\n * `bindCallback` is not an operator because its input and output are not\r\n * Observables. The input is a function `func` with some parameters. The\r\n * last parameter must be a callback function that `func` calls when it is\r\n * done.\r\n *\r\n * The output of `bindCallback` is a function that takes the same parameters\r\n * as `func`, except the last one (the callback). When the output function\r\n * is called with arguments it will return an Observable. If function `func`\r\n * calls its callback with one argument, the Observable will emit that value.\r\n * If on the other hand the callback is called with multiple values the resulting\r\n * Observable will emit an array with said values as arguments.\r\n *\r\n * It is **very important** to remember that input function `func` is not called\r\n * when the output function is, but rather when the Observable returned by the output\r\n * function is subscribed. This means if `func` makes an AJAX request, that request\r\n * will be made every time someone subscribes to the resulting Observable, but not before.\r\n *\r\n * The last optional parameter - `scheduler` - can be used to control when the call\r\n * to `func` happens after someone subscribes to Observable, as well as when results\r\n * passed to callback will be emitted. By default, the subscription to an Observable calls `func`\r\n * synchronously, but using {@link asyncScheduler} as the last parameter will defer the call to `func`,\r\n * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you were to use the async Scheduler\r\n * and call `subscribe` on the output Observable, all function calls that are currently executing\r\n * will end before `func` is invoked.\r\n *\r\n * By default, results passed to the callback are emitted immediately after `func` invokes the callback.\r\n * In particular, if the callback is called synchronously, then the subscription of the resulting Observable\r\n * will call the `next` function synchronously as well.  If you want to defer that call,\r\n * you may use {@link asyncScheduler} just as before.  This means that by using `Scheduler.async` you can\r\n * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.\r\n *\r\n * Note that the Observable created by the output function will always emit a single value\r\n * and then complete immediately. If `func` calls the callback multiple times, values from subsequent\r\n * calls will not appear in the stream. If you need to listen for multiple calls,\r\n *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.\r\n *\r\n * If `func` depends on some context (`this` property) and is not already bound, the context of `func`\r\n * will be the context that the output function has at call time. In particular, if `func`\r\n * is called as a method of some object and if `func` is not already bound, in order to preserve the context\r\n * it is recommended that the context of the output function is set to that object as well.\r\n *\r\n * If the input function calls its callback in the \"node style\" (i.e. first argument to callback is\r\n * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}\r\n * provides convenient error handling and probably is a better choice.\r\n * `bindCallback` will treat such functions the same as any other and error parameters\r\n * (whether passed or not) will always be interpreted as regular callback argument.\r\n *\r\n * ## Examples\r\n *\r\n * Convert jQuery's getJSON to an Observable API\r\n *\r\n * ```ts\r\n * import { bindCallback } from 'rxjs';\r\n * import * as jQuery from 'jquery';\r\n *\r\n * // Suppose we have jQuery.getJSON('/my/url', callback)\r\n * const getJSONAsObservable = bindCallback(jQuery.getJSON);\r\n * const result = getJSONAsObservable('/my/url');\r\n * result.subscribe(x => console.log(x), e => console.error(e));\r\n * ```\r\n *\r\n * Receive an array of arguments passed to a callback\r\n *\r\n * ```ts\r\n * import { bindCallback } from 'rxjs';\r\n *\r\n * const someFunction = (n, s, cb) => {\r\n *   cb(n, s, { someProperty: 'someValue' });\r\n * };\r\n *\r\n * const boundSomeFunction = bindCallback(someFunction);\r\n * boundSomeFunction(5, 'some string').subscribe((values) => {\r\n *   console.log(values); // [5, 'some string', {someProperty: 'someValue'}]\r\n * });\r\n * ```\r\n *\r\n * Compare behaviour with and without `asyncScheduler`\r\n *\r\n * ```ts\r\n * import { bindCallback, asyncScheduler } from 'rxjs';\r\n *\r\n * function iCallMyCallbackSynchronously(cb) {\r\n *   cb();\r\n * }\r\n *\r\n * const boundSyncFn = bindCallback(iCallMyCallbackSynchronously);\r\n * const boundAsyncFn = bindCallback(iCallMyCallbackSynchronously, null, asyncScheduler);\r\n *\r\n * boundSyncFn().subscribe(() => console.log('I was sync!'));\r\n * boundAsyncFn().subscribe(() => console.log('I was async!'));\r\n * console.log('This happened...');\r\n *\r\n * // Logs:\r\n * // I was sync!\r\n * // This happened...\r\n * // I was async!\r\n * ```\r\n *\r\n * Use `bindCallback` on an object method\r\n *\r\n * ```ts\r\n * import { bindCallback } from 'rxjs';\r\n *\r\n * const boundMethod = bindCallback(someObject.methodWithCallback);\r\n * boundMethod\r\n *   .call(someObject) // make sure methodWithCallback has access to someObject\r\n *   .subscribe(subscriber);\r\n * ```\r\n *\r\n * @see {@link bindNodeCallback}\r\n * @see {@link from}\r\n *\r\n * @param callbackFunc A function with a callback as the last parameter.\r\n * @param resultSelector A mapping function used to transform callback events.\r\n * @param scheduler The scheduler on which to schedule the callbacks.\r\n * @return A function which returns the Observable that delivers the same\r\n * values the callback would deliver.\r\n */\r\nexport function bindCallback(\r\n  callbackFunc: (...args: [...any[], (...res: any) => void]) => void,\r\n  resultSelector?: ((...args: any[]) => any) | SchedulerLike,\r\n  scheduler?: SchedulerLike\r\n): (...args: any[]) => Observable<unknown> {\r\n  return bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);\r\n}\r\n", "/* @prettier */\r\nimport { Observable } from '../Observable';\r\nimport { SchedulerLike } from '../types';\r\nimport { bindCallbackInternals } from './bindCallbackInternals';\r\n\r\nexport function bindNodeCallback(\r\n  callbackFunc: (...args: any[]) => void,\r\n  resultSelector: (...args: any[]) => any,\r\n  scheduler?: SchedulerLike\r\n): (...args: any[]) => Observable<any>;\r\n\r\n// args is the arguments array and we push the callback on the rest tuple since the rest parameter must be last (only item) in a parameter list\r\nexport function bindNodeCallback<A extends readonly unknown[], R extends readonly unknown[]>(\r\n  callbackFunc: (...args: [...A, (err: any, ...res: R) => void]) => void,\r\n  schedulerLike?: SchedulerLike\r\n): (...arg: A) => Observable<R extends [] ? void : R extends [any] ? R[0] : R>;\r\n\r\n/**\r\n * Converts a Node.js-style callback API to a function that returns an\r\n * Observable.\r\n *\r\n * <span class=\"informal\">It's just like {@link bindCallback}, but the\r\n * callback is expected to be of type `callback(error, result)`.</span>\r\n *\r\n * `bindNodeCallback` is not an operator because its input and output are not\r\n * Observables. The input is a function `func` with some parameters, but the\r\n * last parameter must be a callback function that `func` calls when it is\r\n * done. The callback function is expected to follow Node.js conventions,\r\n * where the first argument to the callback is an error object, signaling\r\n * whether call was successful. If that object is passed to callback, it means\r\n * something went wrong.\r\n *\r\n * The output of `bindNodeCallback` is a function that takes the same\r\n * parameters as `func`, except the last one (the callback). When the output\r\n * function is called with arguments, it will return an Observable.\r\n * If `func` calls its callback with error parameter present, Observable will\r\n * error with that value as well. If error parameter is not passed, Observable will emit\r\n * second parameter. If there are more parameters (third and so on),\r\n * Observable will emit an array with all arguments, except first error argument.\r\n *\r\n * Note that `func` will not be called at the same time output function is,\r\n * but rather whenever resulting Observable is subscribed. By default call to\r\n * `func` will happen synchronously after subscription, but that can be changed\r\n * with proper `scheduler` provided as optional third parameter. {@link SchedulerLike}\r\n * can also control when values from callback will be emitted by Observable.\r\n * To find out more, check out documentation for {@link bindCallback}, where\r\n * {@link SchedulerLike} works exactly the same.\r\n *\r\n * As in {@link bindCallback}, context (`this` property) of input function will be set to context\r\n * of returned function, when it is called.\r\n *\r\n * After Observable emits value, it will complete immediately. This means\r\n * even if `func` calls callback again, values from second and consecutive\r\n * calls will never appear on the stream. If you need to handle functions\r\n * that call callbacks multiple times, check out {@link fromEvent} or\r\n * {@link fromEventPattern} instead.\r\n *\r\n * Note that `bindNodeCallback` can be used in non-Node.js environments as well.\r\n * \"Node.js-style\" callbacks are just a convention, so if you write for\r\n * browsers or any other environment and API you use implements that callback style,\r\n * `bindNodeCallback` can be safely used on that API functions as well.\r\n *\r\n * Remember that Error object passed to callback does not have to be an instance\r\n * of JavaScript built-in `Error` object. In fact, it does not even have to an object.\r\n * Error parameter of callback function is interpreted as \"present\", when value\r\n * of that parameter is truthy. It could be, for example, non-zero number, non-empty\r\n * string or boolean `true`. In all of these cases resulting Observable would error\r\n * with that value. This means usually regular style callbacks will fail very often when\r\n * `bindNodeCallback` is used. If your Observable errors much more often then you\r\n * would expect, check if callback really is called in Node.js-style and, if not,\r\n * switch to {@link bindCallback} instead.\r\n *\r\n * Note that even if error parameter is technically present in callback, but its value\r\n * is falsy, it still won't appear in array emitted by Observable.\r\n *\r\n * ## Examples\r\n *\r\n *  Read a file from the filesystem and get the data as an Observable\r\n *\r\n * ```ts\r\n * import * as fs from 'fs';\r\n * const readFileAsObservable = bindNodeCallback(fs.readFile);\r\n * const result = readFileAsObservable('./roadNames.txt', 'utf8');\r\n * result.subscribe(x => console.log(x), e => console.error(e));\r\n * ```\r\n *\r\n * Use on function calling callback with multiple arguments\r\n *\r\n * ```ts\r\n * someFunction((err, a, b) => {\r\n *   console.log(err); // null\r\n *   console.log(a); // 5\r\n *   console.log(b); // \"some string\"\r\n * });\r\n * const boundSomeFunction = bindNodeCallback(someFunction);\r\n * boundSomeFunction()\r\n * .subscribe(value => {\r\n *   console.log(value); // [5, \"some string\"]\r\n * });\r\n * ```\r\n *\r\n * Use on function calling callback in regular style\r\n *\r\n * ```ts\r\n * someFunction(a => {\r\n *   console.log(a); // 5\r\n * });\r\n * const boundSomeFunction = bindNodeCallback(someFunction);\r\n * boundSomeFunction()\r\n * .subscribe(\r\n *   value => {}             // never gets called\r\n *   err => console.log(err) // 5\r\n * );\r\n * ```\r\n *\r\n * @see {@link bindCallback}\r\n * @see {@link from}\r\n *\r\n * @param callbackFunc Function with a Node.js-style callback as the last parameter.\r\n * @param resultSelector A mapping function used to transform callback events.\r\n * @param scheduler The scheduler on which to schedule the callbacks.\r\n * @return A function which returns the Observable that delivers the same values the\r\n * Node.js callback would deliver.\r\n */\r\nexport function bindNodeCallback(\r\n  callbackFunc: (...args: [...any[], (err: any, ...res: any) => void]) => void,\r\n  resultSelector?: ((...args: any[]) => any) | SchedulerLike,\r\n  scheduler?: SchedulerLike\r\n): (...args: any[]) => Observable<any> {\r\n  return bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);\r\n}\r\n", "const { isArray } = Array;\r\nconst { getPrototypeOf, prototype: objectProto, keys: getKeys } = Object;\r\n\r\n/**\r\n * Used in functions where either a list of arguments, a single array of arguments, or a\r\n * dictionary of arguments can be returned. Returns an object with an `args` property with\r\n * the arguments in an array, if it is a dictionary, it will also return the `keys` in another\r\n * property.\r\n */\r\nexport function argsArgArrayOrObject<T, O extends Record<string, T>>(args: T[] | [O] | [T[]]): { args: T[]; keys: string[] | null } {\r\n  if (args.length === 1) {\r\n    const first = args[0];\r\n    if (isArray(first)) {\r\n      return { args: first, keys: null };\r\n    }\r\n    if (isPOJO(first)) {\r\n      const keys = getKeys(first);\r\n      return {\r\n        args: keys.map((key) => first[key]),\r\n        keys,\r\n      };\r\n    }\r\n  }\r\n\r\n  return { args: args as T[], keys: null };\r\n}\r\n\r\nfunction isPOJO(obj: any): obj is object {\r\n  return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;\r\n}\r\n", "export function createObject(keys: string[], values: any[]) {\r\n  return keys.reduce((result, key, i) => ((result[key] = values[i]), result), {} as any);\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { ObservableInput, SchedulerLike, ObservedValueOf, ObservableInputTuple } from '../types';\r\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { from } from './from';\r\nimport { identity } from '../util/identity';\r\nimport { Subscription } from '../Subscription';\r\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\r\nimport { popResultSelector, popScheduler } from '../util/args';\r\nimport { createObject } from '../util/createObject';\r\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\r\nimport { AnyCatcher } from '../AnyCatcher';\r\nimport { executeSchedule } from '../util/executeSchedule';\r\n\r\n// combineLatest(any)\r\n// We put this first because we need to catch cases where the user has supplied\r\n// _exactly `any`_ as the argument. Since `any` literally matches _anything_,\r\n// we don't want it to randomly hit one of the other type signatures below,\r\n// as we have no idea at build-time what type we should be returning when given an any.\r\n\r\n/**\r\n * You have passed `any` here, we can't figure out if it is\r\n * an array or an object, so you're getting `unknown`. Use better types.\r\n * @param arg Something typed as `any`\r\n */\r\nexport function combineLatest<T extends AnyCatcher>(arg: T): Observable<unknown>;\r\n\r\n// combineLatest([a, b, c])\r\nexport function combineLatest(sources: []): Observable<never>;\r\nexport function combineLatest<A extends readonly unknown[]>(sources: readonly [...ObservableInputTuple<A>]): Observable<A>;\r\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\r\nexport function combineLatest<A extends readonly unknown[], R>(\r\n  sources: readonly [...ObservableInputTuple<A>],\r\n  resultSelector: (...values: A) => R,\r\n  scheduler: SchedulerLike\r\n): Observable<R>;\r\nexport function combineLatest<A extends readonly unknown[], R>(\r\n  sources: readonly [...ObservableInputTuple<A>],\r\n  resultSelector: (...values: A) => R\r\n): Observable<R>;\r\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\r\nexport function combineLatest<A extends readonly unknown[]>(\r\n  sources: readonly [...ObservableInputTuple<A>],\r\n  scheduler: SchedulerLike\r\n): Observable<A>;\r\n\r\n// combineLatest(a, b, c)\r\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\r\nexport function combineLatest<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A>;\r\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\r\nexport function combineLatest<A extends readonly unknown[], R>(\r\n  ...sourcesAndResultSelectorAndScheduler: [...ObservableInputTuple<A>, (...values: A) => R, SchedulerLike]\r\n): Observable<R>;\r\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\r\nexport function combineLatest<A extends readonly unknown[], R>(\r\n  ...sourcesAndResultSelector: [...ObservableInputTuple<A>, (...values: A) => R]\r\n): Observable<R>;\r\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\r\nexport function combineLatest<A extends readonly unknown[]>(\r\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike]\r\n): Observable<A>;\r\n\r\n// combineLatest({a, b, c})\r\nexport function combineLatest(sourcesObject: { [K in any]: never }): Observable<never>;\r\nexport function combineLatest<T extends Record<string, ObservableInput<any>>>(\r\n  sourcesObject: T\r\n): Observable<{ [K in keyof T]: ObservedValueOf<T[K]> }>;\r\n\r\n/**\r\n * Combines multiple Observables to create an Observable whose values are\r\n * calculated from the latest values of each of its input Observables.\r\n *\r\n * <span class=\"informal\">Whenever any input Observable emits a value, it\r\n * computes a formula using the latest values from all the inputs, then emits\r\n * the output of that formula.</span>\r\n *\r\n * ![](combineLatest.png)\r\n *\r\n * `combineLatest` combines the values from all the Observables passed in the\r\n * observables array. This is done by subscribing to each Observable in order and,\r\n * whenever any Observable emits, collecting an array of the most recent\r\n * values from each Observable. So if you pass `n` Observables to this operator,\r\n * the returned Observable will always emit an array of `n` values, in an order\r\n * corresponding to the order of the passed Observables (the value from the first Observable\r\n * will be at index 0 of the array and so on).\r\n *\r\n * Static version of `combineLatest` accepts an array of Observables. Note that an array of\r\n * Observables is a good choice, if you don't know beforehand how many Observables\r\n * you will combine. Passing an empty array will result in an Observable that\r\n * completes immediately.\r\n *\r\n * To ensure the output array always has the same length, `combineLatest` will\r\n * actually wait for all input Observables to emit at least once,\r\n * before it starts emitting results. This means if some Observable emits\r\n * values before other Observables started emitting, all these values but the last\r\n * will be lost. On the other hand, if some Observable does not emit a value but\r\n * completes, resulting Observable will complete at the same moment without\r\n * emitting anything, since it will now be impossible to include a value from the\r\n * completed Observable in the resulting array. Also, if some input Observable does\r\n * not emit any value and never completes, `combineLatest` will also never emit\r\n * and never complete, since, again, it will wait for all streams to emit some\r\n * value.\r\n *\r\n * If at least one Observable was passed to `combineLatest` and all passed Observables\r\n * emitted something, the resulting Observable will complete when all combined\r\n * streams complete. So even if some Observable completes, the result of\r\n * `combineLatest` will still emit values when other Observables do. In case\r\n * of a completed Observable, its value from now on will always be the last\r\n * emitted value. On the other hand, if any Observable errors, `combineLatest`\r\n * will error immediately as well, and all other Observables will be unsubscribed.\r\n *\r\n * ## Examples\r\n *\r\n * Combine two timer Observables\r\n *\r\n * ```ts\r\n * import { timer, combineLatest } from 'rxjs';\r\n *\r\n * const firstTimer = timer(0, 1000); // emit 0, 1, 2... after every second, starting from now\r\n * const secondTimer = timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now\r\n * const combinedTimers = combineLatest([firstTimer, secondTimer]);\r\n * combinedTimers.subscribe(value => console.log(value));\r\n * // Logs\r\n * // [0, 0] after 0.5s\r\n * // [1, 0] after 1s\r\n * // [1, 1] after 1.5s\r\n * // [2, 1] after 2s\r\n * ```\r\n *\r\n * Combine a dictionary of Observables\r\n *\r\n * ```ts\r\n * import { of, delay, startWith, combineLatest } from 'rxjs';\r\n *\r\n * const observables = {\r\n *   a: of(1).pipe(delay(1000), startWith(0)),\r\n *   b: of(5).pipe(delay(5000), startWith(0)),\r\n *   c: of(10).pipe(delay(10000), startWith(0))\r\n * };\r\n * const combined = combineLatest(observables);\r\n * combined.subscribe(value => console.log(value));\r\n * // Logs\r\n * // { a: 0, b: 0, c: 0 } immediately\r\n * // { a: 1, b: 0, c: 0 } after 1s\r\n * // { a: 1, b: 5, c: 0 } after 5s\r\n * // { a: 1, b: 5, c: 10 } after 10s\r\n * ```\r\n *\r\n * Combine an array of Observables\r\n *\r\n * ```ts\r\n * import { of, delay, startWith, combineLatest } from 'rxjs';\r\n *\r\n * const observables = [1, 5, 10].map(\r\n *   n => of(n).pipe(\r\n *     delay(n * 1000), // emit 0 and then emit n after n seconds\r\n *     startWith(0)\r\n *   )\r\n * );\r\n * const combined = combineLatest(observables);\r\n * combined.subscribe(value => console.log(value));\r\n * // Logs\r\n * // [0, 0, 0] immediately\r\n * // [1, 0, 0] after 1s\r\n * // [1, 5, 0] after 5s\r\n * // [1, 5, 10] after 10s\r\n * ```\r\n *\r\n * Use map operator to dynamically calculate the Body-Mass Index\r\n *\r\n * ```ts\r\n * import { of, combineLatest, map } from 'rxjs';\r\n *\r\n * const weight = of(70, 72, 76, 79, 75);\r\n * const height = of(1.76, 1.77, 1.78);\r\n * const bmi = combineLatest([weight, height]).pipe(\r\n *   map(([w, h]) => w / (h * h)),\r\n * );\r\n * bmi.subscribe(x => console.log('BMI is ' + x));\r\n *\r\n * // With output to console:\r\n * // BMI is 24.212293388429753\r\n * // BMI is 23.93948099205209\r\n * // BMI is 23.671253629592222\r\n * ```\r\n *\r\n * @see {@link combineLatestAll}\r\n * @see {@link merge}\r\n * @see {@link withLatestFrom}\r\n *\r\n * @param args Any number of `ObservableInput`s provided either as an array or as an object\r\n * to combine with each other. If the last parameter is the function, it will be used to project the\r\n * values from the combined latest values into a new value on the output Observable.\r\n * @return An Observable of projected values from the most recent values from each `ObservableInput`,\r\n * or an array of the most recent values from each `ObservableInput`.\r\n */\r\nexport function combineLatest<O extends ObservableInput<any>, R>(...args: any[]): Observable<R> | Observable<ObservedValueOf<O>[]> {\r\n  const scheduler = popScheduler(args);\r\n  const resultSelector = popResultSelector(args);\r\n\r\n  const { args: observables, keys } = argsArgArrayOrObject(args);\r\n\r\n  if (observables.length === 0) {\r\n    // If no observables are passed, or someone has passed an empty array\r\n    // of observables, or even an empty object POJO, we need to just\r\n    // complete (EMPTY), but we have to honor the scheduler provided if any.\r\n    return from([], scheduler as any);\r\n  }\r\n\r\n  const result = new Observable<ObservedValueOf<O>[]>(\r\n    combineLatestInit(\r\n      observables as ObservableInput<ObservedValueOf<O>>[],\r\n      scheduler,\r\n      keys\r\n        ? // A handler for scrubbing the array of args into a dictionary.\r\n          (values) => createObject(keys, values)\r\n        : // A passthrough to just return the array\r\n          identity\r\n    )\r\n  );\r\n\r\n  return resultSelector ? (result.pipe(mapOneOrManyArgs(resultSelector)) as Observable<R>) : result;\r\n}\r\n\r\nexport function combineLatestInit(\r\n  observables: ObservableInput<any>[],\r\n  scheduler?: SchedulerLike,\r\n  valueTransform: (values: any[]) => any = identity\r\n) {\r\n  return (subscriber: Subscriber<any>) => {\r\n    // The outer subscription. We're capturing this in a function\r\n    // because we may have to schedule it.\r\n    maybeSchedule(\r\n      scheduler,\r\n      () => {\r\n        const { length } = observables;\r\n        // A store for the values each observable has emitted so far. We match observable to value on index.\r\n        const values = new Array(length);\r\n        // The number of currently active subscriptions, as they complete, we decrement this number to see if\r\n        // we are all done combining values, so we can complete the result.\r\n        let active = length;\r\n        // The number of inner sources that still haven't emitted the first value\r\n        // We need to track this because all sources need to emit one value in order\r\n        // to start emitting values.\r\n        let remainingFirstValues = length;\r\n        // The loop to kick off subscription. We're keying everything on index `i` to relate the observables passed\r\n        // in to the slot in the output array or the key in the array of keys in the output dictionary.\r\n        for (let i = 0; i < length; i++) {\r\n          maybeSchedule(\r\n            scheduler,\r\n            () => {\r\n              const source = from(observables[i], scheduler as any);\r\n              let hasFirstValue = false;\r\n              source.subscribe(\r\n                createOperatorSubscriber(\r\n                  subscriber,\r\n                  (value) => {\r\n                    // When we get a value, record it in our set of values.\r\n                    values[i] = value;\r\n                    if (!hasFirstValue) {\r\n                      // If this is our first value, record that.\r\n                      hasFirstValue = true;\r\n                      remainingFirstValues--;\r\n                    }\r\n                    if (!remainingFirstValues) {\r\n                      // We're not waiting for any more\r\n                      // first values, so we can emit!\r\n                      subscriber.next(valueTransform(values.slice()));\r\n                    }\r\n                  },\r\n                  () => {\r\n                    if (!--active) {\r\n                      // We only complete the result if we have no more active\r\n                      // inner observables.\r\n                      subscriber.complete();\r\n                    }\r\n                  }\r\n                )\r\n              );\r\n            },\r\n            subscriber\r\n          );\r\n        }\r\n      },\r\n      subscriber\r\n    );\r\n  };\r\n}\r\n\r\n/**\r\n * A small utility to handle the couple of locations where we want to schedule if a scheduler was provided,\r\n * but we don't if there was no scheduler.\r\n */\r\nfunction maybeSchedule(scheduler: SchedulerLike | undefined, execute: () => void, subscription: Subscription) {\r\n  if (scheduler) {\r\n    executeSchedule(subscription, scheduler, execute);\r\n  } else {\r\n    execute();\r\n  }\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { ObservableInput, SchedulerLike } from '../types';\r\nimport { executeSchedule } from '../util/executeSchedule';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * A process embodying the general \"merge\" strategy. This is used in\r\n * `mergeMap` and `mergeScan` because the logic is otherwise nearly identical.\r\n * @param source The original source observable\r\n * @param subscriber The consumer subscriber\r\n * @param project The projection function to get our inner sources\r\n * @param concurrent The number of concurrent inner subscriptions\r\n * @param onBeforeNext Additional logic to apply before nexting to our consumer\r\n * @param expand If `true` this will perform an \"expand\" strategy, which differs only\r\n * in that it recurses, and the inner subscription must be schedule-able.\r\n * @param innerSubScheduler A scheduler to use to schedule inner subscriptions,\r\n * this is to support the expand strategy, mostly, and should be deprecated\r\n */\r\nexport function mergeInternals<T, R>(\r\n  source: Observable<T>,\r\n  subscriber: Subscriber<R>,\r\n  project: (value: T, index: number) => ObservableInput<R>,\r\n  concurrent: number,\r\n  onBeforeNext?: (innerValue: R) => void,\r\n  expand?: boolean,\r\n  innerSubScheduler?: SchedulerLike,\r\n  additionalFinalizer?: () => void\r\n) {\r\n  // Buffered values, in the event of going over our concurrency limit\r\n  const buffer: T[] = [];\r\n  // The number of active inner subscriptions.\r\n  let active = 0;\r\n  // An index to pass to our accumulator function\r\n  let index = 0;\r\n  // Whether or not the outer source has completed.\r\n  let isComplete = false;\r\n\r\n  /**\r\n   * Checks to see if we can complete our result or not.\r\n   */\r\n  const checkComplete = () => {\r\n    // If the outer has completed, and nothing is left in the buffer,\r\n    // and we don't have any active inner subscriptions, then we can\r\n    // Emit the state and complete.\r\n    if (isComplete && !buffer.length && !active) {\r\n      subscriber.complete();\r\n    }\r\n  };\r\n\r\n  // If we're under our concurrency limit, just start the inner subscription, otherwise buffer and wait.\r\n  const outerNext = (value: T) => (active < concurrent ? doInnerSub(value) : buffer.push(value));\r\n\r\n  const doInnerSub = (value: T) => {\r\n    // If we're expanding, we need to emit the outer values and the inner values\r\n    // as the inners will \"become outers\" in a way as they are recursively fed\r\n    // back to the projection mechanism.\r\n    expand && subscriber.next(value as any);\r\n\r\n    // Increment the number of active subscriptions so we can track it\r\n    // against our concurrency limit later.\r\n    active++;\r\n\r\n    // A flag used to show that the inner observable completed.\r\n    // This is checked during finalization to see if we should\r\n    // move to the next item in the buffer, if there is on.\r\n    let innerComplete = false;\r\n\r\n    // Start our inner subscription.\r\n    innerFrom(project(value, index++)).subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (innerValue) => {\r\n          // `mergeScan` has additional handling here. For example\r\n          // taking the inner value and updating state.\r\n          onBeforeNext?.(innerValue);\r\n\r\n          if (expand) {\r\n            // If we're expanding, then just recurse back to our outer\r\n            // handler. It will emit the value first thing.\r\n            outerNext(innerValue as any);\r\n          } else {\r\n            // Otherwise, emit the inner value.\r\n            subscriber.next(innerValue);\r\n          }\r\n        },\r\n        () => {\r\n          // Flag that we have completed, so we know to check the buffer\r\n          // during finalization.\r\n          innerComplete = true;\r\n        },\r\n        // Errors are passed to the destination.\r\n        undefined,\r\n        () => {\r\n          // During finalization, if the inner completed (it wasn't errored or\r\n          // cancelled), then we want to try the next item in the buffer if\r\n          // there is one.\r\n          if (innerComplete) {\r\n            // We have to wrap this in a try/catch because it happens during\r\n            // finalization, possibly asynchronously, and we want to pass\r\n            // any errors that happen (like in a projection function) to\r\n            // the outer Subscriber.\r\n            try {\r\n              // INNER SOURCE COMPLETE\r\n              // Decrement the active count to ensure that the next time\r\n              // we try to call `doInnerSub`, the number is accurate.\r\n              active--;\r\n              // If we have more values in the buffer, try to process those\r\n              // Note that this call will increment `active` ahead of the\r\n              // next conditional, if there were any more inner subscriptions\r\n              // to start.\r\n              while (buffer.length && active < concurrent) {\r\n                const bufferedValue = buffer.shift()!;\r\n                // Particularly for `expand`, we need to check to see if a scheduler was provided\r\n                // for when we want to start our inner subscription. Otherwise, we just start\r\n                // are next inner subscription.\r\n                if (innerSubScheduler) {\r\n                  executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));\r\n                } else {\r\n                  doInnerSub(bufferedValue);\r\n                }\r\n              }\r\n              // Check to see if we can complete, and complete if so.\r\n              checkComplete();\r\n            } catch (err) {\r\n              subscriber.error(err);\r\n            }\r\n          }\r\n        }\r\n      )\r\n    );\r\n  };\r\n\r\n  // Subscribe to our source observable.\r\n  source.subscribe(\r\n    createOperatorSubscriber(subscriber, outerNext, () => {\r\n      // Outer completed, make a note of it, and check to see if we can complete everything.\r\n      isComplete = true;\r\n      checkComplete();\r\n    })\r\n  );\r\n\r\n  // Additional finalization (for when the destination is torn down).\r\n  // Other finalization is added implicitly via subscription above.\r\n  return () => {\r\n    additionalFinalizer?.();\r\n  };\r\n}\r\n", "import { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\r\nimport { map } from './map';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { operate } from '../util/lift';\r\nimport { mergeInternals } from './mergeInternals';\r\nimport { isFunction } from '../util/isFunction';\r\n\r\n/* tslint:disable:max-line-length */\r\nexport function mergeMap<T, O extends ObservableInput<any>>(\r\n  project: (value: T, index: number) => O,\r\n  concurrent?: number\r\n): OperatorFunction<T, ObservedValueOf<O>>;\r\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\r\nexport function mergeMap<T, O extends ObservableInput<any>>(\r\n  project: (value: T, index: number) => O,\r\n  resultSelector: undefined,\r\n  concurrent?: number\r\n): OperatorFunction<T, ObservedValueOf<O>>;\r\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\r\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\r\n  project: (value: T, index: number) => O,\r\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R,\r\n  concurrent?: number\r\n): OperatorFunction<T, R>;\r\n/* tslint:enable:max-line-length */\r\n\r\n/**\r\n * Projects each source value to an Observable which is merged in the output\r\n * Observable.\r\n *\r\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\r\n * these inner Observables using {@link mergeAll}.</span>\r\n *\r\n * ![](mergeMap.png)\r\n *\r\n * Returns an Observable that emits items based on applying a function that you\r\n * supply to each item emitted by the source Observable, where that function\r\n * returns an Observable, and then merging those resulting Observables and\r\n * emitting the results of this merger.\r\n *\r\n * ## Example\r\n *\r\n * Map and flatten each letter to an Observable ticking every 1 second\r\n *\r\n * ```ts\r\n * import { of, mergeMap, interval, map } from 'rxjs';\r\n *\r\n * const letters = of('a', 'b', 'c');\r\n * const result = letters.pipe(\r\n *   mergeMap(x => interval(1000).pipe(map(i => x + i)))\r\n * );\r\n *\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Results in the following:\r\n * // a0\r\n * // b0\r\n * // c0\r\n * // a1\r\n * // b1\r\n * // c1\r\n * // continues to list a, b, c every second with respective ascending integers\r\n * ```\r\n *\r\n * @see {@link concatMap}\r\n * @see {@link exhaustMap}\r\n * @see {@link merge}\r\n * @see {@link mergeAll}\r\n * @see {@link mergeMapTo}\r\n * @see {@link mergeScan}\r\n * @see {@link switchMap}\r\n *\r\n * @param project A function that, when applied to an item emitted by the source\r\n * Observable, returns an Observable.\r\n * @param concurrent Maximum number of `ObservableInput`s being subscribed to concurrently.\r\n * @return A function that returns an Observable that emits the result of\r\n * applying the projection function (and the optional deprecated\r\n * `resultSelector`) to each item emitted by the source Observable and merging\r\n * the results of the Observables obtained from this transformation.\r\n */\r\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\r\n  project: (value: T, index: number) => O,\r\n  resultSelector?: ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R) | number,\r\n  concurrent: number = Infinity\r\n): OperatorFunction<T, ObservedValueOf<O> | R> {\r\n  if (isFunction(resultSelector)) {\r\n    // DEPRECATED PATH\r\n    return mergeMap((a, i) => map((b: any, ii: number) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);\r\n  } else if (typeof resultSelector === 'number') {\r\n    concurrent = resultSelector;\r\n  }\r\n\r\n  return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));\r\n}\r\n", "import { mergeMap } from './mergeMap';\r\nimport { identity } from '../util/identity';\r\nimport { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\r\n\r\n/**\r\n * Converts a higher-order Observable into a first-order Observable which\r\n * concurrently delivers all values that are emitted on the inner Observables.\r\n *\r\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\r\n *\r\n * ![](mergeAll.png)\r\n *\r\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\r\n * a higher-order Observable. Each time it observes one of these emitted inner\r\n * Observables, it subscribes to that and delivers all the values from the\r\n * inner Observable on the output Observable. The output Observable only\r\n * completes once all inner Observables have completed. Any error delivered by\r\n * a inner Observable will be immediately emitted on the output Observable.\r\n *\r\n * ## Examples\r\n *\r\n * Spawn a new interval Observable for each click event, and blend their outputs as one Observable\r\n *\r\n * ```ts\r\n * import { fromEvent, map, interval, mergeAll } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const higherOrder = clicks.pipe(map(() => interval(1000)));\r\n * const firstOrder = higherOrder.pipe(mergeAll());\r\n *\r\n * firstOrder.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * Count from 0 to 9 every second for each click, but only allow 2 concurrent timers\r\n *\r\n * ```ts\r\n * import { fromEvent, map, interval, take, mergeAll } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const higherOrder = clicks.pipe(\r\n *   map(() => interval(1000).pipe(take(10)))\r\n * );\r\n * const firstOrder = higherOrder.pipe(mergeAll(2));\r\n *\r\n * firstOrder.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link combineLatestAll}\r\n * @see {@link concatAll}\r\n * @see {@link exhaustAll}\r\n * @see {@link merge}\r\n * @see {@link mergeMap}\r\n * @see {@link mergeMapTo}\r\n * @see {@link mergeScan}\r\n * @see {@link switchAll}\r\n * @see {@link switchMap}\r\n * @see {@link zipAll}\r\n *\r\n * @param concurrent Maximum number of inner Observables being subscribed to\r\n * concurrently.\r\n * @return A function that returns an Observable that emits values coming from\r\n * all the inner Observables emitted by the source Observable.\r\n */\r\nexport function mergeAll<O extends ObservableInput<any>>(concurrent: number = Infinity): OperatorFunction<O, ObservedValueOf<O>> {\r\n  return mergeMap(identity, concurrent);\r\n}\r\n", "import { mergeAll } from './mergeAll';\r\nimport { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\r\n\r\n/**\r\n * Converts a higher-order Observable into a first-order Observable by\r\n * concatenating the inner Observables in order.\r\n *\r\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\r\n * inner Observable after the other.</span>\r\n *\r\n * ![](concatAll.svg)\r\n *\r\n * Joins every Observable emitted by the source (a higher-order Observable), in\r\n * a serial fashion. It subscribes to each inner Observable only after the\r\n * previous inner Observable has completed, and merges all of their values into\r\n * the returned observable.\r\n *\r\n * __Warning:__ If the source Observable emits Observables quickly and\r\n * endlessly, and the inner Observables it emits generally complete slower than\r\n * the source emits, you can run into memory issues as the incoming Observables\r\n * collect in an unbounded buffer.\r\n *\r\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\r\n * to `1`.\r\n *\r\n * ## Example\r\n *\r\n * For each click event, tick every second from 0 to 3, with no concurrency\r\n *\r\n * ```ts\r\n * import { fromEvent, map, interval, take, concatAll } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const higherOrder = clicks.pipe(\r\n *   map(() => interval(1000).pipe(take(4)))\r\n * );\r\n * const firstOrder = higherOrder.pipe(concatAll());\r\n * firstOrder.subscribe(x => console.log(x));\r\n *\r\n * // Results in the following:\r\n * // (results are not concurrent)\r\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\r\n * // on a 1000ms interval\r\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\r\n * ```\r\n *\r\n * @see {@link combineLatestAll}\r\n * @see {@link concat}\r\n * @see {@link concatMap}\r\n * @see {@link concatMapTo}\r\n * @see {@link exhaustAll}\r\n * @see {@link mergeAll}\r\n * @see {@link switchAll}\r\n * @see {@link switchMap}\r\n * @see {@link zipAll}\r\n *\r\n * @return A function that returns an Observable emitting values from all the\r\n * inner Observables concatenated.\r\n */\r\nexport function concatAll<O extends ObservableInput<any>>(): OperatorFunction<O, ObservedValueOf<O>> {\r\n  return mergeAll(1);\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { ObservableInputTuple, SchedulerLike } from '../types';\r\nimport { concatAll } from '../operators/concatAll';\r\nimport { popScheduler } from '../util/args';\r\nimport { from } from './from';\r\n\r\nexport function concat<T extends readonly unknown[]>(...inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\r\nexport function concat<T extends readonly unknown[]>(\r\n  ...inputsAndScheduler: [...ObservableInputTuple<T>, SchedulerLike]\r\n): Observable<T[number]>;\r\n\r\n/**\r\n * Creates an output Observable which sequentially emits all values from the first given\r\n * Observable and then moves on to the next.\r\n *\r\n * <span class=\"informal\">Concatenates multiple Observables together by\r\n * sequentially emitting their values, one Observable after the other.</span>\r\n *\r\n * ![](concat.png)\r\n *\r\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\r\n * merging their results into the output Observable. You can pass either an array of\r\n * Observables, or put them directly as arguments. Passing an empty array will result\r\n * in Observable that completes immediately.\r\n *\r\n * `concat` will subscribe to first input Observable and emit all its values, without\r\n * changing or affecting them in any way. When that Observable completes, it will\r\n * subscribe to then next Observable passed and, again, emit its values. This will be\r\n * repeated, until the operator runs out of Observables. When last input Observable completes,\r\n * `concat` will complete as well. At any given moment only one Observable passed to operator\r\n * emits values. If you would like to emit values from passed Observables concurrently, check out\r\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\r\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\r\n *\r\n * Note that if some input Observable never completes, `concat` will also never complete\r\n * and Observables following the one that did not complete will never be subscribed. On the other\r\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\r\n * invisible for `concat`, which will just move on to the next Observable.\r\n *\r\n * If any Observable in chain errors, instead of passing control to the next Observable,\r\n * `concat` will error immediately as well. Observables that would be subscribed after\r\n * the one that emitted error, never will.\r\n *\r\n * If you pass to `concat` the same Observable many times, its stream of values\r\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\r\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\r\n * you can always use {@link repeat}.\r\n *\r\n * ## Examples\r\n *\r\n * Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10\r\n *\r\n * ```ts\r\n * import { interval, take, range, concat } from 'rxjs';\r\n *\r\n * const timer = interval(1000).pipe(take(4));\r\n * const sequence = range(1, 10);\r\n * const result = concat(timer, sequence);\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // results in:\r\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\r\n * ```\r\n *\r\n * Concatenate 3 Observables\r\n *\r\n * ```ts\r\n * import { interval, take, concat } from 'rxjs';\r\n *\r\n * const timer1 = interval(1000).pipe(take(10));\r\n * const timer2 = interval(2000).pipe(take(6));\r\n * const timer3 = interval(500).pipe(take(10));\r\n *\r\n * const result = concat(timer1, timer2, timer3);\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // results in the following:\r\n * // (Prints to console sequentially)\r\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\r\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\r\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\r\n * ```\r\n *\r\n * Concatenate the same Observable to repeat it\r\n *\r\n * ```ts\r\n * import { interval, take, concat } from 'rxjs';\r\n *\r\n * const timer = interval(1000).pipe(take(2));\r\n *\r\n * concat(timer, timer) // concatenating the same Observable!\r\n *   .subscribe({\r\n *     next: value => console.log(value),\r\n *     complete: () => console.log('...and it is done!')\r\n *   });\r\n *\r\n * // Logs:\r\n * // 0 after 1s\r\n * // 1 after 2s\r\n * // 0 after 3s\r\n * // 1 after 4s\r\n * // '...and it is done!' also after 4s\r\n * ```\r\n *\r\n * @see {@link concatAll}\r\n * @see {@link concatMap}\r\n * @see {@link concatMapTo}\r\n * @see {@link startWith}\r\n * @see {@link endWith}\r\n *\r\n * @param args `ObservableInput`s to concatenate.\r\n */\r\nexport function concat(...args: any[]): Observable<unknown> {\r\n  return concatAll()(from(args, popScheduler(args)));\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { ObservedValueOf, ObservableInput } from '../types';\r\nimport { innerFrom } from './innerFrom';\r\n\r\n/**\r\n * Creates an Observable that, on subscribe, calls an Observable factory to\r\n * make an Observable for each new Observer.\r\n *\r\n * <span class=\"informal\">Creates the Observable lazily, that is, only when it\r\n * is subscribed.\r\n * </span>\r\n *\r\n * ![](defer.png)\r\n *\r\n * `defer` allows you to create an Observable only when the Observer\r\n * subscribes. It waits until an Observer subscribes to it, calls the given\r\n * factory function to get an Observable -- where a factory function typically\r\n * generates a new Observable -- and subscribes the Observer to this Observable.\r\n * In case the factory function returns a falsy value, then EMPTY is used as\r\n * Observable instead. Last but not least, an exception during the factory\r\n * function call is transferred to the Observer by calling `error`.\r\n *\r\n * ## Example\r\n *\r\n * Subscribe to either an Observable of clicks or an Observable of interval, at random\r\n *\r\n * ```ts\r\n * import { defer, fromEvent, interval } from 'rxjs';\r\n *\r\n * const clicksOrInterval = defer(() => {\r\n *   return Math.random() > 0.5\r\n *     ? fromEvent(document, 'click')\r\n *     : interval(1000);\r\n * });\r\n * clicksOrInterval.subscribe(x => console.log(x));\r\n *\r\n * // Results in the following behavior:\r\n * // If the result of Math.random() is greater than 0.5 it will listen\r\n * // for clicks anywhere on the \"document\"; when document is clicked it\r\n * // will log a MouseEvent object to the console. If the result is less\r\n * // than 0.5 it will emit ascending numbers, one every second(1000ms).\r\n * ```\r\n *\r\n * @see {@link Observable}\r\n *\r\n * @param observableFactory The Observable factory function to invoke for each\r\n * Observer that subscribes to the output Observable. May also return any\r\n * `ObservableInput`, which will be converted on the fly to an Observable.\r\n * @return An Observable whose Observers' subscriptions trigger an invocation of the\r\n * given Observable factory function.\r\n */\r\nexport function defer<R extends ObservableInput<any>>(observableFactory: () => R): Observable<ObservedValueOf<R>> {\r\n  return new Observable<ObservedValueOf<R>>((subscriber) => {\r\n    innerFrom(observableFactory()).subscribe(subscriber);\r\n  });\r\n}\r\n", "import { Connectable, ObservableInput, SubjectLike } from '../types';\r\nimport { Subject } from '../Subject';\r\nimport { Subscription } from '../Subscription';\r\nimport { Observable } from '../Observable';\r\nimport { defer } from './defer';\r\n\r\nexport interface ConnectableConfig<T> {\r\n  /**\r\n   * A factory function used to create the Subject through which the source\r\n   * is multicast. By default this creates a {@link Subject}.\r\n   */\r\n  connector: () => SubjectLike<T>;\r\n  /**\r\n   * If true, the resulting observable will reset internal state upon disconnection\r\n   * and return to a \"cold\" state. This allows the resulting observable to be\r\n   * reconnected.\r\n   * If false, upon disconnection, the connecting subject will remain the\r\n   * connecting subject, meaning the resulting observable will not go \"cold\" again,\r\n   * and subsequent repeats or resubscriptions will resubscribe to that same subject.\r\n   */\r\n  resetOnDisconnect?: boolean;\r\n}\r\n\r\n/**\r\n * The default configuration for `connectable`.\r\n */\r\nconst DEFAULT_CONFIG: ConnectableConfig<unknown> = {\r\n  connector: () => new Subject<unknown>(),\r\n  resetOnDisconnect: true,\r\n};\r\n\r\n/**\r\n * Creates an observable that multicasts once `connect()` is called on it.\r\n *\r\n * @param source The observable source to make connectable.\r\n * @param config The configuration object for `connectable`.\r\n * @returns A \"connectable\" observable, that has a `connect()` method, that you must call to\r\n * connect the source to all consumers through the subject provided as the connector.\r\n */\r\nexport function connectable<T>(source: ObservableInput<T>, config: ConnectableConfig<T> = DEFAULT_CONFIG): Connectable<T> {\r\n  // The subscription representing the connection.\r\n  let connection: Subscription | null = null;\r\n  const { connector, resetOnDisconnect = true } = config;\r\n  let subject = connector();\r\n\r\n  const result: any = new Observable<T>((subscriber) => {\r\n    return subject.subscribe(subscriber);\r\n  });\r\n\r\n  // Define the `connect` function. This is what users must call\r\n  // in order to \"connect\" the source to the subject that is\r\n  // multicasting it.\r\n  result.connect = () => {\r\n    if (!connection || connection.closed) {\r\n      connection = defer(() => source).subscribe(subject);\r\n      if (resetOnDisconnect) {\r\n        connection.add(() => (subject = connector()));\r\n      }\r\n    }\r\n    return connection;\r\n  };\r\n\r\n  return result;\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { ObservedValueOf, ObservableInputTuple, ObservableInput } from '../types';\r\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\r\nimport { innerFrom } from './innerFrom';\r\nimport { popResultSelector } from '../util/args';\r\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\r\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\r\nimport { createObject } from '../util/createObject';\r\nimport { AnyCatcher } from '../AnyCatcher';\r\n\r\n// forkJoin(any)\r\n// We put this first because we need to catch cases where the user has supplied\r\n// _exactly `any`_ as the argument. Since `any` literally matches _anything_,\r\n// we don't want it to randomly hit one of the other type signatures below,\r\n// as we have no idea at build-time what type we should be returning when given an any.\r\n\r\n/**\r\n * You have passed `any` here, we can't figure out if it is\r\n * an array or an object, so you're getting `unknown`. Use better types.\r\n * @param arg Something typed as `any`\r\n */\r\nexport function forkJoin<T extends AnyCatcher>(arg: T): Observable<unknown>;\r\n\r\n// forkJoin(null | undefined)\r\nexport function forkJoin(scheduler: null | undefined): Observable<never>;\r\n\r\n// forkJoin([a, b, c])\r\nexport function forkJoin(sources: readonly []): Observable<never>;\r\nexport function forkJoin<A extends readonly unknown[]>(sources: readonly [...ObservableInputTuple<A>]): Observable<A>;\r\nexport function forkJoin<A extends readonly unknown[], R>(\r\n  sources: readonly [...ObservableInputTuple<A>],\r\n  resultSelector: (...values: A) => R\r\n): Observable<R>;\r\n\r\n// forkJoin(a, b, c)\r\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\r\nexport function forkJoin<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A>;\r\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\r\nexport function forkJoin<A extends readonly unknown[], R>(\r\n  ...sourcesAndResultSelector: [...ObservableInputTuple<A>, (...values: A) => R]\r\n): Observable<R>;\r\n\r\n// forkJoin({a, b, c})\r\nexport function forkJoin(sourcesObject: { [K in any]: never }): Observable<never>;\r\nexport function forkJoin<T extends Record<string, ObservableInput<any>>>(\r\n  sourcesObject: T\r\n): Observable<{ [K in keyof T]: ObservedValueOf<T[K]> }>;\r\n\r\n/**\r\n * Accepts an `Array` of {@link ObservableInput} or a dictionary `Object` of {@link ObservableInput} and returns\r\n * an {@link Observable} that emits either an array of values in the exact same order as the passed array,\r\n * or a dictionary of values in the same shape as the passed dictionary.\r\n *\r\n * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted;\r\n * complete immediately if an empty array is passed.</span>\r\n *\r\n * ![](forkJoin.png)\r\n *\r\n * `forkJoin` is an operator that takes any number of input observables which can be passed either as an array\r\n * or a dictionary of input observables. If no input observables are provided (e.g. an empty array is passed),\r\n * then the resulting stream will complete immediately.\r\n *\r\n * `forkJoin` will wait for all passed observables to emit and complete and then it will emit an array or an object with last\r\n * values from corresponding observables.\r\n *\r\n * If you pass an array of `n` observables to the operator, then the resulting\r\n * array will have `n` values, where the first value is the last one emitted by the first observable,\r\n * second value is the last one emitted by the second observable and so on.\r\n *\r\n * If you pass a dictionary of observables to the operator, then the resulting\r\n * objects will have the same keys as the dictionary passed, with their last values they have emitted\r\n * located at the corresponding key.\r\n *\r\n * That means `forkJoin` will not emit more than once and it will complete after that. If you need to emit combined\r\n * values not only at the end of the lifecycle of passed observables, but also throughout it, try out {@link combineLatest}\r\n * or {@link zip} instead.\r\n *\r\n * In order for the resulting array to have the same length as the number of input observables, whenever any of\r\n * the given observables completes without emitting any value, `forkJoin` will complete at that moment as well\r\n * and it will not emit anything either, even if it already has some last values from other observables.\r\n * Conversely, if there is an observable that never completes, `forkJoin` will never complete either,\r\n * unless at any point some other observable completes without emitting a value, which brings us back to\r\n * the previous case. Overall, in order for `forkJoin` to emit a value, all given observables\r\n * have to emit something at least once and complete.\r\n *\r\n * If any given observable errors at some point, `forkJoin` will error as well and immediately unsubscribe\r\n * from the other observables.\r\n *\r\n * Optionally `forkJoin` accepts a `resultSelector` function, that will be called with values which normally\r\n * would land in the emitted array. Whatever is returned by the `resultSelector`, will appear in the output\r\n * observable instead. This means that the default `resultSelector` can be thought of as a function that takes\r\n * all its arguments and puts them into an array. Note that the `resultSelector` will be called only\r\n * when `forkJoin` is supposed to emit a result.\r\n *\r\n * ## Examples\r\n *\r\n * Use `forkJoin` with a dictionary of observable inputs\r\n *\r\n * ```ts\r\n * import { forkJoin, of, timer } from 'rxjs';\r\n *\r\n * const observable = forkJoin({\r\n *   foo: of(1, 2, 3, 4),\r\n *   bar: Promise.resolve(8),\r\n *   baz: timer(4000)\r\n * });\r\n * observable.subscribe({\r\n *  next: value => console.log(value),\r\n *  complete: () => console.log('This is how it ends!'),\r\n * });\r\n *\r\n * // Logs:\r\n * // { foo: 4, bar: 8, baz: 0 } after 4 seconds\r\n * // 'This is how it ends!' immediately after\r\n * ```\r\n *\r\n * Use `forkJoin` with an array of observable inputs\r\n *\r\n * ```ts\r\n * import { forkJoin, of, timer } from 'rxjs';\r\n *\r\n * const observable = forkJoin([\r\n *   of(1, 2, 3, 4),\r\n *   Promise.resolve(8),\r\n *   timer(4000)\r\n * ]);\r\n * observable.subscribe({\r\n *  next: value => console.log(value),\r\n *  complete: () => console.log('This is how it ends!'),\r\n * });\r\n *\r\n * // Logs:\r\n * // [4, 8, 0] after 4 seconds\r\n * // 'This is how it ends!' immediately after\r\n * ```\r\n *\r\n * @see {@link combineLatest}\r\n * @see {@link zip}\r\n *\r\n * @param args Any number of `ObservableInput`s provided either as an array, as an object\r\n * or as arguments passed directly to the operator.\r\n * @return Observable emitting either an array of last values emitted by passed Observables\r\n * or value from project function.\r\n */\r\nexport function forkJoin(...args: any[]): Observable<any> {\r\n  const resultSelector = popResultSelector(args);\r\n  const { args: sources, keys } = argsArgArrayOrObject(args);\r\n  const result = new Observable((subscriber) => {\r\n    const { length } = sources;\r\n    if (!length) {\r\n      subscriber.complete();\r\n      return;\r\n    }\r\n    const values = new Array(length);\r\n    let remainingCompletions = length;\r\n    let remainingEmissions = length;\r\n    for (let sourceIndex = 0; sourceIndex < length; sourceIndex++) {\r\n      let hasValue = false;\r\n      innerFrom(sources[sourceIndex]).subscribe(\r\n        createOperatorSubscriber(\r\n          subscriber,\r\n          (value) => {\r\n            if (!hasValue) {\r\n              hasValue = true;\r\n              remainingEmissions--;\r\n            }\r\n            values[sourceIndex] = value;\r\n          },\r\n          () => remainingCompletions--,\r\n          undefined,\r\n          () => {\r\n            if (!remainingCompletions || !hasValue) {\r\n              if (!remainingEmissions) {\r\n                subscriber.next(keys ? createObject(keys, values) : values);\r\n              }\r\n              subscriber.complete();\r\n            }\r\n          }\r\n        )\r\n      );\r\n    }\r\n  });\r\n  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;\r\n}\r\n", "import { innerFrom } from '../observable/innerFrom';\r\nimport { Observable } from '../Observable';\r\nimport { mergeMap } from '../operators/mergeMap';\r\nimport { isArrayLike } from '../util/isArrayLike';\r\nimport { isFunction } from '../util/isFunction';\r\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\r\n\r\n// These constants are used to create handler registry functions using array mapping below.\r\nconst nodeEventEmitterMethods = ['addListener', 'removeListener'] as const;\r\nconst eventTargetMethods = ['addEventListener', 'removeEventListener'] as const;\r\nconst jqueryMethods = ['on', 'off'] as const;\r\n\r\nexport interface NodeStyleEventEmitter {\r\n  addListener(eventName: string | symbol, handler: NodeEventHandler): this;\r\n  removeListener(eventName: string | symbol, handler: NodeEventHandler): this;\r\n}\r\n\r\nexport type NodeEventHandler = (...args: any[]) => void;\r\n\r\n// For APIs that implement `addListener` and `removeListener` methods that may\r\n// not use the same arguments or return EventEmitter values\r\n// such as React Native\r\nexport interface NodeCompatibleEventEmitter {\r\n  addListener(eventName: string, handler: NodeEventHandler): void | {};\r\n  removeListener(eventName: string, handler: NodeEventHandler): void | {};\r\n}\r\n\r\n// Use handler types like those in @types/jquery. See:\r\n// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/847731ba1d7fa6db6b911c0e43aa0afe596e7723/types/jquery/misc.d.ts#L6395\r\nexport interface JQueryStyleEventEmitter<TContext, T> {\r\n  on(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\r\n  off(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\r\n}\r\n\r\nexport interface EventListenerObject<E> {\r\n  handleEvent(evt: E): void;\r\n}\r\n\r\nexport interface HasEventTargetAddRemove<E> {\r\n  addEventListener(\r\n    type: string,\r\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\r\n    options?: boolean | AddEventListenerOptions\r\n  ): void;\r\n  removeEventListener(\r\n    type: string,\r\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\r\n    options?: EventListenerOptions | boolean\r\n  ): void;\r\n}\r\n\r\nexport interface EventListenerOptions {\r\n  capture?: boolean;\r\n  passive?: boolean;\r\n  once?: boolean;\r\n}\r\n\r\nexport interface AddEventListenerOptions extends EventListenerOptions {\r\n  once?: boolean;\r\n  passive?: boolean;\r\n}\r\n\r\nexport function fromEvent<T>(target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>, eventName: string): Observable<T>;\r\nexport function fromEvent<T, R>(\r\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\r\n  eventName: string,\r\n  resultSelector: (event: T) => R\r\n): Observable<R>;\r\nexport function fromEvent<T>(\r\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\r\n  eventName: string,\r\n  options: EventListenerOptions\r\n): Observable<T>;\r\nexport function fromEvent<T, R>(\r\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\r\n  eventName: string,\r\n  options: EventListenerOptions,\r\n  resultSelector: (event: T) => R\r\n): Observable<R>;\r\n\r\nexport function fromEvent(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<unknown>;\r\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\r\nexport function fromEvent<T>(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<T>;\r\nexport function fromEvent<R>(\r\n  target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>,\r\n  eventName: string,\r\n  resultSelector: (...args: any[]) => R\r\n): Observable<R>;\r\n\r\nexport function fromEvent(\r\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\r\n  eventName: string\r\n): Observable<unknown>;\r\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\r\nexport function fromEvent<T>(target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>, eventName: string): Observable<T>;\r\nexport function fromEvent<R>(\r\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\r\n  eventName: string,\r\n  resultSelector: (...args: any[]) => R\r\n): Observable<R>;\r\n\r\nexport function fromEvent<T>(\r\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\r\n  eventName: string\r\n): Observable<T>;\r\nexport function fromEvent<T, R>(\r\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\r\n  eventName: string,\r\n  resultSelector: (value: T, ...args: any[]) => R\r\n): Observable<R>;\r\n\r\n/**\r\n * Creates an Observable that emits events of a specific type coming from the\r\n * given event target.\r\n *\r\n * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\r\n * EventEmitter events or others.</span>\r\n *\r\n * ![](fromEvent.png)\r\n *\r\n * `fromEvent` accepts as a first argument event target, which is an object with methods\r\n * for registering event handler functions. As a second argument it takes string that indicates\r\n * type of event we want to listen for. `fromEvent` supports selected types of event targets,\r\n * which are described in detail below. If your event target does not match any of the ones listed,\r\n * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\r\n * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\r\n * handler functions have different names, but they all accept a string describing event type\r\n * and function itself, which will be called whenever said event happens.\r\n *\r\n * Every time resulting Observable is subscribed, event handler function will be registered\r\n * to event target on given event type. When that event fires, value\r\n * passed as a first argument to registered function will be emitted by output Observable.\r\n * When Observable is unsubscribed, function will be unregistered from event target.\r\n *\r\n * Note that if event target calls registered function with more than one argument, second\r\n * and following arguments will not appear in resulting stream. In order to get access to them,\r\n * you can pass to `fromEvent` optional project function, which will be called with all arguments\r\n * passed to event handler. Output Observable will then emit value returned by project function,\r\n * instead of the usual value.\r\n *\r\n * Remember that event targets listed below are checked via duck typing. It means that\r\n * no matter what kind of object you have and no matter what environment you work in,\r\n * you can safely use `fromEvent` on that object if it exposes described methods (provided\r\n * of course they behave as was described above). So for example if Node.js library exposes\r\n * event target which has the same method names as DOM EventTarget, `fromEvent` is still\r\n * a good choice.\r\n *\r\n * If the API you use is more callback then event handler oriented (subscribed\r\n * callback function fires only once and thus there is no need to manually\r\n * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\r\n * instead.\r\n *\r\n * `fromEvent` supports following types of event targets:\r\n *\r\n * **DOM EventTarget**\r\n *\r\n * This is an object with `addEventListener` and `removeEventListener` methods.\r\n *\r\n * In the browser, `addEventListener` accepts - apart from event type string and event\r\n * handler function arguments - optional third parameter, which is either an object or boolean,\r\n * both used for additional configuration how and when passed function will be called. When\r\n * `fromEvent` is used with event target of that type, you can provide this values\r\n * as third parameter as well.\r\n *\r\n * **Node.js EventEmitter**\r\n *\r\n * An object with `addListener` and `removeListener` methods.\r\n *\r\n * **JQuery-style event target**\r\n *\r\n * An object with `on` and `off` methods\r\n *\r\n * **DOM NodeList**\r\n *\r\n * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\r\n *\r\n * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\r\n * it contains and install event handler function in every of them. When returned Observable\r\n * is unsubscribed, function will be removed from all Nodes.\r\n *\r\n * **DOM HtmlCollection**\r\n *\r\n * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\r\n * installed and removed in each of elements.\r\n *\r\n *\r\n * ## Examples\r\n *\r\n * Emit clicks happening on the DOM document\r\n *\r\n * ```ts\r\n * import { fromEvent } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * clicks.subscribe(x => console.log(x));\r\n *\r\n * // Results in:\r\n * // MouseEvent object logged to console every time a click\r\n * // occurs on the document.\r\n * ```\r\n *\r\n * Use `addEventListener` with capture option\r\n *\r\n * ```ts\r\n * import { fromEvent } from 'rxjs';\r\n *\r\n * const div = document.createElement('div');\r\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\r\n * document.body.appendChild(div);\r\n *\r\n * // note optional configuration parameter which will be passed to addEventListener\r\n * const clicksInDocument = fromEvent(document, 'click', { capture: true });\r\n * const clicksInDiv = fromEvent(div, 'click');\r\n *\r\n * clicksInDocument.subscribe(() => console.log('document'));\r\n * clicksInDiv.subscribe(() => console.log('div'));\r\n *\r\n * // By default events bubble UP in DOM tree, so normally\r\n * // when we would click on div in document\r\n * // \"div\" would be logged first and then \"document\".\r\n * // Since we specified optional `capture` option, document\r\n * // will catch event when it goes DOWN DOM tree, so console\r\n * // will log \"document\" and then \"div\".\r\n * ```\r\n *\r\n * @see {@link bindCallback}\r\n * @see {@link bindNodeCallback}\r\n * @see {@link fromEventPattern}\r\n *\r\n * @param target The DOM EventTarget, Node.js EventEmitter, JQuery-like event target,\r\n * NodeList or HTMLCollection to attach the event handler to.\r\n * @param eventName The event name of interest, being emitted by the `target`.\r\n * @param options Options to pass through to the underlying `addListener`,\r\n * `addEventListener` or `on` functions.\r\n * @param resultSelector A mapping function used to transform events. It takes the\r\n * arguments from the event handler and should return a single value.\r\n * @return An Observable emitting events registered through `target`'s\r\n * listener handlers.\r\n */\r\nexport function fromEvent<T>(\r\n  target: any,\r\n  eventName: string,\r\n  options?: EventListenerOptions | ((...args: any[]) => T),\r\n  resultSelector?: (...args: any[]) => T\r\n): Observable<T> {\r\n  if (isFunction(options)) {\r\n    resultSelector = options;\r\n    options = undefined;\r\n  }\r\n  if (resultSelector) {\r\n    return fromEvent<T>(target, eventName, options as EventListenerOptions).pipe(mapOneOrManyArgs(resultSelector));\r\n  }\r\n\r\n  // Figure out our add and remove methods. In order to do this,\r\n  // we are going to analyze the target in a preferred order, if\r\n  // the target matches a given signature, we take the two \"add\" and \"remove\"\r\n  // method names and apply them to a map to create opposite versions of the\r\n  // same function. This is because they all operate in duplicate pairs,\r\n  // `addListener(name, handler)`, `removeListener(name, handler)`, for example.\r\n  // The call only differs by method name, as to whether or not you're adding or removing.\r\n  const [add, remove] =\r\n    // If it is an EventTarget, we need to use a slightly different method than the other two patterns.\r\n    isEventTarget(target)\r\n      ? eventTargetMethods.map((methodName) => (handler: any) => target[methodName](eventName, handler, options as EventListenerOptions))\r\n      : // In all other cases, the call pattern is identical with the exception of the method names.\r\n      isNodeStyleEventEmitter(target)\r\n      ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))\r\n      : isJQueryStyleEventEmitter(target)\r\n      ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))\r\n      : [];\r\n\r\n  // If add is falsy, it's because we didn't match a pattern above.\r\n  // Check to see if it is an ArrayLike, because if it is, we want to\r\n  // try to apply fromEvent to all of it's items. We do this check last,\r\n  // because there are may be some types that are both ArrayLike *and* implement\r\n  // event registry points, and we'd rather delegate to that when possible.\r\n  if (!add) {\r\n    if (isArrayLike(target)) {\r\n      return mergeMap((subTarget: any) => fromEvent(subTarget, eventName, options as EventListenerOptions))(\r\n        innerFrom(target)\r\n      ) as Observable<T>;\r\n    }\r\n  }\r\n\r\n  // If add is falsy and we made it here, it's because we didn't\r\n  // match any valid target objects above.\r\n  if (!add) {\r\n    throw new TypeError('Invalid event target');\r\n  }\r\n\r\n  return new Observable<T>((subscriber) => {\r\n    // The handler we are going to register. Forwards the event object, by itself, or\r\n    // an array of arguments to the event handler, if there is more than one argument,\r\n    // to the consumer.\r\n    const handler = (...args: any[]) => subscriber.next(1 < args.length ? args : args[0]);\r\n    // Do the work of adding the handler to the target.\r\n    add(handler);\r\n    // When we finalize, we want to remove the handler and free up memory.\r\n    return () => remove!(handler);\r\n  });\r\n}\r\n\r\n/**\r\n * Used to create `add` and `remove` functions to register and unregister event handlers\r\n * from a target in the most common handler pattern, where there are only two arguments.\r\n * (e.g.  `on(name, fn)`, `off(name, fn)`, `addListener(name, fn)`, or `removeListener(name, fn)`)\r\n * @param target The target we're calling methods on\r\n * @param eventName The event name for the event we're creating register or unregister functions for\r\n */\r\nfunction toCommonHandlerRegistry(target: any, eventName: string) {\r\n  return (methodName: string) => (handler: any) => target[methodName](eventName, handler);\r\n}\r\n\r\n/**\r\n * Checks to see if the target implements the required node-style EventEmitter methods\r\n * for adding and removing event handlers.\r\n * @param target the object to check\r\n */\r\nfunction isNodeStyleEventEmitter(target: any): target is NodeStyleEventEmitter {\r\n  return isFunction(target.addListener) && isFunction(target.removeListener);\r\n}\r\n\r\n/**\r\n * Checks to see if the target implements the required jQuery-style EventEmitter methods\r\n * for adding and removing event handlers.\r\n * @param target the object to check\r\n */\r\nfunction isJQueryStyleEventEmitter(target: any): target is JQueryStyleEventEmitter<any, any> {\r\n  return isFunction(target.on) && isFunction(target.off);\r\n}\r\n\r\n/**\r\n * Checks to see if the target implements the required EventTarget methods\r\n * for adding and removing event handlers.\r\n * @param target the object to check\r\n */\r\nfunction isEventTarget(target: any): target is HasEventTargetAddRemove<any> {\r\n  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { isFunction } from '../util/isFunction';\r\nimport { NodeEventHandler } from './fromEvent';\r\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\r\n\r\n/* tslint:disable:max-line-length */\r\nexport function fromEventPattern<T>(\r\n  addHandler: (handler: NodeEventHandler) => any,\r\n  removeHandler?: (handler: NodeEventHandler, signal?: any) => void\r\n): Observable<T>;\r\nexport function fromEventPattern<T>(\r\n  addHandler: (handler: NodeEventHandler) => any,\r\n  removeHandler?: (handler: NodeEventHandler, signal?: any) => void,\r\n  resultSelector?: (...args: any[]) => T\r\n): Observable<T>;\r\n/* tslint:enable:max-line-length */\r\n\r\n/**\r\n * Creates an Observable from an arbitrary API for registering event handlers.\r\n *\r\n * <span class=\"informal\">When that method for adding event handler was something {@link fromEvent}\r\n * was not prepared for.</span>\r\n *\r\n * ![](fromEventPattern.png)\r\n *\r\n * `fromEventPattern` allows you to convert into an Observable any API that supports registering handler functions\r\n * for events. It is similar to {@link fromEvent}, but far\r\n * more flexible. In fact, all use cases of {@link fromEvent} could be easily handled by\r\n * `fromEventPattern` (although in slightly more verbose way).\r\n *\r\n * This operator accepts as a first argument an `addHandler` function, which will be injected with\r\n * handler parameter. That handler is actually an event handler function that you now can pass\r\n * to API expecting it. `addHandler` will be called whenever Observable\r\n * returned by the operator is subscribed, so registering handler in API will not\r\n * necessarily happen when `fromEventPattern` is called.\r\n *\r\n * After registration, every time an event that we listen to happens,\r\n * Observable returned by `fromEventPattern` will emit value that event handler\r\n * function was called with. Note that if event handler was called with more\r\n * than one argument, second and following arguments will not appear in the Observable.\r\n *\r\n * If API you are using allows to unregister event handlers as well, you can pass to `fromEventPattern`\r\n * another function - `removeHandler` - as a second parameter. It will be injected\r\n * with the same handler function as before, which now you can use to unregister\r\n * it from the API. `removeHandler` will be called when consumer of resulting Observable\r\n * unsubscribes from it.\r\n *\r\n * In some APIs unregistering is actually handled differently. Method registering an event handler\r\n * returns some kind of token, which is later used to identify which function should\r\n * be unregistered or it itself has method that unregisters event handler.\r\n * If that is the case with your API, make sure token returned\r\n * by registering method is returned by `addHandler`. Then it will be passed\r\n * as a second argument to `removeHandler`, where you will be able to use it.\r\n *\r\n * If you need access to all event handler parameters (not only the first one),\r\n * or you need to transform them in any way, you can call `fromEventPattern` with optional\r\n * third parameter - project function which will accept all arguments passed to\r\n * event handler when it is called. Whatever is returned from project function will appear on\r\n * resulting stream instead of usual event handlers first argument. This means\r\n * that default project can be thought of as function that takes its first parameter\r\n * and ignores the rest.\r\n *\r\n * ## Examples\r\n *\r\n * Emits clicks happening on the DOM document\r\n *\r\n * ```ts\r\n * import { fromEventPattern } from 'rxjs';\r\n *\r\n * function addClickHandler(handler) {\r\n *   document.addEventListener('click', handler);\r\n * }\r\n *\r\n * function removeClickHandler(handler) {\r\n *   document.removeEventListener('click', handler);\r\n * }\r\n *\r\n * const clicks = fromEventPattern(\r\n *   addClickHandler,\r\n *   removeClickHandler\r\n * );\r\n * clicks.subscribe(x => console.log(x));\r\n *\r\n * // Whenever you click anywhere in the browser, DOM MouseEvent\r\n * // object will be logged.\r\n * ```\r\n *\r\n * Use with API that returns cancellation token\r\n *\r\n * ```ts\r\n * import { fromEventPattern } from 'rxjs';\r\n *\r\n * const token = someAPI.registerEventHandler(function() {});\r\n * someAPI.unregisterEventHandler(token); // this APIs cancellation method accepts\r\n *                                        // not handler itself, but special token.\r\n *\r\n * const someAPIObservable = fromEventPattern(\r\n *   function(handler) { return someAPI.registerEventHandler(handler); }, // Note that we return the token here...\r\n *   function(handler, token) { someAPI.unregisterEventHandler(token); }  // ...to then use it here.\r\n * );\r\n * ```\r\n *\r\n * Use with project function\r\n *\r\n * ```ts\r\n * import { fromEventPattern } from 'rxjs';\r\n *\r\n * someAPI.registerEventHandler((eventType, eventMessage) => {\r\n *   console.log(eventType, eventMessage); // Logs 'EVENT_TYPE' 'EVENT_MESSAGE' to console.\r\n * });\r\n *\r\n * const someAPIObservable = fromEventPattern(\r\n *   handler => someAPI.registerEventHandler(handler),\r\n *   handler => someAPI.unregisterEventHandler(handler)\r\n *   (eventType, eventMessage) => eventType + ' --- ' + eventMessage // without that function only 'EVENT_TYPE'\r\n * );                                                                // would be emitted by the Observable\r\n *\r\n * someAPIObservable.subscribe(value => console.log(value));\r\n *\r\n * // Logs:\r\n * // 'EVENT_TYPE --- EVENT_MESSAGE'\r\n * ```\r\n *\r\n * @see {@link fromEvent}\r\n * @see {@link bindCallback}\r\n * @see {@link bindNodeCallback}\r\n *\r\n * @param addHandler A function that takes a `handler` function as argument and attaches it\r\n * somehow to the actual source of events.\r\n * @param removeHandler A function that takes a `handler` function as an argument and removes\r\n * it from the event source. If `addHandler` returns some kind of token, `removeHandler` function\r\n * will have it as a second parameter.\r\n * @param resultSelector A function to transform results. It takes the arguments from the event\r\n * handler and should return a single value.\r\n * @return Observable which, when an event happens, emits first parameter passed to registered\r\n * event handler. Alternatively it emits whatever project function returns at that moment.\r\n */\r\nexport function fromEventPattern<T>(\r\n  addHandler: (handler: NodeEventHandler) => any,\r\n  removeHandler?: (handler: NodeEventHandler, signal?: any) => void,\r\n  resultSelector?: (...args: any[]) => T\r\n): Observable<T | T[]> {\r\n  if (resultSelector) {\r\n    return fromEventPattern<T>(addHandler, removeHandler).pipe(mapOneOrManyArgs(resultSelector));\r\n  }\r\n\r\n  return new Observable<T | T[]>((subscriber) => {\r\n    const handler = (...e: T[]) => subscriber.next(e.length === 1 ? e[0] : e);\r\n    const retValue = addHandler(handler);\r\n    return isFunction(removeHandler) ? () => removeHandler(handler, retValue) : undefined;\r\n  });\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { identity } from '../util/identity';\r\nimport { ObservableInput, SchedulerLike } from '../types';\r\nimport { isScheduler } from '../util/isScheduler';\r\nimport { defer } from './defer';\r\nimport { scheduleIterable } from '../scheduled/scheduleIterable';\r\n\r\ntype ConditionFunc<S> = (state: S) => boolean;\r\ntype IterateFunc<S> = (state: S) => S;\r\ntype ResultFunc<S, T> = (state: S) => T;\r\n\r\nexport interface GenerateBaseOptions<S> {\r\n  /**\r\n   * Initial state.\r\n   */\r\n  initialState: S;\r\n  /**\r\n   * Condition function that accepts state and returns boolean.\r\n   * When it returns false, the generator stops.\r\n   * If not specified, a generator never stops.\r\n   */\r\n  condition?: ConditionFunc<S>;\r\n  /**\r\n   * Iterate function that accepts state and returns new state.\r\n   */\r\n  iterate: IterateFunc<S>;\r\n  /**\r\n   * SchedulerLike to use for generation process.\r\n   * By default, a generator starts immediately.\r\n   */\r\n  scheduler?: SchedulerLike;\r\n}\r\n\r\nexport interface GenerateOptions<T, S> extends GenerateBaseOptions<S> {\r\n  /**\r\n   * Result selection function that accepts state and returns a value to emit.\r\n   */\r\n  resultSelector: ResultFunc<S, T>;\r\n}\r\n\r\n/**\r\n * Generates an observable sequence by running a state-driven loop\r\n * producing the sequence's elements, using the specified scheduler\r\n * to send out observer messages.\r\n *\r\n * ![](generate.png)\r\n *\r\n * ## Examples\r\n *\r\n * Produces sequence of numbers\r\n *\r\n * ```ts\r\n * import { generate } from 'rxjs';\r\n *\r\n * const result = generate(0, x => x < 3, x => x + 1, x => x);\r\n *\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1\r\n * // 2\r\n * ```\r\n *\r\n * Use `asapScheduler`\r\n *\r\n * ```ts\r\n * import { generate, asapScheduler } from 'rxjs';\r\n *\r\n * const result = generate(1, x => x < 5, x => x * 2, x => x + 1, asapScheduler);\r\n *\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Logs:\r\n * // 2\r\n * // 3\r\n * // 5\r\n * ```\r\n *\r\n * @see {@link from}\r\n * @see {@link Observable}\r\n *\r\n * @param initialState Initial state.\r\n * @param condition Condition to terminate generation (upon returning false).\r\n * @param iterate Iteration step function.\r\n * @param resultSelector Selector function for results produced in the sequence.\r\n * @param scheduler A {@link SchedulerLike} on which to run the generator loop.\r\n * If not provided, defaults to emit immediately.\r\n * @returns The generated sequence.\r\n * @deprecated Instead of passing separate arguments, use the options argument.\r\n * Signatures taking separate arguments will be removed in v8.\r\n */\r\nexport function generate<T, S>(\r\n  initialState: S,\r\n  condition: ConditionFunc<S>,\r\n  iterate: IterateFunc<S>,\r\n  resultSelector: ResultFunc<S, T>,\r\n  scheduler?: SchedulerLike\r\n): Observable<T>;\r\n\r\n/**\r\n * Generates an Observable by running a state-driven loop\r\n * that emits an element on each iteration.\r\n *\r\n * <span class=\"informal\">Use it instead of nexting values in a for loop.</span>\r\n *\r\n * ![](generate.png)\r\n *\r\n * `generate` allows you to create a stream of values generated with a loop very similar to\r\n * a traditional for loop. The first argument of `generate` is a beginning value. The second argument\r\n * is a function that accepts this value and tests if some condition still holds. If it does,\r\n * then the loop continues, if not, it stops. The third value is a function which takes the\r\n * previously defined value and modifies it in some way on each iteration. Note how these three parameters\r\n * are direct equivalents of three expressions in a traditional for loop: the first expression\r\n * initializes some state (for example, a numeric index), the second tests if the loop can perform the next\r\n * iteration (for example, if the index is lower than 10) and the third states how the defined value\r\n * will be modified on every step (for example, the index will be incremented by one).\r\n *\r\n * Return value of a `generate` operator is an Observable that on each loop iteration\r\n * emits a value. First of all, the condition function is ran. If it returns true, then the Observable\r\n * emits the currently stored value (initial value at the first iteration) and finally updates\r\n * that value with iterate function. If at some point the condition returns false, then the Observable\r\n * completes at that moment.\r\n *\r\n * Optionally you can pass a fourth parameter to `generate` - a result selector function which allows you\r\n * to immediately map the value that would normally be emitted by an Observable.\r\n *\r\n * If you find three anonymous functions in `generate` call hard to read, you can provide\r\n * a single object to the operator instead where the object has the properties: `initialState`,\r\n * `condition`, `iterate` and `resultSelector`, which should have respective values that you\r\n * would normally pass to `generate`. `resultSelector` is still optional, but that form\r\n * of calling `generate` allows you to omit `condition` as well. If you omit it, that means\r\n * condition always holds, or in other words the resulting Observable will never complete.\r\n *\r\n * Both forms of `generate` can optionally accept a scheduler. In case of a multi-parameter call,\r\n * scheduler simply comes as a last argument (no matter if there is a `resultSelector`\r\n * function or not). In case of a single-parameter call, you can provide it as a\r\n * `scheduler` property on the object passed to the operator. In both cases, a scheduler decides when\r\n * the next iteration of the loop will happen and therefore when the next value will be emitted\r\n * by the Observable. For example, to ensure that each value is pushed to the Observer\r\n * on a separate task in the event loop, you could use the `async` scheduler. Note that\r\n * by default (when no scheduler is passed) values are simply emitted synchronously.\r\n *\r\n *\r\n * ## Examples\r\n *\r\n * Use with condition and iterate functions\r\n *\r\n * ```ts\r\n * import { generate } from 'rxjs';\r\n *\r\n * const result = generate(0, x => x < 3, x => x + 1);\r\n *\r\n * result.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!')\r\n * });\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1\r\n * // 2\r\n * // 'Complete!'\r\n * ```\r\n *\r\n * Use with condition, iterate and resultSelector functions\r\n *\r\n * ```ts\r\n * import { generate } from 'rxjs';\r\n *\r\n * const result = generate(0, x => x < 3, x => x + 1, x => x * 1000);\r\n *\r\n * result.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!')\r\n * });\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1000\r\n * // 2000\r\n * // 'Complete!'\r\n * ```\r\n *\r\n * Use with options object\r\n *\r\n * ```ts\r\n * import { generate } from 'rxjs';\r\n *\r\n * const result = generate({\r\n *   initialState: 0,\r\n *   condition(value) { return value < 3; },\r\n *   iterate(value) { return value + 1; },\r\n *   resultSelector(value) { return value * 1000; }\r\n * });\r\n *\r\n * result.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!')\r\n * });\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1000\r\n * // 2000\r\n * // 'Complete!'\r\n * ```\r\n *\r\n * Use options object without condition function\r\n *\r\n * ```ts\r\n * import { generate } from 'rxjs';\r\n *\r\n * const result = generate({\r\n *   initialState: 0,\r\n *   iterate(value) { return value + 1; },\r\n *   resultSelector(value) { return value * 1000; }\r\n * });\r\n *\r\n * result.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!') // This will never run\r\n * });\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1000\r\n * // 2000\r\n * // 3000\r\n * // ...and never stops.\r\n * ```\r\n *\r\n * @see {@link from}\r\n *\r\n * @param initialState Initial state.\r\n * @param condition Condition to terminate generation (upon returning false).\r\n * @param iterate Iteration step function.\r\n * @param scheduler A {@link Scheduler} on which to run the generator loop. If not\r\n * provided, defaults to emitting immediately.\r\n * @return The generated sequence.\r\n * @deprecated Instead of passing separate arguments, use the options argument.\r\n * Signatures taking separate arguments will be removed in v8.\r\n */\r\nexport function generate<S>(\r\n  initialState: S,\r\n  condition: ConditionFunc<S>,\r\n  iterate: IterateFunc<S>,\r\n  scheduler?: SchedulerLike\r\n): Observable<S>;\r\n\r\n/**\r\n * Generates an observable sequence by running a state-driven loop\r\n * producing the sequence's elements, using the specified scheduler\r\n * to send out observer messages.\r\n * The overload accepts options object that might contain initial state, iterate,\r\n * condition and scheduler.\r\n *\r\n * ![](generate.png)\r\n *\r\n * ## Examples\r\n *\r\n * Use options object with condition function\r\n *\r\n * ```ts\r\n * import { generate } from 'rxjs';\r\n *\r\n * const result = generate({\r\n *   initialState: 0,\r\n *   condition: x => x < 3,\r\n *   iterate: x => x + 1\r\n * });\r\n *\r\n * result.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!')\r\n * });\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1\r\n * // 2\r\n * // 'Complete!'\r\n * ```\r\n *\r\n * @see {@link from}\r\n * @see {@link Observable}\r\n *\r\n * @param options Object that must contain initialState, iterate and might contain condition and scheduler.\r\n * @returns The generated sequence.\r\n */\r\nexport function generate<S>(options: GenerateBaseOptions<S>): Observable<S>;\r\n\r\n/**\r\n * Generates an observable sequence by running a state-driven loop\r\n * producing the sequence's elements, using the specified scheduler\r\n * to send out observer messages.\r\n * The overload accepts options object that might contain initial state, iterate,\r\n * condition, result selector and scheduler.\r\n *\r\n * ![](generate.png)\r\n *\r\n * ## Examples\r\n *\r\n * Use options object with condition and iterate function\r\n *\r\n * ```ts\r\n * import { generate } from 'rxjs';\r\n *\r\n * const result = generate({\r\n *   initialState: 0,\r\n *   condition: x => x < 3,\r\n *   iterate: x => x + 1,\r\n *   resultSelector: x => x\r\n * });\r\n *\r\n * result.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!')\r\n * });\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1\r\n * // 2\r\n * // 'Complete!'\r\n * ```\r\n *\r\n * @see {@link from}\r\n * @see {@link Observable}\r\n *\r\n * @param options Object that must contain initialState, iterate, resultSelector and might contain condition and scheduler.\r\n * @returns The generated sequence.\r\n */\r\nexport function generate<T, S>(options: GenerateOptions<T, S>): Observable<T>;\r\n\r\nexport function generate<T, S>(\r\n  initialStateOrOptions: S | GenerateOptions<T, S>,\r\n  condition?: ConditionFunc<S>,\r\n  iterate?: IterateFunc<S>,\r\n  resultSelectorOrScheduler?: ResultFunc<S, T> | SchedulerLike,\r\n  scheduler?: SchedulerLike\r\n): Observable<T> {\r\n  let resultSelector: ResultFunc<S, T>;\r\n  let initialState: S;\r\n\r\n  // TODO: Remove this as we move away from deprecated signatures\r\n  // and move towards a configuration object argument.\r\n  if (arguments.length === 1) {\r\n    // If we only have one argument, we can assume it is a configuration object.\r\n    // Note that folks not using TypeScript may trip over this.\r\n    ({\r\n      initialState,\r\n      condition,\r\n      iterate,\r\n      resultSelector = identity as ResultFunc<S, T>,\r\n      scheduler,\r\n    } = initialStateOrOptions as GenerateOptions<T, S>);\r\n  } else {\r\n    // Deprecated arguments path. Figure out what the user\r\n    // passed and set it here.\r\n    initialState = initialStateOrOptions as S;\r\n    if (!resultSelectorOrScheduler || isScheduler(resultSelectorOrScheduler)) {\r\n      resultSelector = identity as ResultFunc<S, T>;\r\n      scheduler = resultSelectorOrScheduler as SchedulerLike;\r\n    } else {\r\n      resultSelector = resultSelectorOrScheduler as ResultFunc<S, T>;\r\n    }\r\n  }\r\n\r\n  // The actual generator used to \"generate\" values.\r\n  function* gen() {\r\n    for (let state = initialState; !condition || condition(state); state = iterate!(state)) {\r\n      yield resultSelector(state);\r\n    }\r\n  }\r\n\r\n  // We use `defer` because we want to defer the creation of the iterator from the iterable.\r\n  return defer(\r\n    (scheduler\r\n      ? // If a scheduler was provided, use `scheduleIterable` to ensure that iteration/generation\r\n        // happens on the scheduler.\r\n        () => scheduleIterable(gen(), scheduler!)\r\n      : // Otherwise, if there's no scheduler, we can just use the generator function directly in\r\n        // `defer` and executing it will return the generator (which is iterable).\r\n        gen) as () => ObservableInput<T>\r\n  );\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { defer } from './defer';\r\nimport { ObservableInput } from '../types';\r\n\r\n/**\r\n * Checks a boolean at subscription time, and chooses between one of two observable sources\r\n *\r\n * `iif` expects a function that returns a boolean (the `condition` function), and two sources,\r\n * the `trueResult` and the `falseResult`, and returns an Observable.\r\n *\r\n * At the moment of subscription, the `condition` function is called. If the result is `true`, the\r\n * subscription will be to the source passed as the `trueResult`, otherwise, the subscription will be\r\n * to the source passed as the `falseResult`.\r\n *\r\n * If you need to check more than two options to choose between more than one observable, have a look at the {@link defer} creation method.\r\n *\r\n * ## Examples\r\n *\r\n * Change at runtime which Observable will be subscribed\r\n *\r\n * ```ts\r\n * import { iif, of } from 'rxjs';\r\n *\r\n * let subscribeToFirst;\r\n * const firstOrSecond = iif(\r\n *   () => subscribeToFirst,\r\n *   of('first'),\r\n *   of('second')\r\n * );\r\n *\r\n * subscribeToFirst = true;\r\n * firstOrSecond.subscribe(value => console.log(value));\r\n *\r\n * // Logs:\r\n * // 'first'\r\n *\r\n * subscribeToFirst = false;\r\n * firstOrSecond.subscribe(value => console.log(value));\r\n *\r\n * // Logs:\r\n * // 'second'\r\n * ```\r\n *\r\n * Control access to an Observable\r\n *\r\n * ```ts\r\n * import { iif, of, EMPTY } from 'rxjs';\r\n *\r\n * let accessGranted;\r\n * const observableIfYouHaveAccess = iif(\r\n *   () => accessGranted,\r\n *   of('It seems you have an access...'),\r\n *   EMPTY\r\n * );\r\n *\r\n * accessGranted = true;\r\n * observableIfYouHaveAccess.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('The end')\r\n * });\r\n *\r\n * // Logs:\r\n * // 'It seems you have an access...'\r\n * // 'The end'\r\n *\r\n * accessGranted = false;\r\n * observableIfYouHaveAccess.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('The end')\r\n * });\r\n *\r\n * // Logs:\r\n * // 'The end'\r\n * ```\r\n *\r\n * @see {@link defer}\r\n *\r\n * @param condition Condition which Observable should be chosen.\r\n * @param trueResult An Observable that will be subscribed if condition is true.\r\n * @param falseResult An Observable that will be subscribed if condition is false.\r\n * @return An observable that proxies to `trueResult` or `falseResult`, depending on the result of the `condition` function.\r\n */\r\nexport function iif<T, F>(condition: () => boolean, trueResult: ObservableInput<T>, falseResult: ObservableInput<F>): Observable<T | F> {\r\n  return defer(() => (condition() ? trueResult : falseResult));\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { SchedulerLike } from '../types';\r\nimport { async as asyncScheduler } from '../scheduler/async';\r\nimport { isScheduler } from '../util/isScheduler';\r\nimport { isValidDate } from '../util/isDate';\r\n\r\n/**\r\n * Creates an observable that will wait for a specified time period, or exact date, before\r\n * emitting the number 0.\r\n *\r\n * <span class=\"informal\">Used to emit a notification after a delay.</span>\r\n *\r\n * This observable is useful for creating delays in code, or racing against other values\r\n * for ad-hoc timeouts.\r\n *\r\n * The `delay` is specified by default in milliseconds, however providing a custom scheduler could\r\n * create a different behavior.\r\n *\r\n * ## Examples\r\n *\r\n * Wait 3 seconds and start another observable\r\n *\r\n * You might want to use `timer` to delay subscription to an\r\n * observable by a set amount of time. Here we use a timer with\r\n * {@link concatMapTo} or {@link concatMap} in order to wait\r\n * a few seconds and start a subscription to a source.\r\n *\r\n * ```ts\r\n * import { of, timer, concatMap } from 'rxjs';\r\n *\r\n * // This could be any observable\r\n * const source = of(1, 2, 3);\r\n *\r\n * timer(3000)\r\n *   .pipe(concatMap(() => source))\r\n *   .subscribe(console.log);\r\n * ```\r\n *\r\n * Take all values until the start of the next minute\r\n *\r\n * Using a `Date` as the trigger for the first emission, you can\r\n * do things like wait until midnight to fire an event, or in this case,\r\n * wait until a new minute starts (chosen so the example wouldn't take\r\n * too long to run) in order to stop watching a stream. Leveraging\r\n * {@link takeUntil}.\r\n *\r\n * ```ts\r\n * import { interval, takeUntil, timer } from 'rxjs';\r\n *\r\n * // Build a Date object that marks the\r\n * // next minute.\r\n * const currentDate = new Date();\r\n * const startOfNextMinute = new Date(\r\n *   currentDate.getFullYear(),\r\n *   currentDate.getMonth(),\r\n *   currentDate.getDate(),\r\n *   currentDate.getHours(),\r\n *   currentDate.getMinutes() + 1\r\n * );\r\n *\r\n * // This could be any observable stream\r\n * const source = interval(1000);\r\n *\r\n * const result = source.pipe(\r\n *   takeUntil(timer(startOfNextMinute))\r\n * );\r\n *\r\n * result.subscribe(console.log);\r\n * ```\r\n *\r\n * ### Known Limitations\r\n *\r\n * - The {@link asyncScheduler} uses `setTimeout` which has limitations for how far in the future it can be scheduled.\r\n *\r\n * - If a `scheduler` is provided that returns a timestamp other than an epoch from `now()`, and\r\n * a `Date` object is passed to the `dueTime` argument, the calculation for when the first emission\r\n * should occur will be incorrect. In this case, it would be best to do your own calculations\r\n * ahead of time, and pass a `number` in as the `dueTime`.\r\n *\r\n * @param due If a `number`, the amount of time in milliseconds to wait before emitting.\r\n * If a `Date`, the exact time at which to emit.\r\n * @param scheduler The scheduler to use to schedule the delay. Defaults to {@link asyncScheduler}.\r\n */\r\nexport function timer(due: number | Date, scheduler?: SchedulerLike): Observable<0>;\r\n\r\n/**\r\n * Creates an observable that starts an interval after a specified delay, emitting incrementing numbers -- starting at `0` --\r\n * on each interval after words.\r\n *\r\n * The `delay` and `intervalDuration` are specified by default in milliseconds, however providing a custom scheduler could\r\n * create a different behavior.\r\n *\r\n * ## Example\r\n *\r\n * ### Start an interval that starts right away\r\n *\r\n * Since {@link interval} waits for the passed delay before starting,\r\n * sometimes that's not ideal. You may want to start an interval immediately.\r\n * `timer` works well for this. Here we have both side-by-side so you can\r\n * see them in comparison.\r\n *\r\n * Note that this observable will never complete.\r\n *\r\n * ```ts\r\n * import { timer, interval } from 'rxjs';\r\n *\r\n * timer(0, 1000).subscribe(n => console.log('timer', n));\r\n * interval(1000).subscribe(n => console.log('interval', n));\r\n * ```\r\n *\r\n * ### Known Limitations\r\n *\r\n * - The {@link asyncScheduler} uses `setTimeout` which has limitations for how far in the future it can be scheduled.\r\n *\r\n * - If a `scheduler` is provided that returns a timestamp other than an epoch from `now()`, and\r\n * a `Date` object is passed to the `dueTime` argument, the calculation for when the first emission\r\n * should occur will be incorrect. In this case, it would be best to do your own calculations\r\n * ahead of time, and pass a `number` in as the `startDue`.\r\n * @param startDue If a `number`, is the time to wait before starting the interval.\r\n * If a `Date`, is the exact time at which to start the interval.\r\n * @param intervalDuration The delay between each value emitted in the interval. Passing a\r\n * negative number here will result in immediate completion after the first value is emitted, as though\r\n * no `intervalDuration` was passed at all.\r\n * @param scheduler The scheduler to use to schedule the delay. Defaults to {@link asyncScheduler}.\r\n */\r\nexport function timer(startDue: number | Date, intervalDuration: number, scheduler?: SchedulerLike): Observable<number>;\r\n\r\n/**\r\n * @deprecated The signature allowing `undefined` to be passed for `intervalDuration` will be removed in v8. Use the `timer(dueTime, scheduler?)` signature instead.\r\n */\r\nexport function timer(dueTime: number | Date, unused: undefined, scheduler?: SchedulerLike): Observable<0>;\r\n\r\nexport function timer(\r\n  dueTime: number | Date = 0,\r\n  intervalOrScheduler?: number | SchedulerLike,\r\n  scheduler: SchedulerLike = asyncScheduler\r\n): Observable<number> {\r\n  // Since negative intervalDuration is treated as though no\r\n  // interval was specified at all, we start with a negative number.\r\n  let intervalDuration = -1;\r\n\r\n  if (intervalOrScheduler != null) {\r\n    // If we have a second argument, and it's a scheduler,\r\n    // override the scheduler we had defaulted. Otherwise,\r\n    // it must be an interval.\r\n    if (isScheduler(intervalOrScheduler)) {\r\n      scheduler = intervalOrScheduler;\r\n    } else {\r\n      // Note that this *could* be negative, in which case\r\n      // it's like not passing an intervalDuration at all.\r\n      intervalDuration = intervalOrScheduler;\r\n    }\r\n  }\r\n\r\n  return new Observable((subscriber) => {\r\n    // If a valid date is passed, calculate how long to wait before\r\n    // executing the first value... otherwise, if it's a number just schedule\r\n    // that many milliseconds (or scheduler-specified unit size) in the future.\r\n    let due = isValidDate(dueTime) ? +dueTime - scheduler!.now() : dueTime;\r\n\r\n    if (due < 0) {\r\n      // Ensure we don't schedule in the future.\r\n      due = 0;\r\n    }\r\n\r\n    // The incrementing value we emit.\r\n    let n = 0;\r\n\r\n    // Start the timer.\r\n    return scheduler.schedule(function () {\r\n      if (!subscriber.closed) {\r\n        // Emit the next value and increment.\r\n        subscriber.next(n++);\r\n\r\n        if (0 <= intervalDuration) {\r\n          // If we have a interval after the initial timer,\r\n          // reschedule with the period.\r\n          this.schedule(undefined, intervalDuration);\r\n        } else {\r\n          // We didn't have an interval. So just complete.\r\n          subscriber.complete();\r\n        }\r\n      }\r\n    }, due);\r\n  });\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { asyncScheduler } from '../scheduler/async';\r\nimport { SchedulerLike } from '../types';\r\nimport { timer } from './timer';\r\n\r\n/**\r\n * Creates an Observable that emits sequential numbers every specified\r\n * interval of time, on a specified {@link SchedulerLike}.\r\n *\r\n * <span class=\"informal\">Emits incremental numbers periodically in time.</span>\r\n *\r\n * ![](interval.png)\r\n *\r\n * `interval` returns an Observable that emits an infinite sequence of\r\n * ascending integers, with a constant interval of time of your choosing\r\n * between those emissions. The first emission is not sent immediately, but\r\n * only after the first period has passed. By default, this operator uses the\r\n * `async` {@link SchedulerLike} to provide a notion of time, but you may pass any\r\n * {@link SchedulerLike} to it.\r\n *\r\n * ## Example\r\n *\r\n * Emits ascending numbers, one every second (1000ms) up to the number 3\r\n *\r\n * ```ts\r\n * import { interval, take } from 'rxjs';\r\n *\r\n * const numbers = interval(1000);\r\n *\r\n * const takeFourNumbers = numbers.pipe(take(4));\r\n *\r\n * takeFourNumbers.subscribe(x => console.log('Next: ', x));\r\n *\r\n * // Logs:\r\n * // Next: 0\r\n * // Next: 1\r\n * // Next: 2\r\n * // Next: 3\r\n * ```\r\n *\r\n * @see {@link timer}\r\n * @see {@link delay}\r\n *\r\n * @param period The interval size in milliseconds (by default) or the time unit determined\r\n * by the scheduler's clock.\r\n * @param scheduler The {@link SchedulerLike} to use for scheduling the emission of values,\r\n * and providing a notion of \"time\".\r\n * @return An Observable that emits a sequential number each time interval.\r\n */\r\nexport function interval(period = 0, scheduler: SchedulerLike = asyncScheduler): Observable<number> {\r\n  if (period < 0) {\r\n    // We cannot schedule an interval in the past.\r\n    period = 0;\r\n  }\r\n\r\n  return timer(period, period, scheduler);\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { ObservableInput, ObservableInputTuple, SchedulerLike } from '../types';\r\nimport { mergeAll } from '../operators/mergeAll';\r\nimport { innerFrom } from './innerFrom';\r\nimport { EMPTY } from './empty';\r\nimport { popNumber, popScheduler } from '../util/args';\r\nimport { from } from './from';\r\n\r\nexport function merge<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\r\nexport function merge<A extends readonly unknown[]>(...sourcesAndConcurrency: [...ObservableInputTuple<A>, number?]): Observable<A[number]>;\r\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\r\nexport function merge<A extends readonly unknown[]>(\r\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike?]\r\n): Observable<A[number]>;\r\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\r\nexport function merge<A extends readonly unknown[]>(\r\n  ...sourcesAndConcurrencyAndScheduler: [...ObservableInputTuple<A>, number?, SchedulerLike?]\r\n): Observable<A[number]>;\r\n\r\n/**\r\n * Creates an output Observable which concurrently emits all values from every\r\n * given input Observable.\r\n *\r\n * <span class=\"informal\">Flattens multiple Observables together by blending\r\n * their values into one Observable.</span>\r\n *\r\n * ![](merge.png)\r\n *\r\n * `merge` subscribes to each given input Observable (as arguments), and simply\r\n * forwards (without doing any transformation) all the values from all the input\r\n * Observables to the output Observable. The output Observable only completes\r\n * once all input Observables have completed. Any error delivered by an input\r\n * Observable will be immediately emitted on the output Observable.\r\n *\r\n * ## Examples\r\n *\r\n * Merge together two Observables: 1s interval and clicks\r\n *\r\n * ```ts\r\n * import { merge, fromEvent, interval } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const timer = interval(1000);\r\n * const clicksOrTimer = merge(clicks, timer);\r\n * clicksOrTimer.subscribe(x => console.log(x));\r\n *\r\n * // Results in the following:\r\n * // timer will emit ascending values, one every second(1000ms) to console\r\n * // clicks logs MouseEvents to console every time the \"document\" is clicked\r\n * // Since the two streams are merged you see these happening\r\n * // as they occur.\r\n * ```\r\n *\r\n * Merge together 3 Observables, but run only 2 concurrently\r\n *\r\n * ```ts\r\n * import { interval, take, merge } from 'rxjs';\r\n *\r\n * const timer1 = interval(1000).pipe(take(10));\r\n * const timer2 = interval(2000).pipe(take(6));\r\n * const timer3 = interval(500).pipe(take(10));\r\n *\r\n * const concurrent = 2; // the argument\r\n * const merged = merge(timer1, timer2, timer3, concurrent);\r\n * merged.subscribe(x => console.log(x));\r\n *\r\n * // Results in the following:\r\n * // - First timer1 and timer2 will run concurrently\r\n * // - timer1 will emit a value every 1000ms for 10 iterations\r\n * // - timer2 will emit a value every 2000ms for 6 iterations\r\n * // - after timer1 hits its max iteration, timer2 will\r\n * //   continue, and timer3 will start to run concurrently with timer2\r\n * // - when timer2 hits its max iteration it terminates, and\r\n * //   timer3 will continue to emit a value every 500ms until it is complete\r\n * ```\r\n *\r\n * @see {@link mergeAll}\r\n * @see {@link mergeMap}\r\n * @see {@link mergeMapTo}\r\n * @see {@link mergeScan}\r\n *\r\n * @param args `ObservableInput`s to merge together. If the last parameter\r\n * is of type number, `merge` will use it to limit number of concurrently\r\n * subscribed `ObservableInput`s. If the last parameter is {@link SchedulerLike},\r\n * it will be used for scheduling the emission of values.\r\n * @return An Observable that emits items that are the result of every input Observable.\r\n */\r\nexport function merge(...args: (ObservableInput<unknown> | number | SchedulerLike)[]): Observable<unknown> {\r\n  const scheduler = popScheduler(args);\r\n  const concurrent = popNumber(args, Infinity);\r\n  const sources = args as ObservableInput<unknown>[];\r\n  return !sources.length\r\n    ? // No source provided\r\n      EMPTY\r\n    : sources.length === 1\r\n    ? // One source? Just return it.\r\n      innerFrom(sources[0])\r\n    : // Merge all sources\r\n      mergeAll(concurrent)(from(sources, scheduler));\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { noop } from '../util/noop';\r\n\r\n/**\r\n * An Observable that emits no items to the Observer and never completes.\r\n *\r\n * ![](never.png)\r\n *\r\n * A simple Observable that emits neither values nor errors nor the completion\r\n * notification. It can be used for testing purposes or for composing with other\r\n * Observables. Please note that by never emitting a complete notification, this\r\n * Observable keeps the subscription from being disposed automatically.\r\n * Subscriptions need to be manually disposed.\r\n *\r\n * ##  Example\r\n *\r\n * Emit the number 7, then never emit anything else (not even complete)\r\n *\r\n * ```ts\r\n * import { NEVER, startWith } from 'rxjs';\r\n *\r\n * const info = () => console.log('Will not be called');\r\n *\r\n * const result = NEVER.pipe(startWith(7));\r\n * result.subscribe({\r\n *   next: x => console.log(x),\r\n *   error: info,\r\n *   complete: info\r\n * });\r\n * ```\r\n *\r\n * @see {@link Observable}\r\n * @see {@link EMPTY}\r\n * @see {@link of}\r\n * @see {@link throwError}\r\n */\r\nexport const NEVER = new Observable<never>(noop);\r\n\r\n/**\r\n * @deprecated Replaced with the {@link NEVER} constant. Will be removed in v8.\r\n */\r\nexport function never() {\r\n  return NEVER;\r\n}\r\n", "const { isArray } = Array;\r\n\r\n/**\r\n * Used in operators and functions that accept either a list of arguments, or an array of arguments\r\n * as a single argument.\r\n */\r\nexport function argsOrArgArray<T>(args: (T | T[])[]): T[] {\r\n  return args.length === 1 && isArray(args[0]) ? args[0] : (args as T[]);\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { ObservableInputTuple } from '../types';\r\nimport { argsOrArgArray } from '../util/argsOrArgArray';\r\nimport { OperatorSubscriber } from '../operators/OperatorSubscriber';\r\nimport { noop } from '../util/noop';\r\nimport { innerFrom } from './innerFrom';\r\n\r\nexport function onErrorResumeNext<A extends readonly unknown[]>(sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\r\nexport function onErrorResumeNext<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\r\n\r\n/**\r\n * When any of the provided Observable emits a complete or an error notification, it immediately subscribes to the next one\r\n * that was passed.\r\n *\r\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\r\n *\r\n * ![](onErrorResumeNext.png)\r\n *\r\n * `onErrorResumeNext` will subscribe to each observable source it is provided, in order.\r\n * If the source it's subscribed to emits an error or completes, it will move to the next source\r\n * without error.\r\n *\r\n * If `onErrorResumeNext` is provided no arguments, or a single, empty array, it will return {@link EMPTY}.\r\n *\r\n * `onErrorResumeNext` is basically {@link concat}, only it will continue, even if one of its\r\n * sources emits an error.\r\n *\r\n * Note that there is no way to handle any errors thrown by sources via the result of\r\n * `onErrorResumeNext`. If you want to handle errors thrown in any given source, you can\r\n * always use the {@link catchError} operator on them before passing them into `onErrorResumeNext`.\r\n *\r\n * ## Example\r\n *\r\n * Subscribe to the next Observable after map fails\r\n *\r\n * ```ts\r\n * import { onErrorResumeNext, of, map } from 'rxjs';\r\n *\r\n * onErrorResumeNext(\r\n *   of(1, 2, 3, 0).pipe(\r\n *     map(x => {\r\n *       if (x === 0) {\r\n *         throw Error();\r\n *       }\r\n *       return 10 / x;\r\n *     })\r\n *   ),\r\n *   of(1, 2, 3)\r\n * )\r\n * .subscribe({\r\n *   next: value => console.log(value),\r\n *   error: err => console.log(err),     // Will never be called.\r\n *   complete: () => console.log('done')\r\n * });\r\n *\r\n * // Logs:\r\n * // 10\r\n * // 5\r\n * // 3.3333333333333335\r\n * // 1\r\n * // 2\r\n * // 3\r\n * // 'done'\r\n * ```\r\n *\r\n * @see {@link concat}\r\n * @see {@link catchError}\r\n *\r\n * @param sources `ObservableInput`s passed either directly or as an array.\r\n * @return An Observable that concatenates all sources, one after the other,\r\n * ignoring all errors, such that any error causes it to move on to the next source.\r\n */\r\nexport function onErrorResumeNext<A extends readonly unknown[]>(\r\n  ...sources: [[...ObservableInputTuple<A>]] | [...ObservableInputTuple<A>]\r\n): Observable<A[number]> {\r\n  const nextSources: ObservableInputTuple<A> = argsOrArgArray(sources) as any;\r\n\r\n  return new Observable((subscriber) => {\r\n    let sourceIndex = 0;\r\n    const subscribeNext = () => {\r\n      if (sourceIndex < nextSources.length) {\r\n        let nextSource: Observable<A[number]>;\r\n        try {\r\n          nextSource = innerFrom(nextSources[sourceIndex++]);\r\n        } catch (err) {\r\n          subscribeNext();\r\n          return;\r\n        }\r\n        const innerSubscriber = new OperatorSubscriber(subscriber, undefined, noop, noop);\r\n        nextSource.subscribe(innerSubscriber);\r\n        innerSubscriber.add(subscribeNext);\r\n      } else {\r\n        subscriber.complete();\r\n      }\r\n    };\r\n    subscribeNext();\r\n  });\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { SchedulerLike } from '../types';\r\nimport { from } from './from';\r\n\r\n/**\r\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\r\n */\r\nexport function pairs<T>(arr: readonly T[], scheduler?: SchedulerLike): Observable<[string, T]>;\r\n/**\r\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\r\n */\r\nexport function pairs<O extends Record<string, unknown>>(obj: O, scheduler?: SchedulerLike): Observable<[keyof O, O[keyof O]]>;\r\n/**\r\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\r\n */\r\nexport function pairs<T>(iterable: Iterable<T>, scheduler?: SchedulerLike): Observable<[string, T]>;\r\n/**\r\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\r\n */\r\nexport function pairs(\r\n  n: number | bigint | boolean | ((...args: any[]) => any) | symbol,\r\n  scheduler?: SchedulerLike\r\n): Observable<[never, never]>;\r\n\r\n/**\r\n * Convert an object into an Observable of `[key, value]` pairs.\r\n *\r\n * <span class=\"informal\">Turn entries of an object into a stream.</span>\r\n *\r\n * ![](pairs.png)\r\n *\r\n * `pairs` takes an arbitrary object and returns an Observable that emits arrays. Each\r\n * emitted array has exactly two elements - the first is a key from the object\r\n * and the second is a value corresponding to that key. Keys are extracted from\r\n * an object via `Object.keys` function, which means that they will be only\r\n * enumerable keys that are present on an object directly - not ones inherited\r\n * via prototype chain.\r\n *\r\n * By default, these arrays are emitted synchronously. To change that you can\r\n * pass a {@link SchedulerLike} as a second argument to `pairs`.\r\n *\r\n * ## Example\r\n *\r\n * Converts an object to an Observable\r\n *\r\n * ```ts\r\n * import { pairs } from 'rxjs';\r\n *\r\n * const obj = {\r\n *   foo: 42,\r\n *   bar: 56,\r\n *   baz: 78\r\n * };\r\n *\r\n * pairs(obj).subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!')\r\n * });\r\n *\r\n * // Logs:\r\n * // ['foo', 42]\r\n * // ['bar', 56]\r\n * // ['baz', 78]\r\n * // 'Complete!'\r\n * ```\r\n *\r\n * ### Object.entries required\r\n *\r\n * In IE, you will need to polyfill `Object.entries` in order to use this.\r\n * [MDN has a polyfill here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)\r\n *\r\n * @param obj The object to inspect and turn into an Observable sequence.\r\n * @param scheduler An optional IScheduler to schedule when resulting\r\n * Observable will emit values.\r\n * @returns An observable sequence of [key, value] pairs from the object.\r\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\r\n */\r\nexport function pairs(obj: any, scheduler?: SchedulerLike) {\r\n  return from(Object.entries(obj), scheduler as any);\r\n}\r\n", "export function not<T>(pred: (value: T, index: number) => boolean, thisArg: any): (value: T, index: number) => boolean {\r\n  return (value: T, index: number) => !pred.call(thisArg, value, index); \r\n}", "import { OperatorFunction, MonoTypeOperatorFunction, TruthyTypesOf } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\r\nexport function filter<T, S extends T, A>(predicate: (this: A, value: T, index: number) => value is S, thisArg: A): OperatorFunction<T, S>;\r\nexport function filter<T, S extends T>(predicate: (value: T, index: number) => value is S): OperatorFunction<T, S>;\r\nexport function filter<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\r\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\r\nexport function filter<T, A>(predicate: (this: A, value: T, index: number) => boolean, thisArg: A): MonoTypeOperatorFunction<T>;\r\nexport function filter<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * Filter items emitted by the source Observable by only emitting those that\r\n * satisfy a specified predicate.\r\n *\r\n * <span class=\"informal\">Like\r\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\r\n * it only emits a value from the source if it passes a criterion function.</span>\r\n *\r\n * ![](filter.png)\r\n *\r\n * Similar to the well-known `Array.prototype.filter` method, this operator\r\n * takes values from the source Observable, passes them through a `predicate`\r\n * function and only emits those values that yielded `true`.\r\n *\r\n * ## Example\r\n *\r\n * Emit only click events whose target was a DIV element\r\n *\r\n * ```ts\r\n * import { fromEvent, filter } from 'rxjs';\r\n *\r\n * const div = document.createElement('div');\r\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\r\n * document.body.appendChild(div);\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const clicksOnDivs = clicks.pipe(filter(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\r\n * clicksOnDivs.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link distinct}\r\n * @see {@link distinctUntilChanged}\r\n * @see {@link distinctUntilKeyChanged}\r\n * @see {@link ignoreElements}\r\n * @see {@link partition}\r\n * @see {@link skip}\r\n *\r\n * @param predicate A function that\r\n * evaluates each value emitted by the source Observable. If it returns `true`,\r\n * the value is emitted, if `false` the value is not passed to the output\r\n * Observable. The `index` parameter is the number `i` for the i-th source\r\n * emission that has happened since the subscription, starting from the number\r\n * `0`.\r\n * @param thisArg An optional argument to determine the value of `this`\r\n * in the `predicate` function.\r\n * @return A function that returns an Observable that emits items from the\r\n * source Observable that satisfy the specified `predicate`.\r\n */\r\nexport function filter<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    // An index passed to our predicate function on each call.\r\n    let index = 0;\r\n\r\n    // Subscribe to the source, all errors and completions are\r\n    // forwarded to the consumer.\r\n    source.subscribe(\r\n      // Call the predicate with the appropriate `this` context,\r\n      // if the predicate returns `true`, then send the value\r\n      // to the consumer.\r\n      createOperatorSubscriber(subscriber, (value) => predicate.call(thisArg, value, index++) && subscriber.next(value))\r\n    );\r\n  });\r\n}\r\n", "import { not } from '../util/not';\r\nimport { filter } from '../operators/filter';\r\nimport { ObservableInput } from '../types';\r\nimport { Observable } from '../Observable';\r\nimport { innerFrom } from './innerFrom';\r\n\r\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\r\nexport function partition<T, U extends T, A>(\r\n  source: ObservableInput<T>,\r\n  predicate: (this: A, value: T, index: number) => value is U,\r\n  thisArg: A\r\n): [Observable<U>, Observable<Exclude<T, U>>];\r\nexport function partition<T, U extends T>(\r\n  source: ObservableInput<T>,\r\n  predicate: (value: T, index: number) => value is U\r\n): [Observable<U>, Observable<Exclude<T, U>>];\r\n\r\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\r\nexport function partition<T, A>(\r\n  source: ObservableInput<T>,\r\n  predicate: (this: A, value: T, index: number) => boolean,\r\n  thisArg: A\r\n): [Observable<T>, Observable<T>];\r\nexport function partition<T>(source: ObservableInput<T>, predicate: (value: T, index: number) => boolean): [Observable<T>, Observable<T>];\r\n\r\n/**\r\n * Splits the source Observable into two, one with values that satisfy a\r\n * predicate, and another with values that don't satisfy the predicate.\r\n *\r\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\r\n * one like the output of {@link filter}, and the other with values that did not\r\n * pass the condition.</span>\r\n *\r\n * ![](partition.png)\r\n *\r\n * `partition` outputs an array with two Observables that partition the values\r\n * from the source Observable through the given `predicate` function. The first\r\n * Observable in that array emits source values for which the predicate argument\r\n * returns true. The second Observable emits source values for which the\r\n * predicate returns false. The first behaves like {@link filter} and the second\r\n * behaves like {@link filter} with the predicate negated.\r\n *\r\n * ## Example\r\n *\r\n * Partition a set of numbers into odds and evens observables\r\n *\r\n * ```ts\r\n * import { of, partition } from 'rxjs';\r\n *\r\n * const observableValues = of(1, 2, 3, 4, 5, 6);\r\n * const [evens$, odds$] = partition(observableValues, value => value % 2 === 0);\r\n *\r\n * odds$.subscribe(x => console.log('odds', x));\r\n * evens$.subscribe(x => console.log('evens', x));\r\n *\r\n * // Logs:\r\n * // odds 1\r\n * // odds 3\r\n * // odds 5\r\n * // evens 2\r\n * // evens 4\r\n * // evens 6\r\n * ```\r\n *\r\n * @see {@link filter}\r\n *\r\n * @param source The source `ObservableInput` that will be split into a tuple of\r\n * two Observable elements.\r\n * @param predicate A function that evaluates each value emitted by the source\r\n * Observable. If it returns `true`, the value is emitted on the first Observable\r\n * in the returned array, if `false` the value is emitted on the second Observable\r\n * in the array. The `index` parameter is the number `i` for the i-th source\r\n * emission that has happened since the subscription, starting from the number `0`.\r\n * @param thisArg An optional argument to determine the value of `this` in the\r\n * `predicate` function.\r\n * @return An array with two Observables: one with values that passed the\r\n * predicate, and another with values that did not pass the predicate.\r\n */\r\nexport function partition<T>(\r\n  source: ObservableInput<T>,\r\n  predicate: (this: any, value: T, index: number) => boolean,\r\n  thisArg?: any\r\n): [Observable<T>, Observable<T>] {\r\n  return [filter(predicate, thisArg)(innerFrom(source)), filter(not(predicate, thisArg))(innerFrom(source))] as [\r\n    Observable<T>,\r\n    Observable<T>\r\n  ];\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { innerFrom } from './innerFrom';\r\nimport { Subscription } from '../Subscription';\r\nimport { ObservableInput, ObservableInputTuple } from '../types';\r\nimport { argsOrArgArray } from '../util/argsOrArgArray';\r\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\r\nimport { Subscriber } from '../Subscriber';\r\n\r\nexport function race<T extends readonly unknown[]>(inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\r\nexport function race<T extends readonly unknown[]>(...inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\r\n\r\n/**\r\n * Returns an observable that mirrors the first source observable to emit an item.\r\n *\r\n * ![](race.png)\r\n *\r\n * `race` returns an observable, that when subscribed to, subscribes to all source observables immediately.\r\n * As soon as one of the source observables emits a value, the result unsubscribes from the other sources.\r\n * The resulting observable will forward all notifications, including error and completion, from the \"winning\"\r\n * source observable.\r\n *\r\n * If one of the used source observable throws an errors before a first notification\r\n * the race operator will also throw an error, no matter if another source observable\r\n * could potentially win the race.\r\n *\r\n * `race` can be useful for selecting the response from the fastest network connection for\r\n * HTTP or WebSockets. `race` can also be useful for switching observable context based on user\r\n * input.\r\n *\r\n * ## Example\r\n *\r\n * Subscribes to the observable that was the first to start emitting.\r\n *\r\n * ```ts\r\n * import { interval, map, race } from 'rxjs';\r\n *\r\n * const obs1 = interval(7000).pipe(map(() => 'slow one'));\r\n * const obs2 = interval(3000).pipe(map(() => 'fast one'));\r\n * const obs3 = interval(5000).pipe(map(() => 'medium one'));\r\n *\r\n * race(obs1, obs2, obs3)\r\n *   .subscribe(winner => console.log(winner));\r\n *\r\n * // Outputs\r\n * // a series of 'fast one'\r\n * ```\r\n *\r\n * @param sources Used to race for which `ObservableInput` emits first.\r\n * @return An Observable that mirrors the output of the first Observable to emit an item.\r\n */\r\nexport function race<T>(...sources: (ObservableInput<T> | ObservableInput<T>[])[]): Observable<any> {\r\n  sources = argsOrArgArray(sources);\r\n  // If only one source was passed, just return it. Otherwise return the race.\r\n  return sources.length === 1 ? innerFrom(sources[0] as ObservableInput<T>) : new Observable<T>(raceInit(sources as ObservableInput<T>[]));\r\n}\r\n\r\n/**\r\n * An observable initializer function for both the static version and the\r\n * operator version of race.\r\n * @param sources The sources to race\r\n */\r\nexport function raceInit<T>(sources: ObservableInput<T>[]) {\r\n  return (subscriber: Subscriber<T>) => {\r\n    let subscriptions: Subscription[] = [];\r\n\r\n    // Subscribe to all of the sources. Note that we are checking `subscriptions` here\r\n    // Is is an array of all actively \"racing\" subscriptions, and it is `null` after the\r\n    // race has been won. So, if we have racer that synchronously \"wins\", this loop will\r\n    // stop before it subscribes to any more.\r\n    for (let i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {\r\n      subscriptions.push(\r\n        innerFrom(sources[i] as ObservableInput<T>).subscribe(\r\n          createOperatorSubscriber(subscriber, (value) => {\r\n            if (subscriptions) {\r\n              // We're still racing, but we won! So unsubscribe\r\n              // all other subscriptions that we have, except this one.\r\n              for (let s = 0; s < subscriptions.length; s++) {\r\n                s !== i && subscriptions[s].unsubscribe();\r\n              }\r\n              subscriptions = null!;\r\n            }\r\n            subscriber.next(value);\r\n          })\r\n        )\r\n      );\r\n    }\r\n  };\r\n}\r\n", "import { SchedulerLike } from '../types';\r\nimport { Observable } from '../Observable';\r\nimport { EMPTY } from './empty';\r\n\r\nexport function range(start: number, count?: number): Observable<number>;\r\n\r\n/**\r\n * @deprecated The `scheduler` parameter will be removed in v8. Use `range(start, count).pipe(observeOn(scheduler))` instead. Details: Details: https://rxjs.dev/deprecations/scheduler-argument\r\n */\r\nexport function range(start: number, count: number | undefined, scheduler: SchedulerLike): Observable<number>;\r\n\r\n/**\r\n * Creates an Observable that emits a sequence of numbers within a specified\r\n * range.\r\n *\r\n * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\r\n *\r\n * ![](range.png)\r\n *\r\n * `range` operator emits a range of sequential integers, in order, where you\r\n * select the `start` of the range and its `length`. By default, uses no\r\n * {@link SchedulerLike} and just delivers the notifications synchronously, but may use\r\n * an optional {@link SchedulerLike} to regulate those deliveries.\r\n *\r\n * ## Example\r\n *\r\n * Produce a range of numbers\r\n *\r\n * ```ts\r\n * import { range } from 'rxjs';\r\n *\r\n * const numbers = range(1, 3);\r\n *\r\n * numbers.subscribe({\r\n *   next: value => console.log(value),\r\n *   complete: () => console.log('Complete!')\r\n * });\r\n *\r\n * // Logs:\r\n * // 1\r\n * // 2\r\n * // 3\r\n * // 'Complete!'\r\n * ```\r\n *\r\n * @see {@link timer}\r\n * @see {@link interval}\r\n *\r\n * @param start The value of the first integer in the sequence.\r\n * @param count The number of sequential integers to generate.\r\n * @param scheduler A {@link SchedulerLike} to use for scheduling the emissions\r\n * of the notifications.\r\n * @return An Observable of numbers that emits a finite range of sequential integers.\r\n */\r\nexport function range(start: number, count?: number, scheduler?: SchedulerLike): Observable<number> {\r\n  if (count == null) {\r\n    // If one argument was passed, it's the count, not the start.\r\n    count = start;\r\n    start = 0;\r\n  }\r\n\r\n  if (count <= 0) {\r\n    // No count? We're going nowhere. Return EMPTY.\r\n    return EMPTY;\r\n  }\r\n\r\n  // Where the range should stop.\r\n  const end = count + start;\r\n\r\n  return new Observable(\r\n    scheduler\r\n      ? // The deprecated scheduled path.\r\n        (subscriber) => {\r\n          let n = start;\r\n          return scheduler.schedule(function () {\r\n            if (n < end) {\r\n              subscriber.next(n++);\r\n              this.schedule();\r\n            } else {\r\n              subscriber.complete();\r\n            }\r\n          });\r\n        }\r\n      : // Standard synchronous range.\r\n        (subscriber) => {\r\n          let n = start;\r\n          while (n < end && !subscriber.closed) {\r\n            subscriber.next(n++);\r\n          }\r\n          subscriber.complete();\r\n        }\r\n  );\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { Unsubscribable, ObservableInput, ObservedValueOf } from '../types';\r\nimport { innerFrom } from './innerFrom';\r\nimport { EMPTY } from './empty';\r\n\r\n/**\r\n * Creates an Observable that uses a resource which will be disposed at the same time as the Observable.\r\n *\r\n * <span class=\"informal\">Use it when you catch yourself cleaning up after an Observable.</span>\r\n *\r\n * `using` is a factory operator, which accepts two functions. First function returns a disposable resource.\r\n * It can be an arbitrary object that implements `unsubscribe` method. Second function will be injected with\r\n * that object and should return an Observable. That Observable can use resource object during its execution.\r\n * Both functions passed to `using` will be called every time someone subscribes - neither an Observable nor\r\n * resource object will be shared in any way between subscriptions.\r\n *\r\n * When Observable returned by `using` is subscribed, Observable returned from the second function will be subscribed\r\n * as well. All its notifications (nexted values, completion and error events) will be emitted unchanged by the output\r\n * Observable. If however someone unsubscribes from the Observable or source Observable completes or errors by itself,\r\n * the `unsubscribe` method on resource object will be called. This can be used to do any necessary clean up, which\r\n * otherwise would have to be handled by hand. Note that complete or error notifications are not emitted when someone\r\n * cancels subscription to an Observable via `unsubscribe`, so `using` can be used as a hook, allowing you to make\r\n * sure that all resources which need to exist during an Observable execution will be disposed at appropriate time.\r\n *\r\n * @see {@link defer}\r\n *\r\n * @param resourceFactory A function which creates any resource object that implements `unsubscribe` method.\r\n * @param observableFactory A function which creates an Observable, that can use injected resource object.\r\n * @return An Observable that behaves the same as Observable returned by `observableFactory`, but\r\n * which - when completed, errored or unsubscribed - will also call `unsubscribe` on created resource object.\r\n */\r\nexport function using<T extends ObservableInput<any>>(\r\n  resourceFactory: () => Unsubscribable | void,\r\n  observableFactory: (resource: Unsubscribable | void) => T | void\r\n): Observable<ObservedValueOf<T>> {\r\n  return new Observable<ObservedValueOf<T>>((subscriber) => {\r\n    const resource = resourceFactory();\r\n    const result = observableFactory(resource);\r\n    const source = result ? innerFrom(result) : EMPTY;\r\n    source.subscribe(subscriber);\r\n    return () => {\r\n      // NOTE: Optional chaining did not work here.\r\n      // Related TS Issue: https://github.com/microsoft/TypeScript/issues/40818\r\n      if (resource) {\r\n        resource.unsubscribe();\r\n      }\r\n    };\r\n  });\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { ObservableInputTuple } from '../types';\r\nimport { innerFrom } from './innerFrom';\r\nimport { argsOrArgArray } from '../util/argsOrArgArray';\r\nimport { EMPTY } from './empty';\r\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\r\nimport { popResultSelector } from '../util/args';\r\n\r\nexport function zip<A extends readonly unknown[]>(sources: [...ObservableInputTuple<A>]): Observable<A>;\r\nexport function zip<A extends readonly unknown[], R>(\r\n  sources: [...ObservableInputTuple<A>],\r\n  resultSelector: (...values: A) => R\r\n): Observable<R>;\r\nexport function zip<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A>;\r\nexport function zip<A extends readonly unknown[], R>(\r\n  ...sourcesAndResultSelector: [...ObservableInputTuple<A>, (...values: A) => R]\r\n): Observable<R>;\r\n\r\n/**\r\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\r\n * of its input Observables.\r\n *\r\n * If the last parameter is a function, this function is used to compute the created value from the input values.\r\n * Otherwise, an array of the input values is returned.\r\n *\r\n * ## Example\r\n *\r\n * Combine age and name from different sources\r\n *\r\n * ```ts\r\n * import { of, zip, map } from 'rxjs';\r\n *\r\n * const age$ = of(27, 25, 29);\r\n * const name$ = of('Foo', 'Bar', 'Beer');\r\n * const isDev$ = of(true, true, false);\r\n *\r\n * zip(age$, name$, isDev$).pipe(\r\n *   map(([age, name, isDev]) => ({ age, name, isDev }))\r\n * )\r\n * .subscribe(x => console.log(x));\r\n *\r\n * // Outputs\r\n * // { age: 27, name: 'Foo', isDev: true }\r\n * // { age: 25, name: 'Bar', isDev: true }\r\n * // { age: 29, name: 'Beer', isDev: false }\r\n * ```\r\n *\r\n * @param args Any number of `ObservableInput`s provided either as an array or as an object\r\n * to combine with each other.\r\n * @return An Observable of array values of the values emitted at the same index from each\r\n * individual `ObservableInput`.\r\n */\r\nexport function zip(...args: unknown[]): Observable<unknown> {\r\n  const resultSelector = popResultSelector(args);\r\n\r\n  const sources = argsOrArgArray(args) as Observable<unknown>[];\r\n\r\n  return sources.length\r\n    ? new Observable<unknown[]>((subscriber) => {\r\n        // A collection of buffers of values from each source.\r\n        // Keyed by the same index with which the sources were passed in.\r\n        let buffers: unknown[][] = sources.map(() => []);\r\n\r\n        // An array of flags of whether or not the sources have completed.\r\n        // This is used to check to see if we should complete the result.\r\n        // Keyed by the same index with which the sources were passed in.\r\n        let completed = sources.map(() => false);\r\n\r\n        // When everything is done, release the arrays above.\r\n        subscriber.add(() => {\r\n          buffers = completed = null!;\r\n        });\r\n\r\n        // Loop over our sources and subscribe to each one. The index `i` is\r\n        // especially important here, because we use it in closures below to\r\n        // access the related buffers and completion properties\r\n        for (let sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {\r\n          innerFrom(sources[sourceIndex]).subscribe(\r\n            createOperatorSubscriber(\r\n              subscriber,\r\n              (value) => {\r\n                buffers[sourceIndex].push(value);\r\n                // if every buffer has at least one value in it, then we\r\n                // can shift out the oldest value from each buffer and emit\r\n                // them as an array.\r\n                if (buffers.every((buffer) => buffer.length)) {\r\n                  const result: any = buffers.map((buffer) => buffer.shift()!);\r\n                  // Emit the array. If theres' a result selector, use that.\r\n                  subscriber.next(resultSelector ? resultSelector(...result) : result);\r\n                  // If any one of the sources is both complete and has an empty buffer\r\n                  // then we complete the result. This is because we cannot possibly have\r\n                  // any more values to zip together.\r\n                  if (buffers.some((buffer, i) => !buffer.length && completed[i])) {\r\n                    subscriber.complete();\r\n                  }\r\n                }\r\n              },\r\n              () => {\r\n                // This source completed. Mark it as complete so we can check it later\r\n                // if we have to.\r\n                completed[sourceIndex] = true;\r\n                // But, if this complete source has nothing in its buffer, then we\r\n                // can complete the result, because we can't possibly have any more\r\n                // values from this to zip together with the other values.\r\n                !buffers[sourceIndex].length && subscriber.complete();\r\n              }\r\n            )\r\n          );\r\n        }\r\n\r\n        // When everything is done, release the arrays above.\r\n        return () => {\r\n          buffers = completed = null!;\r\n        };\r\n      })\r\n    : EMPTY;\r\n}\r\n", "import { Subscriber } from '../Subscriber';\r\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\r\n\r\nimport { operate } from '../util/lift';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Ignores source values for a duration determined by another Observable, then\r\n * emits the most recent value from the source Observable, then repeats this\r\n * process.\r\n *\r\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\r\n * duration is determined by a second Observable.</span>\r\n *\r\n * ![](audit.svg)\r\n *\r\n * `audit` is similar to `throttle`, but emits the last value from the silenced\r\n * time window, instead of the first value. `audit` emits the most recent value\r\n * from the source Observable on the output Observable as soon as its internal\r\n * timer becomes disabled, and ignores source values while the timer is enabled.\r\n * Initially, the timer is disabled. As soon as the first source value arrives,\r\n * the timer is enabled by calling the `durationSelector` function with the\r\n * source value, which returns the \"duration\" Observable. When the duration\r\n * Observable emits a value, the timer is disabled, then the most\r\n * recent source value is emitted on the output Observable, and this process\r\n * repeats for the next source value.\r\n *\r\n * ## Example\r\n *\r\n * Emit clicks at a rate of at most one click per second\r\n *\r\n * ```ts\r\n * import { fromEvent, audit, interval } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(audit(ev => interval(1000)));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link auditTime}\r\n * @see {@link debounce}\r\n * @see {@link delayWhen}\r\n * @see {@link sample}\r\n * @see {@link throttle}\r\n *\r\n * @param durationSelector A function\r\n * that receives a value from the source Observable, for computing the silencing\r\n * duration, returned as an Observable or a Promise.\r\n * @return A function that returns an Observable that performs rate-limiting of\r\n * emissions from the source Observable.\r\n */\r\nexport function audit<T>(durationSelector: (value: T) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    let hasValue = false;\r\n    let lastValue: T | null = null;\r\n    let durationSubscriber: Subscriber<any> | null = null;\r\n    let isComplete = false;\r\n\r\n    const endDuration = () => {\r\n      durationSubscriber?.unsubscribe();\r\n      durationSubscriber = null;\r\n      if (hasValue) {\r\n        hasValue = false;\r\n        const value = lastValue!;\r\n        lastValue = null;\r\n        subscriber.next(value);\r\n      }\r\n      isComplete && subscriber.complete();\r\n    };\r\n\r\n    const cleanupDuration = () => {\r\n      durationSubscriber = null;\r\n      isComplete && subscriber.complete();\r\n    };\r\n\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value) => {\r\n          hasValue = true;\r\n          lastValue = value;\r\n          if (!durationSubscriber) {\r\n            innerFrom(durationSelector(value)).subscribe(\r\n              (durationSubscriber = createOperatorSubscriber(subscriber, endDuration, cleanupDuration))\r\n            );\r\n          }\r\n        },\r\n        () => {\r\n          isComplete = true;\r\n          (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n", "import { asyncScheduler } from '../scheduler/async';\r\nimport { audit } from './audit';\r\nimport { timer } from '../observable/timer';\r\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\r\n\r\n/**\r\n * Ignores source values for `duration` milliseconds, then emits the most recent\r\n * value from the source Observable, then repeats this process.\r\n *\r\n * <span class=\"informal\">When it sees a source value, it ignores that plus\r\n * the next ones for `duration` milliseconds, and then it emits the most recent\r\n * value from the source.</span>\r\n *\r\n * ![](auditTime.png)\r\n *\r\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\r\n * silenced time window, instead of the first value. `auditTime` emits the most\r\n * recent value from the source Observable on the output Observable as soon as\r\n * its internal timer becomes disabled, and ignores source values while the\r\n * timer is enabled. Initially, the timer is disabled. As soon as the first\r\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\r\n * the time unit determined internally by the optional `scheduler`) has passed,\r\n * the timer is disabled, then the most recent source value is emitted on the\r\n * output Observable, and this process repeats for the next source value.\r\n * Optionally takes a {@link SchedulerLike} for managing timers.\r\n *\r\n * ## Example\r\n *\r\n * Emit clicks at a rate of at most one click per second\r\n *\r\n * ```ts\r\n * import { fromEvent, auditTime } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(auditTime(1000));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link audit}\r\n * @see {@link debounceTime}\r\n * @see {@link delay}\r\n * @see {@link sampleTime}\r\n * @see {@link throttleTime}\r\n *\r\n * @param duration Time to wait before emitting the most recent source value,\r\n * measured in milliseconds or the time unit determined internally by the\r\n * optional `scheduler`.\r\n * @param scheduler The {@link SchedulerLike} to use for managing the timers\r\n * that handle the rate-limiting behavior.\r\n * @return A function that returns an Observable that performs rate-limiting of\r\n * emissions from the source Observable.\r\n */\r\nexport function auditTime<T>(duration: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\r\n  return audit(() => timer(duration, scheduler));\r\n}\r\n", "import { OperatorFunction, ObservableInput } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { noop } from '../util/noop';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { innerFrom } from '../observable/innerFrom';\r\n\r\n/**\r\n * Buffers the source Observable values until `closingNotifier` emits.\r\n *\r\n * <span class=\"informal\">Collects values from the past as an array, and emits\r\n * that array only when another Observable emits.</span>\r\n *\r\n * ![](buffer.png)\r\n *\r\n * Buffers the incoming Observable values until the given `closingNotifier`\r\n * `ObservableInput` (that internally gets converted to an Observable)\r\n * emits a value, at which point it emits the buffer on the output\r\n * Observable and starts a new buffer internally, awaiting the next time\r\n * `closingNotifier` emits.\r\n *\r\n * ## Example\r\n *\r\n * On every click, emit array of most recent interval events\r\n *\r\n * ```ts\r\n * import { fromEvent, interval, buffer } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const intervalEvents = interval(1000);\r\n * const buffered = intervalEvents.pipe(buffer(clicks));\r\n * buffered.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link bufferCount}\r\n * @see {@link bufferTime}\r\n * @see {@link bufferToggle}\r\n * @see {@link bufferWhen}\r\n * @see {@link window}\r\n *\r\n * @param closingNotifier An `ObservableInput` that signals the\r\n * buffer to be emitted on the output Observable.\r\n * @return A function that returns an Observable of buffers, which are arrays\r\n * of values.\r\n */\r\nexport function buffer<T>(closingNotifier: ObservableInput<any>): OperatorFunction<T, T[]> {\r\n  return operate((source, subscriber) => {\r\n    // The current buffered values.\r\n    let currentBuffer: T[] = [];\r\n\r\n    // Subscribe to our source.\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value) => currentBuffer.push(value),\r\n        () => {\r\n          subscriber.next(currentBuffer);\r\n          subscriber.complete();\r\n        }\r\n      )\r\n    );\r\n\r\n    // Subscribe to the closing notifier.\r\n    innerFrom(closingNotifier).subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        () => {\r\n          // Start a new buffer and emit the previous one.\r\n          const b = currentBuffer;\r\n          currentBuffer = [];\r\n          subscriber.next(b);\r\n        },\r\n        noop\r\n      )\r\n    );\r\n\r\n    return () => {\r\n      // Ensure buffered values are released on finalization.\r\n      currentBuffer = null!;\r\n    };\r\n  });\r\n}\r\n", "import { OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { arrRemove } from '../util/arrRemove';\r\n\r\n/**\r\n * Buffers the source Observable values until the size hits the maximum\r\n * `bufferSize` given.\r\n *\r\n * <span class=\"informal\">Collects values from the past as an array, and emits\r\n * that array only when its size reaches `bufferSize`.</span>\r\n *\r\n * ![](bufferCount.png)\r\n *\r\n * Buffers a number of values from the source Observable by `bufferSize` then\r\n * emits the buffer and clears it, and starts a new buffer each\r\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\r\n * `null`, then new buffers are started immediately at the start of the source\r\n * and when each buffer closes and is emitted.\r\n *\r\n * ## Examples\r\n *\r\n * Emit the last two click events as an array\r\n *\r\n * ```ts\r\n * import { fromEvent, bufferCount } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const buffered = clicks.pipe(bufferCount(2));\r\n * buffered.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * On every click, emit the last two click events as an array\r\n *\r\n * ```ts\r\n * import { fromEvent, bufferCount } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const buffered = clicks.pipe(bufferCount(2, 1));\r\n * buffered.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link buffer}\r\n * @see {@link bufferTime}\r\n * @see {@link bufferToggle}\r\n * @see {@link bufferWhen}\r\n * @see {@link pairwise}\r\n * @see {@link windowCount}\r\n *\r\n * @param bufferSize The maximum size of the buffer emitted.\r\n * @param startBufferEvery Interval at which to start a new buffer.\r\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\r\n * on every other value from the source. A new buffer is started at the\r\n * beginning of the source by default.\r\n * @return A function that returns an Observable of arrays of buffered values.\r\n */\r\nexport function bufferCount<T>(bufferSize: number, startBufferEvery: number | null = null): OperatorFunction<T, T[]> {\r\n  // If no `startBufferEvery` value was supplied, then we're\r\n  // opening and closing on the bufferSize itself.\r\n  startBufferEvery = startBufferEvery ?? bufferSize;\r\n\r\n  return operate((source, subscriber) => {\r\n    let buffers: T[][] = [];\r\n    let count = 0;\r\n\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value) => {\r\n          let toEmit: T[][] | null = null;\r\n\r\n          // Check to see if we need to start a buffer.\r\n          // This will start one at the first value, and then\r\n          // a new one every N after that.\r\n          if (count++ % startBufferEvery! === 0) {\r\n            buffers.push([]);\r\n          }\r\n\r\n          // Push our value into our active buffers.\r\n          for (const buffer of buffers) {\r\n            buffer.push(value);\r\n            // Check to see if we're over the bufferSize\r\n            // if we are, record it so we can emit it later.\r\n            // If we emitted it now and removed it, it would\r\n            // mutate the `buffers` array while we're looping\r\n            // over it.\r\n            if (bufferSize <= buffer.length) {\r\n              toEmit = toEmit ?? [];\r\n              toEmit.push(buffer);\r\n            }\r\n          }\r\n\r\n          if (toEmit) {\r\n            // We have found some buffers that are over the\r\n            // `bufferSize`. Emit them, and remove them from our\r\n            // buffers list.\r\n            for (const buffer of toEmit) {\r\n              arrRemove(buffers, buffer);\r\n              subscriber.next(buffer);\r\n            }\r\n          }\r\n        },\r\n        () => {\r\n          // When the source completes, emit all of our\r\n          // active buffers.\r\n          for (const buffer of buffers) {\r\n            subscriber.next(buffer);\r\n          }\r\n          subscriber.complete();\r\n        },\r\n        // Pass all errors through to consumer.\r\n        undefined,\r\n        () => {\r\n          // Clean up our memory when we finalize\r\n          buffers = null!;\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n", "import { Subscription } from '../Subscription';\r\nimport { OperatorFunction, SchedulerLike } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { arrRemove } from '../util/arrRemove';\r\nimport { asyncScheduler } from '../scheduler/async';\r\nimport { popScheduler } from '../util/args';\r\nimport { executeSchedule } from '../util/executeSchedule';\r\n\r\nexport function bufferTime<T>(bufferTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\r\nexport function bufferTime<T>(\r\n  bufferTimeSpan: number,\r\n  bufferCreationInterval: number | null | undefined,\r\n  scheduler?: SchedulerLike\r\n): OperatorFunction<T, T[]>;\r\nexport function bufferTime<T>(\r\n  bufferTimeSpan: number,\r\n  bufferCreationInterval: number | null | undefined,\r\n  maxBufferSize: number,\r\n  scheduler?: SchedulerLike\r\n): OperatorFunction<T, T[]>;\r\n\r\n/**\r\n * Buffers the source Observable values for a specific time period.\r\n *\r\n * <span class=\"informal\">Collects values from the past as an array, and emits\r\n * those arrays periodically in time.</span>\r\n *\r\n * ![](bufferTime.png)\r\n *\r\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\r\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\r\n * resets the buffer every `bufferTimeSpan` milliseconds. If\r\n * `bufferCreationInterval` is given, this operator opens the buffer every\r\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\r\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\r\n * `maxBufferSize` is specified, the buffer will be closed either after\r\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\r\n *\r\n * ## Examples\r\n *\r\n * Every second, emit an array of the recent click events\r\n *\r\n * ```ts\r\n * import { fromEvent, bufferTime } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const buffered = clicks.pipe(bufferTime(1000));\r\n * buffered.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * Every 5 seconds, emit the click events from the next 2 seconds\r\n *\r\n * ```ts\r\n * import { fromEvent, bufferTime } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const buffered = clicks.pipe(bufferTime(2000, 5000));\r\n * buffered.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link buffer}\r\n * @see {@link bufferCount}\r\n * @see {@link bufferToggle}\r\n * @see {@link bufferWhen}\r\n * @see {@link windowTime}\r\n *\r\n * @param bufferTimeSpan The amount of time to fill each buffer array.\r\n * @param otherArgs Other configuration arguments such as:\r\n * - `bufferCreationInterval` - the interval at which to start new buffers;\r\n * - `maxBufferSize` - the maximum buffer size;\r\n * - `scheduler` - the scheduler on which to schedule the intervals that determine buffer boundaries.\r\n * @return A function that returns an Observable of arrays of buffered values.\r\n */\r\nexport function bufferTime<T>(bufferTimeSpan: number, ...otherArgs: any[]): OperatorFunction<T, T[]> {\r\n  const scheduler = popScheduler(otherArgs) ?? asyncScheduler;\r\n  const bufferCreationInterval = (otherArgs[0] as number) ?? null;\r\n  const maxBufferSize = (otherArgs[1] as number) || Infinity;\r\n\r\n  return operate((source, subscriber) => {\r\n    // The active buffers, their related subscriptions, and removal functions.\r\n    let bufferRecords: { buffer: T[]; subs: Subscription }[] | null = [];\r\n    // If true, it means that every time we emit a buffer, we want to start a new buffer\r\n    // this is only really used for when *just* the buffer time span is passed.\r\n    let restartOnEmit = false;\r\n\r\n    /**\r\n     * Does the work of emitting the buffer from the record, ensuring that the\r\n     * record is removed before the emission so reentrant code (from some custom scheduling, perhaps)\r\n     * does not alter the buffer. Also checks to see if a new buffer needs to be started\r\n     * after the emit.\r\n     */\r\n    const emit = (record: { buffer: T[]; subs: Subscription }) => {\r\n      const { buffer, subs } = record;\r\n      subs.unsubscribe();\r\n      arrRemove(bufferRecords, record);\r\n      subscriber.next(buffer);\r\n      restartOnEmit && startBuffer();\r\n    };\r\n\r\n    /**\r\n     * Called every time we start a new buffer. This does\r\n     * the work of scheduling a job at the requested bufferTimeSpan\r\n     * that will emit the buffer (if it's not unsubscribed before then).\r\n     */\r\n    const startBuffer = () => {\r\n      if (bufferRecords) {\r\n        const subs = new Subscription();\r\n        subscriber.add(subs);\r\n        const buffer: T[] = [];\r\n        const record = {\r\n          buffer,\r\n          subs,\r\n        };\r\n        bufferRecords.push(record);\r\n        executeSchedule(subs, scheduler, () => emit(record), bufferTimeSpan);\r\n      }\r\n    };\r\n\r\n    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {\r\n      // The user passed both a bufferTimeSpan (required), and a creation interval\r\n      // That means we need to start new buffers on the interval, and those buffers need\r\n      // to wait the required time span before emitting.\r\n      executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);\r\n    } else {\r\n      restartOnEmit = true;\r\n    }\r\n\r\n    startBuffer();\r\n\r\n    const bufferTimeSubscriber = createOperatorSubscriber(\r\n      subscriber,\r\n      (value: T) => {\r\n        // Copy the records, so if we need to remove one we\r\n        // don't mutate the array. It's hard, but not impossible to\r\n        // set up a buffer time that could mutate the array and\r\n        // cause issues here.\r\n        const recordsCopy = bufferRecords!.slice();\r\n        for (const record of recordsCopy) {\r\n          // Loop over all buffers and\r\n          const { buffer } = record;\r\n          buffer.push(value);\r\n          // If the buffer is over the max size, we need to emit it.\r\n          maxBufferSize <= buffer.length && emit(record);\r\n        }\r\n      },\r\n      () => {\r\n        // The source completed, emit all of the active\r\n        // buffers we have before we complete.\r\n        while (bufferRecords?.length) {\r\n          subscriber.next(bufferRecords.shift()!.buffer);\r\n        }\r\n        bufferTimeSubscriber?.unsubscribe();\r\n        subscriber.complete();\r\n        subscriber.unsubscribe();\r\n      },\r\n      // Pass all errors through to consumer.\r\n      undefined,\r\n      // Clean up\r\n      () => (bufferRecords = null)\r\n    );\r\n\r\n    source.subscribe(bufferTimeSubscriber);\r\n  });\r\n}\r\n", "import { Subscription } from '../Subscription';\r\nimport { OperatorFunction, ObservableInput } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { noop } from '../util/noop';\r\nimport { arrRemove } from '../util/arrRemove';\r\n\r\n/**\r\n * Buffers the source Observable values starting from an emission from\r\n * `openings` and ending when the output of `closingSelector` emits.\r\n *\r\n * <span class=\"informal\">Collects values from the past as an array. Starts\r\n * collecting only when `opening` emits, and calls the `closingSelector`\r\n * function to get an Observable that tells when to close the buffer.</span>\r\n *\r\n * ![](bufferToggle.png)\r\n *\r\n * Buffers values from the source by opening the buffer via signals from an\r\n * Observable provided to `openings`, and closing and sending the buffers when\r\n * a Subscribable or Promise returned by the `closingSelector` function emits.\r\n *\r\n * ## Example\r\n *\r\n * Every other second, emit the click events from the next 500ms\r\n *\r\n * ```ts\r\n * import { fromEvent, interval, bufferToggle, EMPTY } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const openings = interval(1000);\r\n * const buffered = clicks.pipe(bufferToggle(openings, i =>\r\n *   i % 2 ? interval(500) : EMPTY\r\n * ));\r\n * buffered.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link buffer}\r\n * @see {@link bufferCount}\r\n * @see {@link bufferTime}\r\n * @see {@link bufferWhen}\r\n * @see {@link windowToggle}\r\n *\r\n * @param openings A Subscribable or Promise of notifications to start new\r\n * buffers.\r\n * @param closingSelector A function that takes\r\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\r\n * which, when it emits, signals that the associated buffer should be emitted\r\n * and cleared.\r\n * @return A function that returns an Observable of arrays of buffered values.\r\n */\r\nexport function bufferToggle<T, O>(\r\n  openings: ObservableInput<O>,\r\n  closingSelector: (value: O) => ObservableInput<any>\r\n): OperatorFunction<T, T[]> {\r\n  return operate((source, subscriber) => {\r\n    const buffers: T[][] = [];\r\n\r\n    // Subscribe to the openings notifier first\r\n    innerFrom(openings).subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (openValue) => {\r\n          const buffer: T[] = [];\r\n          buffers.push(buffer);\r\n          // We use this composite subscription, so that\r\n          // when the closing notifier emits, we can tear it down.\r\n          const closingSubscription = new Subscription();\r\n\r\n          const emitBuffer = () => {\r\n            arrRemove(buffers, buffer);\r\n            subscriber.next(buffer);\r\n            closingSubscription.unsubscribe();\r\n          };\r\n\r\n          // The line below will add the subscription to the parent subscriber *and* the closing subscription.\r\n          closingSubscription.add(innerFrom(closingSelector(openValue)).subscribe(createOperatorSubscriber(subscriber, emitBuffer, noop)));\r\n        },\r\n        noop\r\n      )\r\n    );\r\n\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value) => {\r\n          // Value from our source. Add it to all pending buffers.\r\n          for (const buffer of buffers) {\r\n            buffer.push(value);\r\n          }\r\n        },\r\n        () => {\r\n          // Source complete. Emit all pending buffers.\r\n          while (buffers.length > 0) {\r\n            subscriber.next(buffers.shift()!);\r\n          }\r\n          subscriber.complete();\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n", "import { Subscriber } from '../Subscriber';\r\nimport { ObservableInput, OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { noop } from '../util/noop';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { innerFrom } from '../observable/innerFrom';\r\n\r\n/**\r\n * Buffers the source Observable values, using a factory function of closing\r\n * Observables to determine when to close, emit, and reset the buffer.\r\n *\r\n * <span class=\"informal\">Collects values from the past as an array. When it\r\n * starts collecting values, it calls a function that returns an Observable that\r\n * tells when to close the buffer and restart collecting.</span>\r\n *\r\n * ![](bufferWhen.svg)\r\n *\r\n * Opens a buffer immediately, then closes the buffer when the observable\r\n * returned by calling `closingSelector` function emits a value. When it closes\r\n * the buffer, it immediately opens a new buffer and repeats the process.\r\n *\r\n * ## Example\r\n *\r\n * Emit an array of the last clicks every [1-5] random seconds\r\n *\r\n * ```ts\r\n * import { fromEvent, bufferWhen, interval } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const buffered = clicks.pipe(\r\n *   bufferWhen(() => interval(1000 + Math.random() * 4000))\r\n * );\r\n * buffered.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link buffer}\r\n * @see {@link bufferCount}\r\n * @see {@link bufferTime}\r\n * @see {@link bufferToggle}\r\n * @see {@link windowWhen}\r\n *\r\n * @param closingSelector A function that takes no arguments and returns an\r\n * Observable that signals buffer closure.\r\n * @return A function that returns an Observable of arrays of buffered values.\r\n */\r\nexport function bufferWhen<T>(closingSelector: () => ObservableInput<any>): OperatorFunction<T, T[]> {\r\n  return operate((source, subscriber) => {\r\n    // The buffer we keep and emit.\r\n    let buffer: T[] | null = null;\r\n    // A reference to the subscriber used to subscribe to\r\n    // the closing notifier. We need to hold this so we can\r\n    // end the subscription after the first notification.\r\n    let closingSubscriber: Subscriber<T> | null = null;\r\n\r\n    // Ends the previous closing notifier subscription, so it\r\n    // terminates after the first emission, then emits\r\n    // the current buffer  if there is one, starts a new buffer, and starts a\r\n    // new closing notifier.\r\n    const openBuffer = () => {\r\n      // Make sure to finalize the closing subscription, we only cared\r\n      // about one notification.\r\n      closingSubscriber?.unsubscribe();\r\n      // emit the buffer if we have one, and start a new buffer.\r\n      const b = buffer;\r\n      buffer = [];\r\n      b && subscriber.next(b);\r\n\r\n      // Get a new closing notifier and subscribe to it.\r\n      innerFrom(closingSelector()).subscribe((closingSubscriber = createOperatorSubscriber(subscriber, openBuffer, noop)));\r\n    };\r\n\r\n    // Start the first buffer.\r\n    openBuffer();\r\n\r\n    // Subscribe to our source.\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        // Add every new value to the current buffer.\r\n        (value) => buffer?.push(value),\r\n        // When we complete, emit the buffer if we have one,\r\n        // then complete the result.\r\n        () => {\r\n          buffer && subscriber.next(buffer);\r\n          subscriber.complete();\r\n        },\r\n        // Pass all errors through to consumer.\r\n        undefined,\r\n        // Release memory on finalization\r\n        () => (buffer = closingSubscriber = null!)\r\n      )\r\n    );\r\n  });\r\n}\r\n", "import { Observable } from '../Observable';\r\n\r\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\r\nimport { Subscription } from '../Subscription';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { operate } from '../util/lift';\r\n\r\nexport function catchError<T, O extends ObservableInput<any>>(\r\n  selector: (err: any, caught: Observable<T>) => O\r\n): OperatorFunction<T, T | ObservedValueOf<O>>;\r\n\r\n/**\r\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\r\n *\r\n * <span class=\"informal\">\r\n * It only listens to the error channel and ignores notifications.\r\n * Handles errors from the source observable, and maps them to a new observable.\r\n * The error may also be rethrown, or a new error can be thrown to emit an error from the result.\r\n * </span>\r\n *\r\n * ![](catch.png)\r\n *\r\n * This operator handles errors, but forwards along all other events to the resulting observable.\r\n * If the source observable terminates with an error, it will map that error to a new observable,\r\n * subscribe to it, and forward all of its events to the resulting observable.\r\n *\r\n * ## Examples\r\n *\r\n * Continue with a different Observable when there's an error\r\n *\r\n * ```ts\r\n * import { of, map, catchError } from 'rxjs';\r\n *\r\n * of(1, 2, 3, 4, 5)\r\n *   .pipe(\r\n *     map(n => {\r\n *       if (n === 4) {\r\n *         throw 'four!';\r\n *       }\r\n *       return n;\r\n *     }),\r\n *     catchError(err => of('I', 'II', 'III', 'IV', 'V'))\r\n *   )\r\n *   .subscribe(x => console.log(x));\r\n *   // 1, 2, 3, I, II, III, IV, V\r\n * ```\r\n *\r\n * Retry the caught source Observable again in case of error, similar to `retry()` operator\r\n *\r\n * ```ts\r\n * import { of, map, catchError, take } from 'rxjs';\r\n *\r\n * of(1, 2, 3, 4, 5)\r\n *   .pipe(\r\n *     map(n => {\r\n *       if (n === 4) {\r\n *         throw 'four!';\r\n *       }\r\n *       return n;\r\n *     }),\r\n *     catchError((err, caught) => caught),\r\n *     take(30)\r\n *   )\r\n *   .subscribe(x => console.log(x));\r\n *   // 1, 2, 3, 1, 2, 3, ...\r\n * ```\r\n *\r\n * Throw a new error when the source Observable throws an error\r\n *\r\n * ```ts\r\n * import { of, map, catchError } from 'rxjs';\r\n *\r\n * of(1, 2, 3, 4, 5)\r\n *   .pipe(\r\n *     map(n => {\r\n *       if (n === 4) {\r\n *         throw 'four!';\r\n *       }\r\n *       return n;\r\n *     }),\r\n *     catchError(err => {\r\n *       throw 'error in source. Details: ' + err;\r\n *     })\r\n *   )\r\n *   .subscribe({\r\n *     next: x => console.log(x),\r\n *     error: err => console.log(err)\r\n *   });\r\n *   // 1, 2, 3, error in source. Details: four!\r\n * ```\r\n *\r\n * @see {@link onErrorResumeNext}\r\n * @see {@link repeat}\r\n * @see {@link repeatWhen}\r\n * @see {@link retry }\r\n * @see {@link retryWhen}\r\n *\r\n * @param selector A function that takes as arguments `err`, which is the error, and `caught`, which\r\n * is the source observable, in case you'd like to \"retry\" that observable by returning it again.\r\n * Whatever observable is returned by the `selector` will be used to continue the observable chain.\r\n * @return A function that returns an Observable that originates from either\r\n * the source or the Observable returned by the `selector` function.\r\n */\r\nexport function catchError<T, O extends ObservableInput<any>>(\r\n  selector: (err: any, caught: Observable<T>) => O\r\n): OperatorFunction<T, T | ObservedValueOf<O>> {\r\n  return operate((source, subscriber) => {\r\n    let innerSub: Subscription | null = null;\r\n    let syncUnsub = false;\r\n    let handledResult: Observable<ObservedValueOf<O>>;\r\n\r\n    innerSub = source.subscribe(\r\n      createOperatorSubscriber(subscriber, undefined, undefined, (err) => {\r\n        handledResult = innerFrom(selector(err, catchError(selector)(source)));\r\n        if (innerSub) {\r\n          innerSub.unsubscribe();\r\n          innerSub = null;\r\n          handledResult.subscribe(subscriber);\r\n        } else {\r\n          // We don't have an innerSub yet, that means the error was synchronous\r\n          // because the subscribe call hasn't returned yet.\r\n          syncUnsub = true;\r\n        }\r\n      })\r\n    );\r\n\r\n    if (syncUnsub) {\r\n      // We have a synchronous error, we need to make sure to\r\n      // finalize right away. This ensures that callbacks in the `finalize` operator are called\r\n      // at the right time, and that finalization occurs at the expected\r\n      // time between the source error and the subscription to the\r\n      // next observable.\r\n      innerSub.unsubscribe();\r\n      innerSub = null;\r\n      handledResult!.subscribe(subscriber);\r\n    }\r\n  });\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * A basic scan operation. This is used for `scan` and `reduce`.\r\n * @param accumulator The accumulator to use\r\n * @param seed The seed value for the state to accumulate\r\n * @param hasSeed Whether or not a seed was provided\r\n * @param emitOnNext Whether or not to emit the state on next\r\n * @param emitBeforeComplete Whether or not to emit the before completion\r\n */\r\n\r\nexport function scanInternals<V, A, S>(\r\n  accumulator: (acc: V | A | S, value: V, index: number) => A,\r\n  seed: S,\r\n  hasSeed: boolean,\r\n  emitOnNext: boolean,\r\n  emitBeforeComplete?: undefined | true\r\n) {\r\n  return (source: Observable<V>, subscriber: Subscriber<any>) => {\r\n    // Whether or not we have state yet. This will only be\r\n    // false before the first value arrives if we didn't get\r\n    // a seed value.\r\n    let hasState = hasSeed;\r\n    // The state that we're tracking, starting with the seed,\r\n    // if there is one, and then updated by the return value\r\n    // from the accumulator on each emission.\r\n    let state: any = seed;\r\n    // An index to pass to the accumulator function.\r\n    let index = 0;\r\n\r\n    // Subscribe to our source. All errors and completions are passed through.\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value) => {\r\n          // Always increment the index.\r\n          const i = index++;\r\n          // Set the state\r\n          state = hasState\r\n            ? // We already have state, so we can get the new state from the accumulator\r\n              accumulator(state, value, i)\r\n            : // We didn't have state yet, a seed value was not provided, so\r\n\r\n              // we set the state to the first value, and mark that we have state now\r\n              ((hasState = true), value);\r\n\r\n          // Maybe send it to the consumer.\r\n          emitOnNext && subscriber.next(state);\r\n        },\r\n        // If an onComplete was given, call it, otherwise\r\n        // just pass through the complete notification to the consumer.\r\n        emitBeforeComplete &&\r\n          (() => {\r\n            hasState && subscriber.next(state);\r\n            subscriber.complete();\r\n          })\r\n      )\r\n    );\r\n  };\r\n}\r\n", "import { scanInternals } from './scanInternals';\r\nimport { OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\n\r\nexport function reduce<V, A = V>(accumulator: (acc: A | V, value: V, index: number) => A): OperatorFunction<V, V | A>;\r\nexport function reduce<V, A>(accumulator: (acc: A, value: V, index: number) => A, seed: A): OperatorFunction<V, A>;\r\nexport function reduce<V, A, S = A>(accumulator: (acc: A | S, value: V, index: number) => A, seed: S): OperatorFunction<V, A>;\r\n\r\n/**\r\n * Applies an accumulator function over the source Observable, and returns the\r\n * accumulated result when the source completes, given an optional seed value.\r\n *\r\n * <span class=\"informal\">Combines together all values emitted on the source,\r\n * using an accumulator function that knows how to join a new source value into\r\n * the accumulation from the past.</span>\r\n *\r\n * ![](reduce.png)\r\n *\r\n * Like\r\n * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\r\n * `reduce` applies an `accumulator` function against an accumulation and each\r\n * value of the source Observable (from the past) to reduce it to a single\r\n * value, emitted on the output Observable. Note that `reduce` will only emit\r\n * one value, only when the source Observable completes. It is equivalent to\r\n * applying operator {@link scan} followed by operator {@link last}.\r\n *\r\n * Returns an Observable that applies a specified `accumulator` function to each\r\n * item emitted by the source Observable. If a `seed` value is specified, then\r\n * that value will be used as the initial value for the accumulator. If no seed\r\n * value is specified, the first item of the source is used as the seed.\r\n *\r\n * ## Example\r\n *\r\n * Count the number of click events that happened in 5 seconds\r\n *\r\n * ```ts\r\n * import { fromEvent, takeUntil, interval, map, reduce } from 'rxjs';\r\n *\r\n * const clicksInFiveSeconds = fromEvent(document, 'click')\r\n *   .pipe(takeUntil(interval(5000)));\r\n *\r\n * const ones = clicksInFiveSeconds.pipe(map(() => 1));\r\n * const seed = 0;\r\n * const count = ones.pipe(reduce((acc, one) => acc + one, seed));\r\n *\r\n * count.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link count}\r\n * @see {@link expand}\r\n * @see {@link mergeScan}\r\n * @see {@link scan}\r\n *\r\n * @param accumulator The accumulator function called on each source value.\r\n * @param seed The initial accumulation value.\r\n * @return A function that returns an Observable that emits a single value that\r\n * is the result of accumulating the values emitted by the source Observable.\r\n */\r\nexport function reduce<V, A>(accumulator: (acc: V | A, value: V, index: number) => A, seed?: any): OperatorFunction<V, V | A> {\r\n  return operate(scanInternals(accumulator, seed, arguments.length >= 2, false, true));\r\n}\r\n", "import { reduce } from './reduce';\r\nimport { OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\n\r\nconst arrReducer = (arr: any[], value: any) => (arr.push(value), arr);\r\n\r\n/**\r\n * Collects all source emissions and emits them as an array when the source completes.\r\n *\r\n * <span class=\"informal\">Get all values inside an array when the source completes</span>\r\n *\r\n * ![](toArray.png)\r\n *\r\n * `toArray` will wait until the source Observable completes before emitting\r\n * the array containing all emissions. When the source Observable errors no\r\n * array will be emitted.\r\n *\r\n * ## Example\r\n *\r\n * ```ts\r\n * import { interval, take, toArray } from 'rxjs';\r\n *\r\n * const source = interval(1000);\r\n * const example = source.pipe(\r\n *   take(10),\r\n *   toArray()\r\n * );\r\n *\r\n * example.subscribe(value => console.log(value));\r\n *\r\n * // output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n * ```\r\n *\r\n * @return A function that returns an Observable that emits an array of items\r\n * emitted by the source Observable when source completes.\r\n */\r\nexport function toArray<T>(): OperatorFunction<T, T[]> {\r\n  // Because arrays are mutable, and we're mutating the array in this\r\n  // reducer process, we have to encapsulate the creation of the initial\r\n  // array within this `operate` function.\r\n  return operate((source, subscriber) => {\r\n    reduce(arrReducer, [] as T[])(source).subscribe(subscriber);\r\n  });\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { ObservableInput, OperatorFunction } from '../types';\r\nimport { identity } from '../util/identity';\r\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\r\nimport { pipe } from '../util/pipe';\r\nimport { mergeMap } from './mergeMap';\r\nimport { toArray } from './toArray';\r\n\r\n/**\r\n * Collects all of the inner sources from source observable. Then, once the\r\n * source completes, joins the values using the given static.\r\n *\r\n * This is used for {@link combineLatestAll} and {@link zipAll} which both have the\r\n * same behavior of collecting all inner observables, then operating on them.\r\n *\r\n * @param joinFn The type of static join to apply to the sources collected\r\n * @param project The projection function to apply to the values, if any\r\n */\r\nexport function joinAllInternals<T, R>(joinFn: (sources: ObservableInput<T>[]) => Observable<T>, project?: (...args: any[]) => R) {\r\n  return pipe(\r\n    // Collect all inner sources into an array, and emit them when the\r\n    // source completes.\r\n    toArray() as OperatorFunction<ObservableInput<T>, ObservableInput<T>[]>,\r\n    // Run the join function on the collected array of inner sources.\r\n    mergeMap((sources) => joinFn(sources)),\r\n    // If a projection function was supplied, apply it to each result.\r\n    project ? mapOneOrManyArgs(project) : (identity as any)\r\n  );\r\n}\r\n", "import { combineLatest } from '../observable/combineLatest';\r\nimport { OperatorFunction, ObservableInput } from '../types';\r\nimport { joinAllInternals } from './joinAllInternals';\r\n\r\nexport function combineLatestAll<T>(): OperatorFunction<ObservableInput<T>, T[]>;\r\nexport function combineLatestAll<T>(): OperatorFunction<any, T[]>;\r\nexport function combineLatestAll<T, R>(project: (...values: T[]) => R): OperatorFunction<ObservableInput<T>, R>;\r\nexport function combineLatestAll<R>(project: (...values: Array<any>) => R): OperatorFunction<any, R>;\r\n\r\n/**\r\n * Flattens an Observable-of-Observables by applying {@link combineLatest} when the Observable-of-Observables completes.\r\n *\r\n * `combineLatestAll` takes an Observable of Observables, and collects all Observables from it. Once the outer Observable completes,\r\n * it subscribes to all collected Observables and combines their values using the {@link combineLatest} strategy, such that:\r\n *\r\n * * Every time an inner Observable emits, the output Observable emits\r\n * * When the returned observable emits, it emits all of the latest values by:\r\n *    * If a `project` function is provided, it is called with each recent value from each inner Observable in whatever order they\r\n *      arrived, and the result of the `project` function is what is emitted by the output Observable.\r\n *    * If there is no `project` function, an array of all the most recent values is emitted by the output Observable.\r\n *\r\n * ## Example\r\n *\r\n * Map two click events to a finite interval Observable, then apply `combineLatestAll`\r\n *\r\n * ```ts\r\n * import { fromEvent, map, interval, take, combineLatestAll } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const higherOrder = clicks.pipe(\r\n *   map(() => interval(Math.random() * 2000).pipe(take(3))),\r\n *   take(2)\r\n * );\r\n * const result = higherOrder.pipe(combineLatestAll());\r\n *\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link combineLatest}\r\n * @see {@link combineLatestWith}\r\n * @see {@link mergeAll}\r\n *\r\n * @param project optional function to map the most recent values from each inner Observable into a new result.\r\n * Takes each of the most recent values from each collected inner Observable as arguments, in order.\r\n * @return A function that returns an Observable that flattens Observables\r\n * emitted by the source Observable.\r\n */\r\nexport function combineLatestAll<R>(project?: (...values: Array<any>) => R) {\r\n  return joinAllInternals(combineLatest, project);\r\n}\r\n", "import { combineLatestAll } from './combineLatestAll';\r\n\r\n/**\r\n * @deprecated Renamed to {@link combineLatestAll}. Will be removed in v8.\r\n */\r\nexport const combineAll = combineLatestAll;\r\n", "import { combineLatestInit } from '../observable/combineLatest';\r\nimport { ObservableInput, ObservableInputTuple, OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { argsOrArgArray } from '../util/argsOrArgArray';\r\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\r\nimport { pipe } from '../util/pipe';\r\nimport { popResultSelector } from '../util/args';\r\n\r\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\r\nexport function combineLatest<T, A extends readonly unknown[], R>(\r\n  sources: [...ObservableInputTuple<A>],\r\n  project: (...values: [T, ...A]) => R\r\n): OperatorFunction<T, R>;\r\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\r\nexport function combineLatest<T, A extends readonly unknown[], R>(sources: [...ObservableInputTuple<A>]): OperatorFunction<T, [T, ...A]>;\r\n\r\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\r\nexport function combineLatest<T, A extends readonly unknown[], R>(\r\n  ...sourcesAndProject: [...ObservableInputTuple<A>, (...values: [T, ...A]) => R]\r\n): OperatorFunction<T, R>;\r\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\r\nexport function combineLatest<T, A extends readonly unknown[], R>(...sources: [...ObservableInputTuple<A>]): OperatorFunction<T, [T, ...A]>;\r\n\r\n/**\r\n * @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8.\r\n */\r\nexport function combineLatest<T, R>(...args: (ObservableInput<any> | ((...values: any[]) => R))[]): OperatorFunction<T, unknown> {\r\n  const resultSelector = popResultSelector(args);\r\n  return resultSelector\r\n    ? pipe(combineLatest(...(args as Array<ObservableInput<any>>)), mapOneOrManyArgs(resultSelector))\r\n    : operate((source, subscriber) => {\r\n        combineLatestInit([source, ...argsOrArgArray(args)])(subscriber);\r\n      });\r\n}\r\n", "import { ObservableInputTuple, OperatorFunction, Cons } from '../types';\r\nimport { combineLatest } from './combineLatest';\r\n\r\n/**\r\n * Create an observable that combines the latest values from all passed observables and the source\r\n * into arrays and emits them.\r\n *\r\n * Returns an observable, that when subscribed to, will subscribe to the source observable and all\r\n * sources provided as arguments. Once all sources emit at least one value, all of the latest values\r\n * will be emitted as an array. After that, every time any source emits a value, all of the latest values\r\n * will be emitted as an array.\r\n *\r\n * This is a useful operator for eagerly calculating values based off of changed inputs.\r\n *\r\n * ## Example\r\n *\r\n * Simple concatenation of values from two inputs\r\n *\r\n * ```ts\r\n * import { fromEvent, combineLatestWith, map } from 'rxjs';\r\n *\r\n * // Setup: Add two inputs to the page\r\n * const input1 = document.createElement('input');\r\n * document.body.appendChild(input1);\r\n * const input2 = document.createElement('input');\r\n * document.body.appendChild(input2);\r\n *\r\n * // Get streams of changes\r\n * const input1Changes$ = fromEvent(input1, 'change');\r\n * const input2Changes$ = fromEvent(input2, 'change');\r\n *\r\n * // Combine the changes by adding them together\r\n * input1Changes$.pipe(\r\n *   combineLatestWith(input2Changes$),\r\n *   map(([e1, e2]) => (<HTMLInputElement>e1.target).value + ' - ' + (<HTMLInputElement>e2.target).value)\r\n * )\r\n * .subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @param otherSources the other sources to subscribe to.\r\n * @return A function that returns an Observable that emits the latest\r\n * emissions from both source and provided Observables.\r\n */\r\nexport function combineLatestWith<T, A extends readonly unknown[]>(\r\n  ...otherSources: [...ObservableInputTuple<A>]\r\n): OperatorFunction<T, Cons<T, A>> {\r\n  return combineLatest(...otherSources);\r\n}\r\n", "import { mergeMap } from './mergeMap';\r\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\r\nimport { isFunction } from '../util/isFunction';\r\n\r\n/* tslint:disable:max-line-length */\r\nexport function concatMap<T, O extends ObservableInput<any>>(\r\n  project: (value: T, index: number) => O\r\n): OperatorFunction<T, ObservedValueOf<O>>;\r\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\r\nexport function concatMap<T, O extends ObservableInput<any>>(\r\n  project: (value: T, index: number) => O,\r\n  resultSelector: undefined\r\n): OperatorFunction<T, ObservedValueOf<O>>;\r\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\r\nexport function concatMap<T, R, O extends ObservableInput<any>>(\r\n  project: (value: T, index: number) => O,\r\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\r\n): OperatorFunction<T, R>;\r\n/* tslint:enable:max-line-length */\r\n\r\n/**\r\n * Projects each source value to an Observable which is merged in the output\r\n * Observable, in a serialized fashion waiting for each one to complete before\r\n * merging the next.\r\n *\r\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\r\n * these inner Observables using {@link concatAll}.</span>\r\n *\r\n * ![](concatMap.png)\r\n *\r\n * Returns an Observable that emits items based on applying a function that you\r\n * supply to each item emitted by the source Observable, where that function\r\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\r\n * concatenated with the previous inner Observable.\r\n *\r\n * __Warning:__ if source values arrive endlessly and faster than their\r\n * corresponding inner Observables can complete, it will result in memory issues\r\n * as inner Observables amass in an unbounded buffer waiting for their turn to\r\n * be subscribed to.\r\n *\r\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\r\n * to `1`.\r\n *\r\n * ## Example\r\n *\r\n * For each click event, tick every second from 0 to 3, with no concurrency\r\n *\r\n * ```ts\r\n * import { fromEvent, concatMap, interval, take } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(\r\n *   concatMap(ev => interval(1000).pipe(take(4)))\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Results in the following:\r\n * // (results are not concurrent)\r\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\r\n * // on a 1000ms interval\r\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\r\n * ```\r\n *\r\n * @see {@link concat}\r\n * @see {@link concatAll}\r\n * @see {@link concatMapTo}\r\n * @see {@link exhaustMap}\r\n * @see {@link mergeMap}\r\n * @see {@link switchMap}\r\n *\r\n * @param project A function that, when applied to an item emitted by the source\r\n * Observable, returns an Observable.\r\n * @return A function that returns an Observable that emits the result of\r\n * applying the projection function (and the optional deprecated\r\n * `resultSelector`) to each item emitted by the source Observable and taking\r\n * values from each projected inner Observable sequentially.\r\n */\r\nexport function concatMap<T, R, O extends ObservableInput<any>>(\r\n  project: (value: T, index: number) => O,\r\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\r\n): OperatorFunction<T, ObservedValueOf<O> | R> {\r\n  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);\r\n}\r\n", "import { concatMap } from './concatMap';\r\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\r\nimport { isFunction } from '../util/isFunction';\r\n\r\n/** @deprecated Will be removed in v9. Use {@link concatMap} instead: `concatMap(() => result)` */\r\nexport function concatMapTo<O extends ObservableInput<unknown>>(observable: O): OperatorFunction<unknown, ObservedValueOf<O>>;\r\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\r\nexport function concatMapTo<O extends ObservableInput<unknown>>(\r\n  observable: O,\r\n  resultSelector: undefined\r\n): OperatorFunction<unknown, ObservedValueOf<O>>;\r\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\r\nexport function concatMapTo<T, R, O extends ObservableInput<unknown>>(\r\n  observable: O,\r\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\r\n): OperatorFunction<T, R>;\r\n\r\n/**\r\n * Projects each source value to the same Observable which is merged multiple\r\n * times in a serialized fashion on the output Observable.\r\n *\r\n * <span class=\"informal\">It's like {@link concatMap}, but maps each value\r\n * always to the same inner Observable.</span>\r\n *\r\n * ![](concatMapTo.png)\r\n *\r\n * Maps each source value to the given Observable `innerObservable` regardless\r\n * of the source value, and then flattens those resulting Observables into one\r\n * single Observable, which is the output Observable. Each new `innerObservable`\r\n * instance emitted on the output Observable is concatenated with the previous\r\n * `innerObservable` instance.\r\n *\r\n * __Warning:__ if source values arrive endlessly and faster than their\r\n * corresponding inner Observables can complete, it will result in memory issues\r\n * as inner Observables amass in an unbounded buffer waiting for their turn to\r\n * be subscribed to.\r\n *\r\n * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter\r\n * set to `1`.\r\n *\r\n * ## Example\r\n *\r\n * For each click event, tick every second from 0 to 3, with no concurrency\r\n *\r\n * ```ts\r\n * import { fromEvent, concatMapTo, interval, take } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(\r\n *   concatMapTo(interval(1000).pipe(take(4)))\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Results in the following:\r\n * // (results are not concurrent)\r\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\r\n * // on a 1000ms interval\r\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\r\n * ```\r\n *\r\n * @see {@link concat}\r\n * @see {@link concatAll}\r\n * @see {@link concatMap}\r\n * @see {@link mergeMapTo}\r\n * @see {@link switchMapTo}\r\n *\r\n * @param innerObservable An `ObservableInput` to replace each value from the\r\n * source Observable.\r\n * @return A function that returns an Observable of values merged together by\r\n * joining the passed Observable with itself, one after the other, for each\r\n * value emitted from the source.\r\n * @deprecated Will be removed in v9. Use {@link concatMap} instead: `concatMap(() => result)`\r\n */\r\nexport function concatMapTo<T, R, O extends ObservableInput<unknown>>(\r\n  innerObservable: O,\r\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\r\n): OperatorFunction<T, ObservedValueOf<O> | R> {\r\n  return isFunction(resultSelector) ? concatMap(() => innerObservable, resultSelector) : concatMap(() => innerObservable);\r\n}\r\n", "import { ObservableInputTuple, OperatorFunction, SchedulerLike } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { concatAll } from './concatAll';\r\nimport { popScheduler } from '../util/args';\r\nimport { from } from '../observable/from';\r\n\r\n/** @deprecated Replaced with {@link concatWith}. Will be removed in v8. */\r\nexport function concat<T, A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): OperatorFunction<T, T | A[number]>;\r\n/** @deprecated Replaced with {@link concatWith}. Will be removed in v8. */\r\nexport function concat<T, A extends readonly unknown[]>(\r\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike]\r\n): OperatorFunction<T, T | A[number]>;\r\n\r\n/**\r\n * @deprecated Replaced with {@link concatWith}. Will be removed in v8.\r\n */\r\nexport function concat<T, R>(...args: any[]): OperatorFunction<T, R> {\r\n  const scheduler = popScheduler(args);\r\n  return operate((source, subscriber) => {\r\n    concatAll()(from([source, ...args], scheduler)).subscribe(subscriber);\r\n  });\r\n}\r\n", "import { ObservableInputTuple, OperatorFunction } from '../types';\r\nimport { concat } from './concat';\r\n\r\n/**\r\n * Emits all of the values from the source observable, then, once it completes, subscribes\r\n * to each observable source provided, one at a time, emitting all of their values, and not subscribing\r\n * to the next one until it completes.\r\n *\r\n * `concat(a$, b$, c$)` is the same as `a$.pipe(concatWith(b$, c$))`.\r\n *\r\n * ## Example\r\n *\r\n * Listen for one mouse click, then listen for all mouse moves.\r\n *\r\n * ```ts\r\n * import { fromEvent, map, take, concatWith } from 'rxjs';\r\n *\r\n * const clicks$ = fromEvent(document, 'click');\r\n * const moves$ = fromEvent(document, 'mousemove');\r\n *\r\n * clicks$.pipe(\r\n *   map(() => 'click'),\r\n *   take(1),\r\n *   concatWith(\r\n *     moves$.pipe(\r\n *       map(() => 'move')\r\n *     )\r\n *   )\r\n * )\r\n * .subscribe(x => console.log(x));\r\n *\r\n * // 'click'\r\n * // 'move'\r\n * // 'move'\r\n * // 'move'\r\n * // ...\r\n * ```\r\n *\r\n * @param otherSources Other observable sources to subscribe to, in sequence, after the original source is complete.\r\n * @return A function that returns an Observable that concatenates\r\n * subscriptions to the source and provided Observables subscribing to the next\r\n * only once the current subscription completes.\r\n */\r\nexport function concatWith<T, A extends readonly unknown[]>(\r\n  ...otherSources: [...ObservableInputTuple<A>]\r\n): OperatorFunction<T, T | A[number]> {\r\n  return concat(...otherSources);\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { Subscribable } from '../types';\r\n\r\n/**\r\n * Used to convert a subscribable to an observable.\r\n *\r\n * Currently, this is only used within internals.\r\n *\r\n * TODO: Discuss ObservableInput supporting \"Subscribable\".\r\n * https://github.com/ReactiveX/rxjs/issues/5909\r\n *\r\n * @param subscribable A subscribable\r\n */\r\nexport function fromSubscribable<T>(subscribable: Subscribable<T>) {\r\n  return new Observable((subscriber: Subscriber<T>) => subscribable.subscribe(subscriber));\r\n}\r\n", "import { OperatorFunction, ObservableInput, ObservedValueOf, SubjectLike } from '../types';\r\nimport { Observable } from '../Observable';\r\nimport { Subject } from '../Subject';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { operate } from '../util/lift';\r\nimport { fromSubscribable } from '../observable/fromSubscribable';\r\n\r\n/**\r\n * An object used to configure {@link connect} operator.\r\n */\r\nexport interface ConnectConfig<T> {\r\n  /**\r\n   * A factory function used to create the Subject through which the source\r\n   * is multicast. By default, this creates a {@link Subject}.\r\n   */\r\n  connector: () => SubjectLike<T>;\r\n}\r\n\r\n/**\r\n * The default configuration for `connect`.\r\n */\r\nconst DEFAULT_CONFIG: ConnectConfig<unknown> = {\r\n  connector: () => new Subject<unknown>(),\r\n};\r\n\r\n/**\r\n * Creates an observable by multicasting the source within a function that\r\n * allows the developer to define the usage of the multicast prior to connection.\r\n *\r\n * This is particularly useful if the observable source you wish to multicast could\r\n * be synchronous or asynchronous. This sets it apart from {@link share}, which, in the\r\n * case of totally synchronous sources will fail to share a single subscription with\r\n * multiple consumers, as by the time the subscription to the result of {@link share}\r\n * has returned, if the source is synchronous its internal reference count will jump from\r\n * 0 to 1 back to 0 and reset.\r\n *\r\n * To use `connect`, you provide a `selector` function that will give you\r\n * a multicast observable that is not yet connected. You then use that multicast observable\r\n * to create a resulting observable that, when subscribed, will set up your multicast. This is\r\n * generally, but not always, accomplished with {@link merge}.\r\n *\r\n * Note that using a {@link takeUntil} inside of `connect`'s `selector` _might_ mean you were looking\r\n * to use the {@link takeWhile} operator instead.\r\n *\r\n * When you subscribe to the result of `connect`, the `selector` function will be called. After\r\n * the `selector` function returns, the observable it returns will be subscribed to, _then_ the\r\n * multicast will be connected to the source.\r\n *\r\n * ## Example\r\n *\r\n * Sharing a totally synchronous observable\r\n *\r\n * ```ts\r\n * import { of, tap, connect, merge, map, filter } from 'rxjs';\r\n *\r\n * const source$ = of(1, 2, 3, 4, 5).pipe(\r\n *   tap({\r\n *     subscribe: () => console.log('subscription started'),\r\n *     next: n => console.log(`source emitted ${ n }`)\r\n *   })\r\n * );\r\n *\r\n * source$.pipe(\r\n *   // Notice in here we're merging 3 subscriptions to `shared$`.\r\n *   connect(shared$ => merge(\r\n *     shared$.pipe(map(n => `all ${ n }`)),\r\n *     shared$.pipe(filter(n => n % 2 === 0), map(n => `even ${ n }`)),\r\n *     shared$.pipe(filter(n => n % 2 === 1), map(n => `odd ${ n }`))\r\n *   ))\r\n * )\r\n * .subscribe(console.log);\r\n *\r\n * // Expected output: (notice only one subscription)\r\n * 'subscription started'\r\n * 'source emitted 1'\r\n * 'all 1'\r\n * 'odd 1'\r\n * 'source emitted 2'\r\n * 'all 2'\r\n * 'even 2'\r\n * 'source emitted 3'\r\n * 'all 3'\r\n * 'odd 3'\r\n * 'source emitted 4'\r\n * 'all 4'\r\n * 'even 4'\r\n * 'source emitted 5'\r\n * 'all 5'\r\n * 'odd 5'\r\n * ```\r\n *\r\n * @param selector A function used to set up the multicast. Gives you a multicast observable\r\n * that is not yet connected. With that, you're expected to create and return\r\n * and Observable, that when subscribed to, will utilize the multicast observable.\r\n * After this function is executed -- and its return value subscribed to -- the\r\n * operator will subscribe to the source, and the connection will be made.\r\n * @param config The configuration object for `connect`.\r\n */\r\nexport function connect<T, O extends ObservableInput<unknown>>(\r\n  selector: (shared: Observable<T>) => O,\r\n  config: ConnectConfig<T> = DEFAULT_CONFIG\r\n): OperatorFunction<T, ObservedValueOf<O>> {\r\n  const { connector } = config;\r\n  return operate((source, subscriber) => {\r\n    const subject = connector();\r\n    innerFrom(selector(fromSubscribable(subject))).subscribe(subscriber);\r\n    subscriber.add(source.subscribe(subject));\r\n  });\r\n}\r\n", "import { OperatorFunction } from '../types';\r\nimport { reduce } from './reduce';\r\n\r\n/**\r\n * Counts the number of emissions on the source and emits that number when the\r\n * source completes.\r\n *\r\n * <span class=\"informal\">Tells how many values were emitted, when the source\r\n * completes.</span>\r\n *\r\n * ![](count.png)\r\n *\r\n * `count` transforms an Observable that emits values into an Observable that\r\n * emits a single value that represents the number of values emitted by the\r\n * source Observable. If the source Observable terminates with an error, `count`\r\n * will pass this error notification along without emitting a value first. If\r\n * the source Observable does not terminate at all, `count` will neither emit\r\n * a value nor terminate. This operator takes an optional `predicate` function\r\n * as argument, in which case the output emission will represent the number of\r\n * source values that matched `true` with the `predicate`.\r\n *\r\n * ## Examples\r\n *\r\n * Counts how many seconds have passed before the first click happened\r\n *\r\n * ```ts\r\n * import { interval, fromEvent, takeUntil, count } from 'rxjs';\r\n *\r\n * const seconds = interval(1000);\r\n * const clicks = fromEvent(document, 'click');\r\n * const secondsBeforeClick = seconds.pipe(takeUntil(clicks));\r\n * const result = secondsBeforeClick.pipe(count());\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * Counts how many odd numbers are there between 1 and 7\r\n *\r\n * ```ts\r\n * import { range, count } from 'rxjs';\r\n *\r\n * const numbers = range(1, 7);\r\n * const result = numbers.pipe(count(i => i % 2 === 1));\r\n * result.subscribe(x => console.log(x));\r\n * // Results in:\r\n * // 4\r\n * ```\r\n *\r\n * @see {@link max}\r\n * @see {@link min}\r\n * @see {@link reduce}\r\n *\r\n * @param predicate A function that is used to analyze the value and the index and\r\n * determine whether or not to increment the count. Return `true` to increment the count,\r\n * and return `false` to keep the count the same.\r\n * If the predicate is not provided, every value will be counted.\r\n * @return A function that returns an Observable that emits one number that\r\n * represents the count of emissions.\r\n */\r\nexport function count<T>(predicate?: (value: T, index: number) => boolean): OperatorFunction<T, number> {\r\n  return reduce((total, value, i) => (!predicate || predicate(value, i) ? total + 1 : total), 0);\r\n}\r\n", "import { Subscriber } from '../Subscriber';\r\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { noop } from '../util/noop';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { innerFrom } from '../observable/innerFrom';\r\n\r\n/**\r\n * Emits a notification from the source Observable only after a particular time span\r\n * determined by another Observable has passed without another source emission.\r\n *\r\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\r\n * emission silence is determined by a second Observable.</span>\r\n *\r\n * ![](debounce.svg)\r\n *\r\n * `debounce` delays notifications emitted by the source Observable, but drops previous\r\n * pending delayed emissions if a new notification arrives on the source Observable.\r\n * This operator keeps track of the most recent notification from the source\r\n * Observable, and spawns a duration Observable by calling the\r\n * `durationSelector` function. The notification is emitted only when the duration\r\n * Observable emits a next notification, and if no other notification was emitted on\r\n * the source Observable since the duration Observable was spawned. If a new\r\n * notification appears before the duration Observable emits, the previous notification will\r\n * not be emitted and a new duration is scheduled from `durationSelector` is scheduled.\r\n * If the completing event happens during the scheduled duration the last cached notification\r\n * is emitted before the completion event is forwarded to the output observable.\r\n * If the error event happens during the scheduled duration or after it only the error event is\r\n * forwarded to the output observable. The cache notification is not emitted in this case.\r\n *\r\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\r\n * delay-like operator since output emissions do not necessarily occur at the\r\n * same time as they did on the source Observable.\r\n *\r\n * ## Example\r\n *\r\n * Emit the most recent click after a burst of clicks\r\n *\r\n * ```ts\r\n * import { fromEvent, scan, debounce, interval } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(\r\n *   scan(i => ++i, 1),\r\n *   debounce(i => interval(200 * i))\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link audit}\r\n * @see {@link auditTime}\r\n * @see {@link debounceTime}\r\n * @see {@link delay}\r\n * @see {@link sample}\r\n * @see {@link sampleTime}\r\n * @see {@link throttle}\r\n * @see {@link throttleTime}\r\n *\r\n * @param durationSelector A function\r\n * that receives a value from the source Observable, for computing the timeout\r\n * duration for each source value, returned as an Observable or a Promise.\r\n * @return A function that returns an Observable that delays the emissions of\r\n * the source Observable by the specified duration Observable returned by\r\n * `durationSelector`, and may drop some values if they occur too frequently.\r\n */\r\nexport function debounce<T>(durationSelector: (value: T) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    let hasValue = false;\r\n    let lastValue: T | null = null;\r\n    // The subscriber/subscription for the current debounce, if there is one.\r\n    let durationSubscriber: Subscriber<any> | null = null;\r\n\r\n    const emit = () => {\r\n      // Unsubscribe any current debounce subscription we have,\r\n      // we only cared about the first notification from it, and we\r\n      // want to clean that subscription up as soon as possible.\r\n      durationSubscriber?.unsubscribe();\r\n      durationSubscriber = null;\r\n      if (hasValue) {\r\n        // We have a value! Free up memory first, then emit the value.\r\n        hasValue = false;\r\n        const value = lastValue!;\r\n        lastValue = null;\r\n        subscriber.next(value);\r\n      }\r\n    };\r\n\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value: T) => {\r\n          // Cancel any pending debounce duration. We don't\r\n          // need to null it out here yet tho, because we're just going\r\n          // to create another one in a few lines.\r\n          durationSubscriber?.unsubscribe();\r\n          hasValue = true;\r\n          lastValue = value;\r\n          // Capture our duration subscriber, so we can unsubscribe it when we're notified\r\n          // and we're going to emit the value.\r\n          durationSubscriber = createOperatorSubscriber(subscriber, emit, noop);\r\n          // Subscribe to the duration.\r\n          innerFrom(durationSelector(value)).subscribe(durationSubscriber);\r\n        },\r\n        () => {\r\n          // Source completed.\r\n          // Emit any pending debounced values then complete\r\n          emit();\r\n          subscriber.complete();\r\n        },\r\n        // Pass all errors through to consumer\r\n        undefined,\r\n        () => {\r\n          // Finalization.\r\n          lastValue = durationSubscriber = null;\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n", "import { asyncScheduler } from '../scheduler/async';\r\nimport { Subscription } from '../Subscription';\r\nimport { MonoTypeOperatorFunction, SchedulerAction, SchedulerLike } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Emits a notification from the source Observable only after a particular time span\r\n * has passed without another source emission.\r\n *\r\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\r\n * recent notification from each burst of emissions.</span>\r\n *\r\n * ![](debounceTime.png)\r\n *\r\n * `debounceTime` delays notifications emitted by the source Observable, but drops\r\n * previous pending delayed emissions if a new notification arrives on the source\r\n * Observable. This operator keeps track of the most recent notification from the\r\n * source Observable, and emits that only when `dueTime` has passed\r\n * without any other notification appearing on the source Observable. If a new value\r\n * appears before `dueTime` silence occurs, the previous notification will be dropped\r\n * and will not be emitted and a new `dueTime` is scheduled.\r\n * If the completing event happens during `dueTime` the last cached notification\r\n * is emitted before the completion event is forwarded to the output observable.\r\n * If the error event happens during `dueTime` or after it only the error event is\r\n * forwarded to the output observable. The cache notification is not emitted in this case.\r\n *\r\n * This is a rate-limiting operator, because it is impossible for more than one\r\n * notification to be emitted in any time window of duration `dueTime`, but it is also\r\n * a delay-like operator since output emissions do not occur at the same time as\r\n * they did on the source Observable. Optionally takes a {@link SchedulerLike} for\r\n * managing timers.\r\n *\r\n * ## Example\r\n *\r\n * Emit the most recent click after a burst of clicks\r\n *\r\n * ```ts\r\n * import { fromEvent, debounceTime } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(debounceTime(1000));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link audit}\r\n * @see {@link auditTime}\r\n * @see {@link debounce}\r\n * @see {@link sample}\r\n * @see {@link sampleTime}\r\n * @see {@link throttle}\r\n * @see {@link throttleTime}\r\n *\r\n * @param dueTime The timeout duration in milliseconds (or the time unit determined\r\n * internally by the optional `scheduler`) for the window of time required to wait\r\n * for emission silence before emitting the most recent source value.\r\n * @param scheduler The {@link SchedulerLike} to use for managing the timers that\r\n * handle the timeout for each value.\r\n * @return A function that returns an Observable that delays the emissions of\r\n * the source Observable by the specified `dueTime`, and may drop some values\r\n * if they occur too frequently.\r\n */\r\nexport function debounceTime<T>(dueTime: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    let activeTask: Subscription | null = null;\r\n    let lastValue: T | null = null;\r\n    let lastTime: number | null = null;\r\n\r\n    const emit = () => {\r\n      if (activeTask) {\r\n        // We have a value! Free up memory first, then emit the value.\r\n        activeTask.unsubscribe();\r\n        activeTask = null;\r\n        const value = lastValue!;\r\n        lastValue = null;\r\n        subscriber.next(value);\r\n      }\r\n    };\r\n    function emitWhenIdle(this: SchedulerAction<unknown>) {\r\n      // This is called `dueTime` after the first value\r\n      // but we might have received new values during this window!\r\n\r\n      const targetTime = lastTime! + dueTime;\r\n      const now = scheduler.now();\r\n      if (now < targetTime) {\r\n        // On that case, re-schedule to the new target\r\n        activeTask = this.schedule(undefined, targetTime - now);\r\n        subscriber.add(activeTask);\r\n        return;\r\n      }\r\n\r\n      emit();\r\n    }\r\n\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value: T) => {\r\n          lastValue = value;\r\n          lastTime = scheduler.now();\r\n\r\n          // Only set up a task if it's not already up\r\n          if (!activeTask) {\r\n            activeTask = scheduler.schedule(emitWhenIdle, dueTime);\r\n            subscriber.add(activeTask);\r\n          }\r\n        },\r\n        () => {\r\n          // Source completed.\r\n          // Emit any pending debounced values then complete\r\n          emit();\r\n          subscriber.complete();\r\n        },\r\n        // Pass all errors through to consumer.\r\n        undefined,\r\n        () => {\r\n          // Finalization.\r\n          lastValue = activeTask = null;\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n", "import { OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Emits a given value if the source Observable completes without emitting any\r\n * `next` value, otherwise mirrors the source Observable.\r\n *\r\n * <span class=\"informal\">If the source Observable turns out to be empty, then\r\n * this operator will emit a default value.</span>\r\n *\r\n * ![](defaultIfEmpty.png)\r\n *\r\n * `defaultIfEmpty` emits the values emitted by the source Observable or a\r\n * specified default value if the source Observable is empty (completes without\r\n * having emitted any `next` value).\r\n *\r\n * ## Example\r\n *\r\n * If no clicks happen in 5 seconds, then emit 'no clicks'\r\n *\r\n * ```ts\r\n * import { fromEvent, takeUntil, interval, defaultIfEmpty } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const clicksBeforeFive = clicks.pipe(takeUntil(interval(5000)));\r\n * const result = clicksBeforeFive.pipe(defaultIfEmpty('no clicks'));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link empty}\r\n * @see {@link last}\r\n *\r\n * @param defaultValue The default value used if the source\r\n * Observable is empty.\r\n * @return A function that returns an Observable that emits either the\r\n * specified `defaultValue` if the source Observable emits no items, or the\r\n * values emitted by the source Observable.\r\n */\r\nexport function defaultIfEmpty<T, R>(defaultValue: R): OperatorFunction<T, T | R> {\r\n  return operate((source, subscriber) => {\r\n    let hasValue = false;\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value) => {\r\n          hasValue = true;\r\n          subscriber.next(value);\r\n        },\r\n        () => {\r\n          if (!hasValue) {\r\n            subscriber.next(defaultValue!);\r\n          }\r\n          subscriber.complete();\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n", "import { MonoTypeOperatorFunction } from '../types';\r\nimport { EMPTY } from '../observable/empty';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Emits only the first `count` values emitted by the source Observable.\r\n *\r\n * <span class=\"informal\">Takes the first `count` values from the source, then\r\n * completes.</span>\r\n *\r\n * ![](take.png)\r\n *\r\n * `take` returns an Observable that emits only the first `count` values emitted\r\n * by the source Observable. If the source emits fewer than `count` values then\r\n * all of its values are emitted. After that, it completes, regardless if the\r\n * source completes.\r\n *\r\n * ## Example\r\n *\r\n * Take the first 5 seconds of an infinite 1-second interval Observable\r\n *\r\n * ```ts\r\n * import { interval, take } from 'rxjs';\r\n *\r\n * const intervalCount = interval(1000);\r\n * const takeFive = intervalCount.pipe(take(5));\r\n * takeFive.subscribe(x => console.log(x));\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1\r\n * // 2\r\n * // 3\r\n * // 4\r\n * ```\r\n *\r\n * @see {@link takeLast}\r\n * @see {@link takeUntil}\r\n * @see {@link takeWhile}\r\n * @see {@link skip}\r\n *\r\n * @param count The maximum number of `next` values to emit.\r\n * @return A function that returns an Observable that emits only the first\r\n * `count` values emitted by the source Observable, or all of the values from\r\n * the source if the source emits fewer than `count` values.\r\n */\r\nexport function take<T>(count: number): MonoTypeOperatorFunction<T> {\r\n  return count <= 0\r\n    ? // If we are taking no values, that's empty.\r\n      () => EMPTY\r\n    : operate((source, subscriber) => {\r\n        let seen = 0;\r\n        source.subscribe(\r\n          createOperatorSubscriber(subscriber, (value) => {\r\n            // Increment the number of values we have seen,\r\n            // then check it against the allowed count to see\r\n            // if we are still letting values through.\r\n            if (++seen <= count) {\r\n              subscriber.next(value);\r\n              // If we have met or passed our allowed count,\r\n              // we need to complete. We have to do <= here,\r\n              // because re-entrant code will increment `seen` twice.\r\n              if (count <= seen) {\r\n                subscriber.complete();\r\n              }\r\n            }\r\n          })\r\n        );\r\n      });\r\n}\r\n", "import { OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { noop } from '../util/noop';\r\n\r\n/**\r\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\r\n *\r\n * ![](ignoreElements.png)\r\n *\r\n * The `ignoreElements` operator suppresses all items emitted by the source Observable,\r\n * but allows its termination notification (either `error` or `complete`) to pass through unchanged.\r\n *\r\n * If you do not care about the items being emitted by an Observable, but you do want to be notified\r\n * when it completes or when it terminates with an error, you can apply the `ignoreElements` operator\r\n * to the Observable, which will ensure that it will never call its observers’ `next` handlers.\r\n *\r\n * ## Example\r\n *\r\n * Ignore all `next` emissions from the source\r\n *\r\n * ```ts\r\n * import { of, ignoreElements } from 'rxjs';\r\n *\r\n * of('you', 'talking', 'to', 'me')\r\n *   .pipe(ignoreElements())\r\n *   .subscribe({\r\n *     next: word => console.log(word),\r\n *     error: err => console.log('error:', err),\r\n *     complete: () => console.log('the end'),\r\n *   });\r\n *\r\n * // result:\r\n * // 'the end'\r\n * ```\r\n *\r\n * @return A function that returns an empty Observable that only calls\r\n * `complete` or `error`, based on which one is called by the source\r\n * Observable.\r\n */\r\nexport function ignoreElements(): OperatorFunction<unknown, never> {\r\n  return operate((source, subscriber) => {\r\n    source.subscribe(createOperatorSubscriber(subscriber, noop));\r\n  });\r\n}\r\n", "import { OperatorFunction } from '../types';\r\nimport { map } from './map';\r\n\r\n/** @deprecated To be removed in v9. Use {@link map} instead: `map(() => value)`. */\r\nexport function mapTo<R>(value: R): OperatorFunction<unknown, R>;\r\n/**\r\n * @deprecated Do not specify explicit type parameters. Signatures with type parameters\r\n * that cannot be inferred will be removed in v8. `mapTo` itself will be removed in v9,\r\n * use {@link map} instead: `map(() => value)`.\r\n * */\r\nexport function mapTo<T, R>(value: R): OperatorFunction<T, R>;\r\n\r\n/**\r\n * Emits the given constant value on the output Observable every time the source\r\n * Observable emits a value.\r\n *\r\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\r\n * the same output value every time.</span>\r\n *\r\n * ![](mapTo.png)\r\n *\r\n * Takes a constant `value` as argument, and emits that whenever the source\r\n * Observable emits a value. In other words, ignores the actual source value,\r\n * and simply uses the emission moment to know when to emit the given `value`.\r\n *\r\n * ## Example\r\n *\r\n * Map every click to the string `'Hi'`\r\n *\r\n * ```ts\r\n * import { fromEvent, mapTo } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const greetings = clicks.pipe(mapTo('Hi'));\r\n *\r\n * greetings.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link map}\r\n *\r\n * @param value The value to map each source value to.\r\n * @return A function that returns an Observable that emits the given `value`\r\n * every time the source Observable emits.\r\n * @deprecated To be removed in v9. Use {@link map} instead: `map(() => value)`.\r\n */\r\nexport function mapTo<R>(value: R): OperatorFunction<unknown, R> {\r\n  return map(() => value);\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\r\nimport { concat } from '../observable/concat';\r\nimport { take } from './take';\r\nimport { ignoreElements } from './ignoreElements';\r\nimport { mapTo } from './mapTo';\r\nimport { mergeMap } from './mergeMap';\r\nimport { innerFrom } from '../observable/innerFrom';\r\n\r\n/** @deprecated The `subscriptionDelay` parameter will be removed in v8. */\r\nexport function delayWhen<T>(\r\n  delayDurationSelector: (value: T, index: number) => ObservableInput<any>,\r\n  subscriptionDelay: Observable<any>\r\n): MonoTypeOperatorFunction<T>;\r\nexport function delayWhen<T>(delayDurationSelector: (value: T, index: number) => ObservableInput<any>): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * Delays the emission of items from the source Observable by a given time span\r\n * determined by the emissions of another Observable.\r\n *\r\n * <span class=\"informal\">It's like {@link delay}, but the time span of the\r\n * delay duration is determined by a second Observable.</span>\r\n *\r\n * ![](delayWhen.png)\r\n *\r\n * `delayWhen` operator shifts each emitted value from the source Observable by\r\n * a time span determined by another Observable. When the source emits a value,\r\n * the `delayDurationSelector` function is called with the value emitted from\r\n * the source Observable as the first argument to the `delayDurationSelector`.\r\n * The `delayDurationSelector` function should return an {@link ObservableInput},\r\n * that is internally converted to an Observable that is called the \"duration\"\r\n * Observable.\r\n *\r\n * The source value is emitted on the output Observable only when the \"duration\"\r\n * Observable emits ({@link guide/glossary-and-semantics#next next}s) any value.\r\n * Upon that, the \"duration\" Observable gets unsubscribed.\r\n *\r\n * Before RxJS V7, the {@link guide/glossary-and-semantics#complete completion}\r\n * of the \"duration\" Observable would have been triggering the emission of the\r\n * source value to the output Observable, but with RxJS V7, this is not the case\r\n * anymore.\r\n *\r\n * Only next notifications (from the \"duration\" Observable) trigger values from\r\n * the source Observable to be passed to the output Observable. If the \"duration\"\r\n * Observable only emits the complete notification (without next), the value\r\n * emitted by the source Observable will never get to the output Observable - it\r\n * will be swallowed. If the \"duration\" Observable errors, the error will be\r\n * propagated to the output Observable.\r\n *\r\n * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\r\n * is an Observable. When `subscriptionDelay` emits its first value or\r\n * completes, the source Observable is subscribed to and starts behaving like\r\n * described in the previous paragraph. If `subscriptionDelay` is not provided,\r\n * `delayWhen` will subscribe to the source Observable as soon as the output\r\n * Observable is subscribed.\r\n *\r\n * ## Example\r\n *\r\n * Delay each click by a random amount of time, between 0 and 5 seconds\r\n *\r\n * ```ts\r\n * import { fromEvent, delayWhen, interval } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const delayedClicks = clicks.pipe(\r\n *   delayWhen(() => interval(Math.random() * 5000))\r\n * );\r\n * delayedClicks.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link delay}\r\n * @see {@link throttle}\r\n * @see {@link throttleTime}\r\n * @see {@link debounce}\r\n * @see {@link debounceTime}\r\n * @see {@link sample}\r\n * @see {@link sampleTime}\r\n * @see {@link audit}\r\n * @see {@link auditTime}\r\n *\r\n * @param delayDurationSelector A function that returns an `ObservableInput` for\r\n * each `value` emitted by the source Observable, which is then used to delay the\r\n * emission of that `value` on the output Observable until the `ObservableInput`\r\n * returned from this function emits a next value. When called, beside `value`,\r\n * this function receives a zero-based `index` of the emission order.\r\n * @param subscriptionDelay An Observable that triggers the subscription to the\r\n * source Observable once it emits any value.\r\n * @return A function that returns an Observable that delays the emissions of\r\n * the source Observable by an amount of time specified by the Observable\r\n * returned by `delayDurationSelector`.\r\n */\r\nexport function delayWhen<T>(\r\n  delayDurationSelector: (value: T, index: number) => ObservableInput<any>,\r\n  subscriptionDelay?: Observable<any>\r\n): MonoTypeOperatorFunction<T> {\r\n  if (subscriptionDelay) {\r\n    // DEPRECATED PATH\r\n    return (source: Observable<T>) =>\r\n      concat(subscriptionDelay.pipe(take(1), ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));\r\n  }\r\n\r\n  return mergeMap((value, index) => innerFrom(delayDurationSelector(value, index)).pipe(take(1), mapTo(value)));\r\n}\r\n", "import { asyncScheduler } from '../scheduler/async';\r\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\r\nimport { delayWhen } from './delayWhen';\r\nimport { timer } from '../observable/timer';\r\n\r\n/**\r\n * Delays the emission of items from the source Observable by a given timeout or\r\n * until a given Date.\r\n *\r\n * <span class=\"informal\">Time shifts each item by some specified amount of\r\n * milliseconds.</span>\r\n *\r\n * ![](delay.svg)\r\n *\r\n * If the delay argument is a Number, this operator time shifts the source\r\n * Observable by that amount of time expressed in milliseconds. The relative\r\n * time intervals between the values are preserved.\r\n *\r\n * If the delay argument is a Date, this operator time shifts the start of the\r\n * Observable execution until the given date occurs.\r\n *\r\n * ## Examples\r\n *\r\n * Delay each click by one second\r\n *\r\n * ```ts\r\n * import { fromEvent, delay } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const delayedClicks = clicks.pipe(delay(1000)); // each click emitted after 1 second\r\n * delayedClicks.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * Delay all clicks until a future date happens\r\n *\r\n * ```ts\r\n * import { fromEvent, delay } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const date = new Date('March 15, 2050 12:00:00'); // in the future\r\n * const delayedClicks = clicks.pipe(delay(date)); // click emitted only after that date\r\n * delayedClicks.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link delayWhen}\r\n * @see {@link throttle}\r\n * @see {@link throttleTime}\r\n * @see {@link debounce}\r\n * @see {@link debounceTime}\r\n * @see {@link sample}\r\n * @see {@link sampleTime}\r\n * @see {@link audit}\r\n * @see {@link auditTime}\r\n *\r\n * @param due The delay duration in milliseconds (a `number`) or a `Date` until\r\n * which the emission of the source items is delayed.\r\n * @param scheduler The {@link SchedulerLike} to use for managing the timers\r\n * that handle the time-shift for each item.\r\n * @return A function that returns an Observable that delays the emissions of\r\n * the source Observable by the specified timeout or Date.\r\n */\r\nexport function delay<T>(due: number | Date, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\r\n  const duration = timer(due, scheduler);\r\n  return delayWhen(() => duration);\r\n}\r\n", "import { observeNotification } from '../Notification';\r\nimport { OperatorFunction, ObservableNotification, ValueFromNotification } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Converts an Observable of {@link ObservableNotification} objects into the emissions\r\n * that they represent.\r\n *\r\n * <span class=\"informal\">Unwraps {@link ObservableNotification} objects as actual `next`,\r\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\r\n *\r\n * ![](dematerialize.png)\r\n *\r\n * `dematerialize` is assumed to operate an Observable that only emits\r\n * {@link ObservableNotification} objects as `next` emissions, and does not emit any\r\n * `error`. Such Observable is the output of a `materialize` operation. Those\r\n * notifications are then unwrapped using the metadata they contain, and emitted\r\n * as `next`, `error`, and `complete` on the output Observable.\r\n *\r\n * Use this operator in conjunction with {@link materialize}.\r\n *\r\n * ## Example\r\n *\r\n * Convert an Observable of Notifications to an actual Observable\r\n *\r\n * ```ts\r\n * import { NextNotification, ErrorNotification, of, dematerialize } from 'rxjs';\r\n *\r\n * const notifA: NextNotification<string> = { kind: 'N', value: 'A' };\r\n * const notifB: NextNotification<string> = { kind: 'N', value: 'B' };\r\n * const notifE: ErrorNotification = { kind: 'E', error: new TypeError('x.toUpperCase is not a function') };\r\n *\r\n * const materialized = of(notifA, notifB, notifE);\r\n *\r\n * const upperCase = materialized.pipe(dematerialize());\r\n * upperCase.subscribe({\r\n *   next: x => console.log(x),\r\n *   error: e => console.error(e)\r\n * });\r\n *\r\n * // Results in:\r\n * // A\r\n * // B\r\n * // TypeError: x.toUpperCase is not a function\r\n * ```\r\n *\r\n * @see {@link materialize}\r\n *\r\n * @return A function that returns an Observable that emits items and\r\n * notifications embedded in Notification objects emitted by the source\r\n * Observable.\r\n */\r\nexport function dematerialize<N extends ObservableNotification<any>>(): OperatorFunction<N, ValueFromNotification<N>> {\r\n  return operate((source, subscriber) => {\r\n    source.subscribe(createOperatorSubscriber(subscriber, (notification) => observeNotification(notification, subscriber)));\r\n  });\r\n}\r\n", "import { MonoTypeOperatorFunction, ObservableInput } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { noop } from '../util/noop';\r\nimport { innerFrom } from '../observable/innerFrom';\r\n\r\n/**\r\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\r\n *\r\n * If a `keySelector` function is provided, then it will project each value from the source observable into a new value that it will\r\n * check for equality with previously projected values. If the `keySelector` function is not provided, it will use each value from the\r\n * source observable directly with an equality check against previous values.\r\n *\r\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\r\n *\r\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\r\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\r\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\r\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\r\n *\r\n * ## Examples\r\n *\r\n * A simple example with numbers\r\n *\r\n * ```ts\r\n * import { of, distinct } from 'rxjs';\r\n *\r\n * of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)\r\n *   .pipe(distinct())\r\n *   .subscribe(x => console.log(x));\r\n *\r\n * // Outputs\r\n * // 1\r\n * // 2\r\n * // 3\r\n * // 4\r\n * ```\r\n *\r\n * An example using the `keySelector` function\r\n *\r\n * ```ts\r\n * import { of, distinct } from 'rxjs';\r\n *\r\n * of(\r\n *   { age: 4, name: 'Foo'},\r\n *   { age: 7, name: 'Bar'},\r\n *   { age: 5, name: 'Foo'}\r\n * )\r\n * .pipe(distinct(({ name }) => name))\r\n * .subscribe(x => console.log(x));\r\n *\r\n * // Outputs\r\n * // { age: 4, name: 'Foo' }\r\n * // { age: 7, name: 'Bar' }\r\n * ```\r\n * @see {@link distinctUntilChanged}\r\n * @see {@link distinctUntilKeyChanged}\r\n *\r\n * @param keySelector Optional `function` to select which value you want to check as distinct.\r\n * @param flushes Optional `ObservableInput` for flushing the internal HashSet of the operator.\r\n * @return A function that returns an Observable that emits items from the\r\n * source Observable with distinct values.\r\n */\r\nexport function distinct<T, K>(keySelector?: (value: T) => K, flushes?: ObservableInput<any>): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    const distinctKeys = new Set();\r\n    source.subscribe(\r\n      createOperatorSubscriber(subscriber, (value) => {\r\n        const key = keySelector ? keySelector(value) : value;\r\n        if (!distinctKeys.has(key)) {\r\n          distinctKeys.add(key);\r\n          subscriber.next(value);\r\n        }\r\n      })\r\n    );\r\n\r\n    flushes && innerFrom(flushes).subscribe(createOperatorSubscriber(subscriber, () => distinctKeys.clear(), noop));\r\n  });\r\n}\r\n", "import { MonoTypeOperatorFunction } from '../types';\r\nimport { identity } from '../util/identity';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\nexport function distinctUntilChanged<T>(comparator?: (previous: T, current: T) => boolean): MonoTypeOperatorFunction<T>;\r\nexport function distinctUntilChanged<T, K>(\r\n  comparator: (previous: K, current: K) => boolean,\r\n  keySelector: (value: T) => K\r\n): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * Returns a result {@link Observable} that emits all values pushed by the source observable if they\r\n * are distinct in comparison to the last value the result observable emitted.\r\n *\r\n * When provided without parameters or with the first parameter (`{@link distinctUntilChanged#comparator comparator}`),\r\n * it behaves like this:\r\n *\r\n * 1. It will always emit the first value from the source.\r\n * 2. For all subsequent values pushed by the source, they will be compared to the previously emitted values\r\n *    using the provided `comparator` or an `===` equality check.\r\n * 3. If the value pushed by the source is determined to be unequal by this check, that value is emitted and\r\n *    becomes the new \"previously emitted value\" internally.\r\n *\r\n * When the second parameter (`{@link distinctUntilChanged#keySelector keySelector}`) is provided, the behavior\r\n * changes:\r\n *\r\n * 1. It will always emit the first value from the source.\r\n * 2. The `keySelector` will be run against all values, including the first value.\r\n * 3. For all values after the first, the selected key will be compared against the key selected from\r\n *    the previously emitted value using the `comparator`.\r\n * 4. If the keys are determined to be unequal by this check, the value (not the key), is emitted\r\n *    and the selected key from that value is saved for future comparisons against other keys.\r\n *\r\n * ## Examples\r\n *\r\n * A very basic example with no `{@link distinctUntilChanged#comparator comparator}`. Note that `1` is emitted more than once,\r\n * because it's distinct in comparison to the _previously emitted_ value,\r\n * not in comparison to _all other emitted values_.\r\n *\r\n * ```ts\r\n * import { of, distinctUntilChanged } from 'rxjs';\r\n *\r\n * of(1, 1, 1, 2, 2, 2, 1, 1, 3, 3)\r\n *   .pipe(distinctUntilChanged())\r\n *   .subscribe(console.log);\r\n * // Logs: 1, 2, 1, 3\r\n * ```\r\n *\r\n * With a `{@link distinctUntilChanged#comparator comparator}`, you can do custom comparisons. Let's say\r\n * you only want to emit a value when all of its components have\r\n * changed:\r\n *\r\n * ```ts\r\n * import { of, distinctUntilChanged } from 'rxjs';\r\n *\r\n * const totallyDifferentBuilds$ = of(\r\n *   { engineVersion: '1.1.0', transmissionVersion: '1.2.0' },\r\n *   { engineVersion: '1.1.0', transmissionVersion: '1.4.0' },\r\n *   { engineVersion: '1.3.0', transmissionVersion: '1.4.0' },\r\n *   { engineVersion: '1.3.0', transmissionVersion: '1.5.0' },\r\n *   { engineVersion: '2.0.0', transmissionVersion: '1.5.0' }\r\n * ).pipe(\r\n *   distinctUntilChanged((prev, curr) => {\r\n *     return (\r\n *       prev.engineVersion === curr.engineVersion ||\r\n *       prev.transmissionVersion === curr.transmissionVersion\r\n *     );\r\n *   })\r\n * );\r\n *\r\n * totallyDifferentBuilds$.subscribe(console.log);\r\n *\r\n * // Logs:\r\n * // { engineVersion: '1.1.0', transmissionVersion: '1.2.0' }\r\n * // { engineVersion: '1.3.0', transmissionVersion: '1.4.0' }\r\n * // { engineVersion: '2.0.0', transmissionVersion: '1.5.0' }\r\n * ```\r\n *\r\n * You can also provide a custom `{@link distinctUntilChanged#comparator comparator}` to check that emitted\r\n * changes are only in one direction. Let's say you only want to get\r\n * the next record temperature:\r\n *\r\n * ```ts\r\n * import { of, distinctUntilChanged } from 'rxjs';\r\n *\r\n * const temps$ = of(30, 31, 20, 34, 33, 29, 35, 20);\r\n *\r\n * const recordHighs$ = temps$.pipe(\r\n *   distinctUntilChanged((prevHigh, temp) => {\r\n *     // If the current temp is less than\r\n *     // or the same as the previous record,\r\n *     // the record hasn't changed.\r\n *     return temp <= prevHigh;\r\n *   })\r\n * );\r\n *\r\n * recordHighs$.subscribe(console.log);\r\n * // Logs: 30, 31, 34, 35\r\n * ```\r\n *\r\n * Selecting update events only when the `updatedBy` field shows\r\n * the account changed hands.\r\n *\r\n * ```ts\r\n * import { of, distinctUntilChanged } from 'rxjs';\r\n *\r\n * // A stream of updates to a given account\r\n * const accountUpdates$ = of(\r\n *   { updatedBy: 'blesh', data: [] },\r\n *   { updatedBy: 'blesh', data: [] },\r\n *   { updatedBy: 'ncjamieson', data: [] },\r\n *   { updatedBy: 'ncjamieson', data: [] },\r\n *   { updatedBy: 'blesh', data: [] }\r\n * );\r\n *\r\n * // We only want the events where it changed hands\r\n * const changedHands$ = accountUpdates$.pipe(\r\n *   distinctUntilChanged(undefined, update => update.updatedBy)\r\n * );\r\n *\r\n * changedHands$.subscribe(console.log);\r\n * // Logs:\r\n * // { updatedBy: 'blesh', data: Array[0] }\r\n * // { updatedBy: 'ncjamieson', data: Array[0] }\r\n * // { updatedBy: 'blesh', data: Array[0] }\r\n * ```\r\n *\r\n * @see {@link distinct}\r\n * @see {@link distinctUntilKeyChanged}\r\n *\r\n * @param comparator A function used to compare the previous and current keys for\r\n * equality. Defaults to a `===` check.\r\n * @param keySelector Used to select a key value to be passed to the `comparator`.\r\n *\r\n * @return A function that returns an Observable that emits items from the\r\n * source Observable with distinct values.\r\n */\r\nexport function distinctUntilChanged<T, K>(\r\n  comparator?: (previous: K, current: K) => boolean,\r\n  keySelector: (value: T) => K = identity as (value: T) => K\r\n): MonoTypeOperatorFunction<T> {\r\n  // We've been allowing `null` do be passed as the `compare`, so we can't do\r\n  // a default value for the parameter, because that will only work\r\n  // for `undefined`.\r\n  comparator = comparator ?? defaultCompare;\r\n\r\n  return operate((source, subscriber) => {\r\n    // The previous key, used to compare against keys selected\r\n    // from new arrivals to determine \"distinctiveness\".\r\n    let previousKey: K;\r\n    // Whether or not this is the first value we've gotten.\r\n    let first = true;\r\n\r\n    source.subscribe(\r\n      createOperatorSubscriber(subscriber, (value) => {\r\n        // We always call the key selector.\r\n        const currentKey = keySelector(value);\r\n\r\n        // If it's the first value, we always emit it.\r\n        // Otherwise, we compare this key to the previous key, and\r\n        // if the comparer returns false, we emit.\r\n        if (first || !comparator!(previousKey, currentKey)) {\r\n          // Update our state *before* we emit the value\r\n          // as emission can be the source of re-entrant code\r\n          // in functional libraries like this. We only really\r\n          // need to do this if it's the first value, or if the\r\n          // key we're tracking in previous needs to change.\r\n          first = false;\r\n          previousKey = currentKey;\r\n\r\n          // Emit the value!\r\n          subscriber.next(value);\r\n        }\r\n      })\r\n    );\r\n  });\r\n}\r\n\r\nfunction defaultCompare(a: any, b: any) {\r\n  return a === b;\r\n}\r\n", "import { distinctUntilChanged } from './distinctUntilChanged';\r\nimport { MonoTypeOperatorFunction } from '../types';\r\n\r\nexport function distinctUntilKeyChanged<T>(key: keyof T): MonoTypeOperatorFunction<T>;\r\nexport function distinctUntilKeyChanged<T, K extends keyof T>(key: K, compare: (x: T[K], y: T[K]) => boolean): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * Returns an Observable that emits all items emitted by the source Observable that\r\n * are distinct by comparison from the previous item, using a property accessed by\r\n * using the key provided to check if the two items are distinct.\r\n *\r\n * If a comparator function is provided, then it will be called for each item to\r\n * test for whether that value should be emitted or not.\r\n *\r\n * If a comparator function is not provided, an equality check is used by default.\r\n *\r\n * ## Examples\r\n *\r\n * An example comparing the name of persons\r\n *\r\n * ```ts\r\n * import { of, distinctUntilKeyChanged } from 'rxjs';\r\n *\r\n * of(\r\n *   { age: 4, name: 'Foo' },\r\n *   { age: 7, name: 'Bar' },\r\n *   { age: 5, name: 'Foo' },\r\n *   { age: 6, name: 'Foo' }\r\n * ).pipe(\r\n *   distinctUntilKeyChanged('name')\r\n * )\r\n * .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * // { age: 4, name: 'Foo' }\r\n * // { age: 7, name: 'Bar' }\r\n * // { age: 5, name: 'Foo' }\r\n * ```\r\n *\r\n * An example comparing the first letters of the name\r\n *\r\n * ```ts\r\n * import { of, distinctUntilKeyChanged } from 'rxjs';\r\n *\r\n * of(\r\n *   { age: 4, name: 'Foo1' },\r\n *   { age: 7, name: 'Bar' },\r\n *   { age: 5, name: 'Foo2' },\r\n *   { age: 6, name: 'Foo3' }\r\n * ).pipe(\r\n *   distinctUntilKeyChanged('name', (x, y) => x.substring(0, 3) === y.substring(0, 3))\r\n * )\r\n * .subscribe(x => console.log(x));\r\n *\r\n * // displays:\r\n * // { age: 4, name: 'Foo1' }\r\n * // { age: 7, name: 'Bar' }\r\n * // { age: 5, name: 'Foo2' }\r\n * ```\r\n *\r\n * @see {@link distinct}\r\n * @see {@link distinctUntilChanged}\r\n *\r\n * @param key String key for object property lookup on each item.\r\n * @param compare Optional comparison function called to test if an item is distinct\r\n * from the previous item in the source.\r\n * @return A function that returns an Observable that emits items from the source\r\n * Observable with distinct values based on the key specified.\r\n */\r\nexport function distinctUntilKeyChanged<T, K extends keyof T>(\r\n  key: K,\r\n  compare?: (x: T[K], y: T[K]) => boolean\r\n): MonoTypeOperatorFunction<T> {\r\n  return distinctUntilChanged((x: T, y: T) => (compare ? compare(x[key], y[key]) : x[key] === y[key]));\r\n}\r\n", "import { EmptyError } from '../util/EmptyError';\r\nimport { MonoTypeOperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * If the source observable completes without emitting a value, it will emit\r\n * an error. The error will be created at that time by the optional\r\n * `errorFactory` argument, otherwise, the error will be {@link EmptyError}.\r\n *\r\n * ![](throwIfEmpty.png)\r\n *\r\n * ## Example\r\n *\r\n * Throw an error if the document wasn't clicked within 1 second\r\n *\r\n * ```ts\r\n * import { fromEvent, takeUntil, timer, throwIfEmpty } from 'rxjs';\r\n *\r\n * const click$ = fromEvent(document, 'click');\r\n *\r\n * click$.pipe(\r\n *   takeUntil(timer(1000)),\r\n *   throwIfEmpty(() => new Error('The document was not clicked within 1 second'))\r\n * )\r\n * .subscribe({\r\n *   next() {\r\n *    console.log('The document was clicked');\r\n *   },\r\n *   error(err) {\r\n *     console.error(err.message);\r\n *   }\r\n * });\r\n * ```\r\n *\r\n * @param errorFactory A factory function called to produce the\r\n * error to be thrown when the source observable completes without emitting a\r\n * value.\r\n * @return A function that returns an Observable that throws an error if the\r\n * source Observable completed without emitting.\r\n */\r\nexport function throwIfEmpty<T>(errorFactory: () => any = defaultErrorFactory): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    let hasValue = false;\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value) => {\r\n          hasValue = true;\r\n          subscriber.next(value);\r\n        },\r\n        () => (hasValue ? subscriber.complete() : subscriber.error(errorFactory()))\r\n      )\r\n    );\r\n  });\r\n}\r\n\r\nfunction defaultErrorFactory() {\r\n  return new EmptyError();\r\n}\r\n", "import { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\r\nimport { Observable } from '../Observable';\r\nimport { OperatorFunction } from '../types';\r\nimport { filter } from './filter';\r\nimport { throwIfEmpty } from './throwIfEmpty';\r\nimport { defaultIfEmpty } from './defaultIfEmpty';\r\nimport { take } from './take';\r\n\r\n/**\r\n * Emits the single value at the specified `index` in a sequence of emissions\r\n * from the source Observable.\r\n *\r\n * <span class=\"informal\">Emits only the i-th value, then completes.</span>\r\n *\r\n * ![](elementAt.png)\r\n *\r\n * `elementAt` returns an Observable that emits the item at the specified\r\n * `index` in the source Observable, or a default value if that `index` is out\r\n * of range and the `default` argument is provided. If the `default` argument is\r\n * not given and the `index` is out of range, the output Observable will emit an\r\n * `ArgumentOutOfRangeError` error.\r\n *\r\n * ## Example\r\n *\r\n * Emit only the third click event\r\n *\r\n * ```ts\r\n * import { fromEvent, elementAt } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(elementAt(2));\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Results in:\r\n * // click 1 = nothing\r\n * // click 2 = nothing\r\n * // click 3 = MouseEvent object logged to console\r\n * ```\r\n *\r\n * @see {@link first}\r\n * @see {@link last}\r\n * @see {@link skip}\r\n * @see {@link single}\r\n * @see {@link take}\r\n *\r\n * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\r\n * `ArgumentOutOfRangeError` to the Observer's `error` callback if `i < 0` or the\r\n * Observable has completed before emitting the i-th `next` notification.\r\n *\r\n * @param index Is the number `i` for the i-th source emission that has happened\r\n * since the subscription, starting from the number `0`.\r\n * @param defaultValue The default value returned for missing indices.\r\n * @return A function that returns an Observable that emits a single item, if\r\n * it is found. Otherwise, it will emit the default value if given. If not, it\r\n * emits an error.\r\n */\r\nexport function elementAt<T, D = T>(index: number, defaultValue?: D): OperatorFunction<T, T | D> {\r\n  if (index < 0) {\r\n    throw new ArgumentOutOfRangeError();\r\n  }\r\n  const hasDefaultValue = arguments.length >= 2;\r\n  return (source: Observable<T>) =>\r\n    source.pipe(\r\n      filter((v, i) => i === index),\r\n      take(1),\r\n      hasDefaultValue ? defaultIfEmpty(defaultValue!) : throwIfEmpty(() => new ArgumentOutOfRangeError())\r\n    );\r\n}\r\n", "/** prettier */\r\nimport { Observable } from '../Observable';\r\nimport { concat } from '../observable/concat';\r\nimport { of } from '../observable/of';\r\nimport { MonoTypeOperatorFunction, SchedulerLike, OperatorFunction, ValueFromArray } from '../types';\r\n\r\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `concatAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\r\nexport function endWith<T>(scheduler: SchedulerLike): MonoTypeOperatorFunction<T>;\r\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `concatAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\r\nexport function endWith<T, A extends unknown[] = T[]>(\r\n  ...valuesAndScheduler: [...A, SchedulerLike]\r\n): OperatorFunction<T, T | ValueFromArray<A>>;\r\n\r\nexport function endWith<T, A extends unknown[] = T[]>(...values: A): OperatorFunction<T, T | ValueFromArray<A>>;\r\n\r\n/**\r\n * Returns an observable that will emit all values from the source, then synchronously emit\r\n * the provided value(s) immediately after the source completes.\r\n *\r\n * NOTE: Passing a last argument of a Scheduler is _deprecated_, and may result in incorrect\r\n * types in TypeScript.\r\n *\r\n * This is useful for knowing when an observable ends. Particularly when paired with an\r\n * operator like {@link takeUntil}\r\n *\r\n * ![](endWith.png)\r\n *\r\n * ## Example\r\n *\r\n * Emit values to know when an interval starts and stops. The interval will\r\n * stop when a user clicks anywhere on the document.\r\n *\r\n * ```ts\r\n * import { interval, map, fromEvent, startWith, takeUntil, endWith } from 'rxjs';\r\n *\r\n * const ticker$ = interval(5000).pipe(\r\n *   map(() => 'tick')\r\n * );\r\n *\r\n * const documentClicks$ = fromEvent(document, 'click');\r\n *\r\n * ticker$.pipe(\r\n *   startWith('interval started'),\r\n *   takeUntil(documentClicks$),\r\n *   endWith('interval ended by click')\r\n * )\r\n * .subscribe(x => console.log(x));\r\n *\r\n * // Result (assuming a user clicks after 15 seconds)\r\n * // 'interval started'\r\n * // 'tick'\r\n * // 'tick'\r\n * // 'tick'\r\n * // 'interval ended by click'\r\n * ```\r\n *\r\n * @see {@link startWith}\r\n * @see {@link concat}\r\n * @see {@link takeUntil}\r\n *\r\n * @param values Items you want the modified Observable to emit last.\r\n * @return A function that returns an Observable that emits all values from the\r\n * source, then synchronously emits the provided value(s) immediately after the\r\n * source completes.\r\n */\r\nexport function endWith<T>(...values: Array<T | SchedulerLike>): MonoTypeOperatorFunction<T> {\r\n  return (source: Observable<T>) => concat(source, of(...values)) as Observable<T>;\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { Falsy, OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\nexport function every<T>(predicate: BooleanConstructor): OperatorFunction<T, Exclude<T, Falsy> extends never ? false : boolean>;\r\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\r\nexport function every<T>(\r\n  predicate: BooleanConstructor,\r\n  thisArg: any\r\n): OperatorFunction<T, Exclude<T, Falsy> extends never ? false : boolean>;\r\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\r\nexport function every<T, A>(\r\n  predicate: (this: A, value: T, index: number, source: Observable<T>) => boolean,\r\n  thisArg: A\r\n): OperatorFunction<T, boolean>;\r\nexport function every<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean): OperatorFunction<T, boolean>;\r\n\r\n/**\r\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\r\n *\r\n * <span class=\"informal\">If all values pass predicate before the source completes, emits true before completion,\r\n * otherwise emit false, then complete.</span>\r\n *\r\n * ![](every.png)\r\n *\r\n * ## Example\r\n *\r\n * A simple example emitting true if all elements are less than 5, false otherwise\r\n *\r\n * ```ts\r\n * import { of, every } from 'rxjs';\r\n *\r\n * of(1, 2, 3, 4, 5, 6)\r\n *   .pipe(every(x => x < 5))\r\n *   .subscribe(x => console.log(x)); // -> false\r\n * ```\r\n *\r\n * @param predicate A function for determining if an item meets a specified condition.\r\n * @param thisArg Optional object to use for `this` in the callback.\r\n * @return A function that returns an Observable of booleans that determines if\r\n * all items of the source Observable meet the condition specified.\r\n */\r\nexport function every<T>(\r\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\r\n  thisArg?: any\r\n): OperatorFunction<T, boolean> {\r\n  return operate((source, subscriber) => {\r\n    let index = 0;\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value) => {\r\n          if (!predicate.call(thisArg, value, index++, source)) {\r\n            subscriber.next(false);\r\n            subscriber.complete();\r\n          }\r\n        },\r\n        () => {\r\n          subscriber.next(true);\r\n          subscriber.complete();\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\r\nimport { map } from './map';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/* tslint:disable:max-line-length */\r\nexport function exhaustMap<T, O extends ObservableInput<any>>(\r\n  project: (value: T, index: number) => O\r\n): OperatorFunction<T, ObservedValueOf<O>>;\r\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\r\nexport function exhaustMap<T, O extends ObservableInput<any>>(\r\n  project: (value: T, index: number) => O,\r\n  resultSelector: undefined\r\n): OperatorFunction<T, ObservedValueOf<O>>;\r\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\r\nexport function exhaustMap<T, I, R>(\r\n  project: (value: T, index: number) => ObservableInput<I>,\r\n  resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R\r\n): OperatorFunction<T, R>;\r\n/* tslint:enable:max-line-length */\r\n\r\n/**\r\n * Projects each source value to an Observable which is merged in the output\r\n * Observable only if the previous projected Observable has completed.\r\n *\r\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\r\n * these inner Observables using {@link exhaustAll}.</span>\r\n *\r\n * ![](exhaustMap.png)\r\n *\r\n * Returns an Observable that emits items based on applying a function that you\r\n * supply to each item emitted by the source Observable, where that function\r\n * returns an (so-called \"inner\") Observable. When it projects a source value to\r\n * an Observable, the output Observable begins emitting the items emitted by\r\n * that projected Observable. However, `exhaustMap` ignores every new projected\r\n * Observable if the previous projected Observable has not yet completed. Once\r\n * that one completes, it will accept and flatten the next projected Observable\r\n * and repeat this process.\r\n *\r\n * ## Example\r\n *\r\n * Run a finite timer for each click, only if there is no currently active timer\r\n *\r\n * ```ts\r\n * import { fromEvent, exhaustMap, interval, take } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(\r\n *   exhaustMap(() => interval(1000).pipe(take(5)))\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link concatMap}\r\n * @see {@link exhaust}\r\n * @see {@link mergeMap}\r\n * @see {@link switchMap}\r\n *\r\n * @param project A function that, when applied to an item emitted by the source\r\n * Observable, returns an Observable.\r\n * @return A function that returns an Observable containing projected\r\n * Observables of each item of the source, ignoring projected Observables that\r\n * start before their preceding Observable has completed.\r\n */\r\nexport function exhaustMap<T, R, O extends ObservableInput<any>>(\r\n  project: (value: T, index: number) => O,\r\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\r\n): OperatorFunction<T, ObservedValueOf<O> | R> {\r\n  if (resultSelector) {\r\n    // DEPRECATED PATH\r\n    return (source: Observable<T>) =>\r\n      source.pipe(exhaustMap((a, i) => innerFrom(project(a, i)).pipe(map((b: any, ii: any) => resultSelector(a, b, i, ii)))));\r\n  }\r\n  return operate((source, subscriber) => {\r\n    let index = 0;\r\n    let innerSub: Subscriber<T> | null = null;\r\n    let isComplete = false;\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (outerValue) => {\r\n          if (!innerSub) {\r\n            innerSub = createOperatorSubscriber(subscriber, undefined, () => {\r\n              innerSub = null;\r\n              isComplete && subscriber.complete();\r\n            });\r\n            innerFrom(project(outerValue, index++)).subscribe(innerSub);\r\n          }\r\n        },\r\n        () => {\r\n          isComplete = true;\r\n          !innerSub && subscriber.complete();\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n", "import { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\r\nimport { exhaustMap } from './exhaustMap';\r\nimport { identity } from '../util/identity';\r\n\r\n/**\r\n * Converts a higher-order Observable into a first-order Observable by dropping\r\n * inner Observables while the previous inner Observable has not yet completed.\r\n *\r\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\r\n * next inner Observables while the current inner is still executing.</span>\r\n *\r\n * ![](exhaustAll.svg)\r\n *\r\n * `exhaustAll` subscribes to an Observable that emits Observables, also known as a\r\n * higher-order Observable. Each time it observes one of these emitted inner\r\n * Observables, the output Observable begins emitting the items emitted by that\r\n * inner Observable. So far, it behaves like {@link mergeAll}. However,\r\n * `exhaustAll` ignores every new inner Observable if the previous Observable has\r\n * not yet completed. Once that one completes, it will accept and flatten the\r\n * next inner Observable and repeat this process.\r\n *\r\n * ## Example\r\n *\r\n * Run a finite timer for each click, only if there is no currently active timer\r\n *\r\n * ```ts\r\n * import { fromEvent, map, interval, take, exhaustAll } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const higherOrder = clicks.pipe(\r\n *   map(() => interval(1000).pipe(take(5)))\r\n * );\r\n * const result = higherOrder.pipe(exhaustAll());\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link combineLatestAll}\r\n * @see {@link concatAll}\r\n * @see {@link switchAll}\r\n * @see {@link switchMap}\r\n * @see {@link mergeAll}\r\n * @see {@link exhaustMap}\r\n * @see {@link zipAll}\r\n *\r\n * @return A function that returns an Observable that takes a source of\r\n * Observables and propagates the first Observable exclusively until it\r\n * completes before subscribing to the next.\r\n */\r\nexport function exhaustAll<O extends ObservableInput<any>>(): OperatorFunction<O, ObservedValueOf<O>> {\r\n  return exhaustMap(identity);\r\n}\r\n", "import { exhaustAll } from './exhaustAll';\r\n\r\n/**\r\n * @deprecated Renamed to {@link exhaustAll}. Will be removed in v8.\r\n */\r\nexport const exhaust = exhaustAll;\r\n", "import { OperatorFunction, ObservableInput, ObservedValueOf, SchedulerLike } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { mergeInternals } from './mergeInternals';\r\n\r\n/* tslint:disable:max-line-length */\r\nexport function expand<T, O extends ObservableInput<unknown>>(\r\n  project: (value: T, index: number) => O,\r\n  concurrent?: number,\r\n  scheduler?: SchedulerLike\r\n): OperatorFunction<T, ObservedValueOf<O>>;\r\n/**\r\n * @deprecated The `scheduler` parameter will be removed in v8. If you need to schedule the inner subscription,\r\n * use `subscribeOn` within the projection function: `expand((value) => fn(value).pipe(subscribeOn(scheduler)))`.\r\n * Details: Details: https://rxjs.dev/deprecations/scheduler-argument\r\n */\r\nexport function expand<T, O extends ObservableInput<unknown>>(\r\n  project: (value: T, index: number) => O,\r\n  concurrent: number | undefined,\r\n  scheduler: SchedulerLike\r\n): OperatorFunction<T, ObservedValueOf<O>>;\r\n/* tslint:enable:max-line-length */\r\n\r\n/**\r\n * Recursively projects each source value to an Observable which is merged in\r\n * the output Observable.\r\n *\r\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\r\n * projection function to every source value as well as every output value.\r\n * It's recursive.</span>\r\n *\r\n * ![](expand.png)\r\n *\r\n * Returns an Observable that emits items based on applying a function that you\r\n * supply to each item emitted by the source Observable, where that function\r\n * returns an Observable, and then merging those resulting Observables and\r\n * emitting the results of this merger. *Expand* will re-emit on the output\r\n * Observable every source value. Then, each output value is given to the\r\n * `project` function which returns an inner Observable to be merged on the\r\n * output Observable. Those output values resulting from the projection are also\r\n * given to the `project` function to produce new output values. This is how\r\n * *expand* behaves recursively.\r\n *\r\n * ## Example\r\n *\r\n * Start emitting the powers of two on every click, at most 10 of them\r\n *\r\n * ```ts\r\n * import { fromEvent, map, expand, of, delay, take } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const powersOfTwo = clicks.pipe(\r\n *   map(() => 1),\r\n *   expand(x => of(2 * x).pipe(delay(1000))),\r\n *   take(10)\r\n * );\r\n * powersOfTwo.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link mergeMap}\r\n * @see {@link mergeScan}\r\n *\r\n * @param project A function that, when applied to an item emitted by the source\r\n * or the output Observable, returns an Observable.\r\n * @param concurrent Maximum number of input Observables being subscribed to\r\n * concurrently.\r\n * @param scheduler The {@link SchedulerLike} to use for subscribing to\r\n * each projected inner Observable.\r\n * @return A function that returns an Observable that emits the source values\r\n * and also result of applying the projection function to each value emitted on\r\n * the output Observable and merging the results of the Observables obtained\r\n * from this transformation.\r\n */\r\nexport function expand<T, O extends ObservableInput<unknown>>(\r\n  project: (value: T, index: number) => O,\r\n  concurrent = Infinity,\r\n  scheduler?: SchedulerLike\r\n): OperatorFunction<T, ObservedValueOf<O>> {\r\n  concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;\r\n  return operate((source, subscriber) =>\r\n    mergeInternals(\r\n      // General merge params\r\n      source,\r\n      subscriber,\r\n      project,\r\n      concurrent,\r\n\r\n      // onBeforeNext\r\n      undefined,\r\n\r\n      // Expand-specific\r\n      true, // Use expand path\r\n      scheduler // Inner subscription scheduler\r\n    )\r\n  );\r\n}\r\n", "import { MonoTypeOperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\n\r\n/**\r\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\r\n * the source terminates on complete or error.\r\n * The specified function will also be called when the subscriber explicitly unsubscribes.\r\n *\r\n * ## Examples\r\n *\r\n * Execute callback function when the observable completes\r\n *\r\n * ```ts\r\n * import { interval, take, finalize } from 'rxjs';\r\n *\r\n * // emit value in sequence every 1 second\r\n * const source = interval(1000);\r\n * const example = source.pipe(\r\n *   take(5), //take only the first 5 values\r\n *   finalize(() => console.log('Sequence complete')) // Execute when the observable completes\r\n * );\r\n * const subscribe = example.subscribe(val => console.log(val));\r\n *\r\n * // results:\r\n * // 0\r\n * // 1\r\n * // 2\r\n * // 3\r\n * // 4\r\n * // 'Sequence complete'\r\n * ```\r\n *\r\n * Execute callback function when the subscriber explicitly unsubscribes\r\n *\r\n * ```ts\r\n * import { interval, finalize, tap, noop, timer } from 'rxjs';\r\n *\r\n * const source = interval(100).pipe(\r\n *   finalize(() => console.log('[finalize] Called')),\r\n *   tap({\r\n *     next: () => console.log('[next] Called'),\r\n *     error: () => console.log('[error] Not called'),\r\n *     complete: () => console.log('[tap complete] Not called')\r\n *   })\r\n * );\r\n *\r\n * const sub = source.subscribe({\r\n *   next: x => console.log(x),\r\n *   error: noop,\r\n *   complete: () => console.log('[complete] Not called')\r\n * });\r\n *\r\n * timer(150).subscribe(() => sub.unsubscribe());\r\n *\r\n * // results:\r\n * // '[next] Called'\r\n * // 0\r\n * // '[finalize] Called'\r\n * ```\r\n *\r\n * @param callback Function to be called when source terminates.\r\n * @return A function that returns an Observable that mirrors the source, but\r\n * will call the specified function on termination.\r\n */\r\nexport function finalize<T>(callback: () => void): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    // TODO: This try/finally was only added for `useDeprecatedSynchronousErrorHandling`.\r\n    // REMOVE THIS WHEN THAT HOT GARBAGE IS REMOVED IN V8.\r\n    try {\r\n      source.subscribe(subscriber);\r\n    } finally {\r\n      subscriber.add(callback);\r\n    }\r\n  });\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { OperatorFunction, TruthyTypesOf } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\nexport function find<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\r\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\r\nexport function find<T, S extends T, A>(\r\n  predicate: (this: A, value: T, index: number, source: Observable<T>) => value is S,\r\n  thisArg: A\r\n): OperatorFunction<T, S | undefined>;\r\nexport function find<T, S extends T>(\r\n  predicate: (value: T, index: number, source: Observable<T>) => value is S\r\n): OperatorFunction<T, S | undefined>;\r\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\r\nexport function find<T, A>(\r\n  predicate: (this: A, value: T, index: number, source: Observable<T>) => boolean,\r\n  thisArg: A\r\n): OperatorFunction<T, T | undefined>;\r\nexport function find<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean): OperatorFunction<T, T | undefined>;\r\n/**\r\n * Emits only the first value emitted by the source Observable that meets some\r\n * condition.\r\n *\r\n * <span class=\"informal\">Finds the first value that passes some test and emits\r\n * that.</span>\r\n *\r\n * ![](find.png)\r\n *\r\n * `find` searches for the first item in the source Observable that matches the\r\n * specified condition embodied by the `predicate`, and returns the first\r\n * occurrence in the source. Unlike {@link first}, the `predicate` is required\r\n * in `find`, and does not emit an error if a valid value is not found\r\n * (emits `undefined` instead).\r\n *\r\n * ## Example\r\n *\r\n * Find and emit the first click that happens on a DIV element\r\n *\r\n * ```ts\r\n * import { fromEvent, find } from 'rxjs';\r\n *\r\n * const div = document.createElement('div');\r\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\r\n * document.body.appendChild(div);\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(find(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link filter}\r\n * @see {@link first}\r\n * @see {@link findIndex}\r\n * @see {@link take}\r\n *\r\n * @param predicate A function called with each item to test for condition matching.\r\n * @param thisArg An optional argument to determine the value of `this` in the\r\n * `predicate` function.\r\n * @return A function that returns an Observable that emits the first item that\r\n * matches the condition.\r\n */\r\nexport function find<T>(\r\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\r\n  thisArg?: any\r\n): OperatorFunction<T, T | undefined> {\r\n  return operate(createFind(predicate, thisArg, 'value'));\r\n}\r\n\r\nexport function createFind<T>(\r\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\r\n  thisArg: any,\r\n  emit: 'value' | 'index'\r\n) {\r\n  const findIndex = emit === 'index';\r\n  return (source: Observable<T>, subscriber: Subscriber<any>) => {\r\n    let index = 0;\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value) => {\r\n          const i = index++;\r\n          if (predicate.call(thisArg, value, i, source)) {\r\n            subscriber.next(findIndex ? i : value);\r\n            subscriber.complete();\r\n          }\r\n        },\r\n        () => {\r\n          subscriber.next(findIndex ? -1 : undefined);\r\n          subscriber.complete();\r\n        }\r\n      )\r\n    );\r\n  };\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { Falsy, OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createFind } from './find';\r\n\r\nexport function findIndex<T>(predicate: BooleanConstructor): OperatorFunction<T, T extends Falsy ? -1 : number>;\r\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\r\nexport function findIndex<T>(predicate: BooleanConstructor, thisArg: any): OperatorFunction<T, T extends Falsy ? -1 : number>;\r\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\r\nexport function findIndex<T, A>(\r\n  predicate: (this: A, value: T, index: number, source: Observable<T>) => boolean,\r\n  thisArg: A\r\n): OperatorFunction<T, number>;\r\nexport function findIndex<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean): OperatorFunction<T, number>;\r\n\r\n/**\r\n * Emits only the index of the first value emitted by the source Observable that\r\n * meets some condition.\r\n *\r\n * <span class=\"informal\">It's like {@link find}, but emits the index of the\r\n * found value, not the value itself.</span>\r\n *\r\n * ![](findIndex.png)\r\n *\r\n * `findIndex` searches for the first item in the source Observable that matches\r\n * the specified condition embodied by the `predicate`, and returns the\r\n * (zero-based) index of the first occurrence in the source. Unlike\r\n * {@link first}, the `predicate` is required in `findIndex`, and does not emit\r\n * an error if a valid value is not found.\r\n *\r\n * ## Example\r\n *\r\n * Emit the index of first click that happens on a DIV element\r\n *\r\n * ```ts\r\n * import { fromEvent, findIndex } from 'rxjs';\r\n *\r\n * const div = document.createElement('div');\r\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\r\n * document.body.appendChild(div);\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(findIndex(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link filter}\r\n * @see {@link find}\r\n * @see {@link first}\r\n * @see {@link take}\r\n *\r\n * @param predicate A function called with each item to test for condition matching.\r\n * @param thisArg An optional argument to determine the value of `this` in the\r\n * `predicate` function.\r\n * @return A function that returns an Observable that emits the index of the\r\n * first item that matches the condition.\r\n */\r\nexport function findIndex<T>(\r\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\r\n  thisArg?: any\r\n): OperatorFunction<T, number> {\r\n  return operate(createFind(predicate, thisArg, 'index'));\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { EmptyError } from '../util/EmptyError';\r\nimport { OperatorFunction, TruthyTypesOf } from '../types';\r\nimport { filter } from './filter';\r\nimport { take } from './take';\r\nimport { defaultIfEmpty } from './defaultIfEmpty';\r\nimport { throwIfEmpty } from './throwIfEmpty';\r\nimport { identity } from '../util/identity';\r\n\r\nexport function first<T, D = T>(predicate?: null, defaultValue?: D): OperatorFunction<T, T | D>;\r\nexport function first<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\r\nexport function first<T, D>(predicate: BooleanConstructor, defaultValue: D): OperatorFunction<T, TruthyTypesOf<T> | D>;\r\nexport function first<T, S extends T>(\r\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\r\n  defaultValue?: S\r\n): OperatorFunction<T, S>;\r\nexport function first<T, S extends T, D>(\r\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\r\n  defaultValue: D\r\n): OperatorFunction<T, S | D>;\r\nexport function first<T, D = T>(\r\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\r\n  defaultValue?: D\r\n): OperatorFunction<T, T | D>;\r\n\r\n/**\r\n * Emits only the first value (or the first value that meets some condition)\r\n * emitted by the source Observable.\r\n *\r\n * <span class=\"informal\">Emits only the first value. Or emits only the first\r\n * value that passes some test.</span>\r\n *\r\n * ![](first.png)\r\n *\r\n * If called with no arguments, `first` emits the first value of the source\r\n * Observable, then completes. If called with a `predicate` function, `first`\r\n * emits the first value of the source that matches the specified condition. Emits an error\r\n * notification if `defaultValue` was not provided and a matching element is not found.\r\n *\r\n * ## Examples\r\n *\r\n * Emit only the first click that happens on the DOM\r\n *\r\n * ```ts\r\n * import { fromEvent, first } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(first());\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * Emits the first click that happens on a DIV\r\n *\r\n * ```ts\r\n * import { fromEvent, first } from 'rxjs';\r\n *\r\n * const div = document.createElement('div');\r\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\r\n * document.body.appendChild(div);\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(first(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link filter}\r\n * @see {@link find}\r\n * @see {@link take}\r\n * @see {@link last}\r\n *\r\n * @throws {EmptyError} Delivers an `EmptyError` to the Observer's `error`\r\n * callback if the Observable completes before any `next` notification was sent.\r\n * This is how `first()` is different from `take(1)` which completes instead.\r\n *\r\n * @param predicate An optional function called with each item to test for condition\r\n * matching.\r\n * @param defaultValue The default value emitted in case no valid value was found on\r\n * the source.\r\n * @return A function that returns an Observable that emits the first item that\r\n * matches the condition.\r\n */\r\nexport function first<T, D>(\r\n  predicate?: ((value: T, index: number, source: Observable<T>) => boolean) | null,\r\n  defaultValue?: D\r\n): OperatorFunction<T, T | D> {\r\n  const hasDefaultValue = arguments.length >= 2;\r\n  return (source: Observable<T>) =>\r\n    source.pipe(\r\n      predicate ? filter((v, i) => predicate(v, i, source)) : identity,\r\n      take(1),\r\n      hasDefaultValue ? defaultIfEmpty(defaultValue!) : throwIfEmpty(() => new EmptyError())\r\n    );\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { Subject } from '../Subject';\r\nimport { ObservableInput, Observer, OperatorFunction, SubjectLike } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber, OperatorSubscriber } from './OperatorSubscriber';\r\n\r\nexport interface BasicGroupByOptions<K, T> {\r\n  element?: undefined;\r\n  duration?: (grouped: GroupedObservable<K, T>) => ObservableInput<any>;\r\n  connector?: () => SubjectLike<T>;\r\n}\r\n\r\nexport interface GroupByOptionsWithElement<K, E, T> {\r\n  element: (value: T) => E;\r\n  duration?: (grouped: GroupedObservable<K, E>) => ObservableInput<any>;\r\n  connector?: () => SubjectLike<E>;\r\n}\r\n\r\nexport function groupBy<T, K>(key: (value: T) => K, options: BasicGroupByOptions<K, T>): OperatorFunction<T, GroupedObservable<K, T>>;\r\n\r\nexport function groupBy<T, K, E>(\r\n  key: (value: T) => K,\r\n  options: GroupByOptionsWithElement<K, E, T>\r\n): OperatorFunction<T, GroupedObservable<K, E>>;\r\n\r\nexport function groupBy<T, K extends T>(\r\n  key: (value: T) => value is K\r\n): OperatorFunction<T, GroupedObservable<true, K> | GroupedObservable<false, Exclude<T, K>>>;\r\n\r\nexport function groupBy<T, K>(key: (value: T) => K): OperatorFunction<T, GroupedObservable<K, T>>;\r\n\r\n/**\r\n * @deprecated use the options parameter instead.\r\n */\r\nexport function groupBy<T, K>(\r\n  key: (value: T) => K,\r\n  element: void,\r\n  duration: (grouped: GroupedObservable<K, T>) => Observable<any>\r\n): OperatorFunction<T, GroupedObservable<K, T>>;\r\n\r\n/**\r\n * @deprecated use the options parameter instead.\r\n */\r\nexport function groupBy<T, K, R>(\r\n  key: (value: T) => K,\r\n  element?: (value: T) => R,\r\n  duration?: (grouped: GroupedObservable<K, R>) => Observable<any>\r\n): OperatorFunction<T, GroupedObservable<K, R>>;\r\n\r\n/**\r\n * Groups the items emitted by an Observable according to a specified criterion,\r\n * and emits these grouped items as `GroupedObservables`, one\r\n * {@link GroupedObservable} per group.\r\n *\r\n * ![](groupBy.png)\r\n *\r\n * When the Observable emits an item, a key is computed for this item with the key function.\r\n *\r\n * If a {@link GroupedObservable} for this key exists, this {@link GroupedObservable} emits. Otherwise, a new\r\n * {@link GroupedObservable} for this key is created and emits.\r\n *\r\n * A {@link GroupedObservable} represents values belonging to the same group represented by a common key. The common\r\n * key is available as the `key` field of a {@link GroupedObservable} instance.\r\n *\r\n * The elements emitted by {@link GroupedObservable}s are by default the items emitted by the Observable, or elements\r\n * returned by the element function.\r\n *\r\n * ## Examples\r\n *\r\n * Group objects by `id` and return as array\r\n *\r\n * ```ts\r\n * import { of, groupBy, mergeMap, reduce } from 'rxjs';\r\n *\r\n * of(\r\n *   { id: 1, name: 'JavaScript' },\r\n *   { id: 2, name: 'Parcel' },\r\n *   { id: 2, name: 'webpack' },\r\n *   { id: 1, name: 'TypeScript' },\r\n *   { id: 3, name: 'TSLint' }\r\n * ).pipe(\r\n *   groupBy(p => p.id),\r\n *   mergeMap(group$ => group$.pipe(reduce((acc, cur) => [...acc, cur], [])))\r\n * )\r\n * .subscribe(p => console.log(p));\r\n *\r\n * // displays:\r\n * // [{ id: 1, name: 'JavaScript' }, { id: 1, name: 'TypeScript'}]\r\n * // [{ id: 2, name: 'Parcel' }, { id: 2, name: 'webpack'}]\r\n * // [{ id: 3, name: 'TSLint' }]\r\n * ```\r\n *\r\n * Pivot data on the `id` field\r\n *\r\n * ```ts\r\n * import { of, groupBy, mergeMap, reduce, map } from 'rxjs';\r\n *\r\n * of(\r\n *   { id: 1, name: 'JavaScript' },\r\n *   { id: 2, name: 'Parcel' },\r\n *   { id: 2, name: 'webpack' },\r\n *   { id: 1, name: 'TypeScript' },\r\n *   { id: 3, name: 'TSLint' }\r\n * ).pipe(\r\n *   groupBy(p => p.id, { element: p => p.name }),\r\n *   mergeMap(group$ => group$.pipe(reduce((acc, cur) => [...acc, cur], [`${ group$.key }`]))),\r\n *   map(arr => ({ id: parseInt(arr[0], 10), values: arr.slice(1) }))\r\n * )\r\n * .subscribe(p => console.log(p));\r\n *\r\n * // displays:\r\n * // { id: 1, values: [ 'JavaScript', 'TypeScript' ] }\r\n * // { id: 2, values: [ 'Parcel', 'webpack' ] }\r\n * // { id: 3, values: [ 'TSLint' ] }\r\n * ```\r\n *\r\n * @param key A function that extracts the key\r\n * for each item.\r\n * @param element A function that extracts the\r\n * return element for each item.\r\n * @param duration\r\n * A function that returns an Observable to determine how long each group should\r\n * exist.\r\n * @param connector Factory function to create an\r\n * intermediate Subject through which grouped elements are emitted.\r\n * @return A function that returns an Observable that emits GroupedObservables,\r\n * each of which corresponds to a unique key value and each of which emits\r\n * those items from the source Observable that share that key value.\r\n *\r\n * @deprecated Use the options parameter instead.\r\n */\r\nexport function groupBy<T, K, R>(\r\n  key: (value: T) => K,\r\n  element?: (value: T) => R,\r\n  duration?: (grouped: GroupedObservable<K, R>) => Observable<any>,\r\n  connector?: () => Subject<R>\r\n): OperatorFunction<T, GroupedObservable<K, R>>;\r\n\r\n// Impl\r\nexport function groupBy<T, K, R>(\r\n  keySelector: (value: T) => K,\r\n  elementOrOptions?: ((value: any) => any) | void | BasicGroupByOptions<K, T> | GroupByOptionsWithElement<K, R, T>,\r\n  duration?: (grouped: GroupedObservable<any, any>) => ObservableInput<any>,\r\n  connector?: () => SubjectLike<any>\r\n): OperatorFunction<T, GroupedObservable<K, R>> {\r\n  return operate((source, subscriber) => {\r\n    let element: ((value: any) => any) | void;\r\n    if (!elementOrOptions || typeof elementOrOptions === 'function') {\r\n      element = elementOrOptions as ((value: any) => any);\r\n    } else {\r\n      ({ duration, element, connector } = elementOrOptions);\r\n    }\r\n\r\n    // A lookup for the groups that we have so far.\r\n    const groups = new Map<K, SubjectLike<any>>();\r\n\r\n    // Used for notifying all groups and the subscriber in the same way.\r\n    const notify = (cb: (group: Observer<any>) => void) => {\r\n      groups.forEach(cb);\r\n      cb(subscriber);\r\n    };\r\n\r\n    // Used to handle errors from the source, AND errors that occur during the\r\n    // next call from the source.\r\n    const handleError = (err: any) => notify((consumer) => consumer.error(err));\r\n\r\n    // The number of actively subscribed groups\r\n    let activeGroups = 0;\r\n\r\n    // Whether or not teardown was attempted on this subscription.\r\n    let teardownAttempted = false;\r\n\r\n    // Capturing a reference to this, because we need a handle to it\r\n    // in `createGroupedObservable` below. This is what we use to\r\n    // subscribe to our source observable. This sometimes needs to be unsubscribed\r\n    // out-of-band with our `subscriber` which is the downstream subscriber, or destination,\r\n    // in cases where a user unsubscribes from the main resulting subscription, but\r\n    // still has groups from this subscription subscribed and would expect values from it\r\n    // Consider:  `source.pipe(groupBy(fn), take(2))`.\r\n    const groupBySourceSubscriber = new OperatorSubscriber(\r\n      subscriber,\r\n      (value: T) => {\r\n        // Because we have to notify all groups of any errors that occur in here,\r\n        // we have to add our own try/catch to ensure that those errors are propagated.\r\n        // OperatorSubscriber will only send the error to the main subscriber.\r\n        try {\r\n          const key = keySelector(value);\r\n\r\n          let group = groups.get(key);\r\n          if (!group) {\r\n            // Create our group subject\r\n            groups.set(key, (group = connector ? connector() : new Subject<any>()));\r\n\r\n            // Emit the grouped observable. Note that we can't do a simple `asObservable()` here,\r\n            // because the grouped observable has special semantics around reference counting\r\n            // to ensure we don't sever our connection to the source prematurely.\r\n            const grouped = createGroupedObservable(key, group);\r\n            subscriber.next(grouped);\r\n\r\n            if (duration) {\r\n              const durationSubscriber = createOperatorSubscriber(\r\n                // Providing the group here ensures that it is disposed of -- via `unsubscribe` --\r\n                // when the duration subscription is torn down. That is important, because then\r\n                // if someone holds a handle to the grouped observable and tries to subscribe to it\r\n                // after the connection to the source has been severed, they will get an\r\n                // `ObjectUnsubscribedError` and know they can't possibly get any notifications.\r\n                group as any,\r\n                () => {\r\n                  // Our duration notified! We can complete the group.\r\n                  // The group will be removed from the map in the finalization phase.\r\n                  group!.complete();\r\n                  durationSubscriber?.unsubscribe();\r\n                },\r\n                // Completions are also sent to the group, but just the group.\r\n                undefined,\r\n                // Errors on the duration subscriber are sent to the group\r\n                // but only the group. They are not sent to the main subscription.\r\n                undefined,\r\n                // Finalization: Remove this group from our map.\r\n                () => groups.delete(key)\r\n              );\r\n\r\n              // Start our duration notifier.\r\n              groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber));\r\n            }\r\n          }\r\n\r\n          // Send the value to our group.\r\n          group.next(element ? element(value) : value);\r\n        } catch (err) {\r\n          handleError(err);\r\n        }\r\n      },\r\n      // Source completes.\r\n      () => notify((consumer) => consumer.complete()),\r\n      // Error from the source.\r\n      handleError,\r\n      // Free up memory.\r\n      // When the source subscription is _finally_ torn down, release the subjects and keys\r\n      // in our groups Map, they may be quite large and we don't want to keep them around if we\r\n      // don't have to.\r\n      () => groups.clear(),\r\n      () => {\r\n        teardownAttempted = true;\r\n        // We only kill our subscription to the source if we have\r\n        // no active groups. As stated above, consider this scenario:\r\n        // source$.pipe(groupBy(fn), take(2)).\r\n        return activeGroups === 0;\r\n      }\r\n    );\r\n\r\n    // Subscribe to the source\r\n    source.subscribe(groupBySourceSubscriber);\r\n\r\n    /**\r\n     * Creates the actual grouped observable returned.\r\n     * @param key The key of the group\r\n     * @param groupSubject The subject that fuels the group\r\n     */\r\n    function createGroupedObservable(key: K, groupSubject: SubjectLike<any>) {\r\n      const result: any = new Observable<T>((groupSubscriber) => {\r\n        activeGroups++;\r\n        const innerSub = groupSubject.subscribe(groupSubscriber);\r\n        return () => {\r\n          innerSub.unsubscribe();\r\n          // We can kill the subscription to our source if we now have no more\r\n          // active groups subscribed, and a finalization was already attempted on\r\n          // the source.\r\n          --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();\r\n        };\r\n      });\r\n      result.key = key;\r\n      return result;\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * An observable of values that is the emitted by the result of a {@link groupBy} operator,\r\n * contains a `key` property for the grouping.\r\n */\r\nexport interface GroupedObservable<K, T> extends Observable<T> {\r\n  /**\r\n   * The key value for the grouped notifications.\r\n   */\r\n  readonly key: K;\r\n}\r\n", "import { OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Emits `false` if the input Observable emits any values, or emits `true` if the\r\n * input Observable completes without emitting any values.\r\n *\r\n * <span class=\"informal\">Tells whether any values are emitted by an Observable.</span>\r\n *\r\n * ![](isEmpty.png)\r\n *\r\n * `isEmpty` transforms an Observable that emits values into an Observable that\r\n * emits a single boolean value representing whether or not any values were\r\n * emitted by the source Observable. As soon as the source Observable emits a\r\n * value, `isEmpty` will emit a `false` and complete.  If the source Observable\r\n * completes having not emitted anything, `isEmpty` will emit a `true` and\r\n * complete.\r\n *\r\n * A similar effect could be achieved with {@link count}, but `isEmpty` can emit\r\n * a `false` value sooner.\r\n *\r\n * ## Examples\r\n *\r\n * Emit `false` for a non-empty Observable\r\n *\r\n * ```ts\r\n * import { Subject, isEmpty } from 'rxjs';\r\n *\r\n * const source = new Subject<string>();\r\n * const result = source.pipe(isEmpty());\r\n *\r\n * source.subscribe(x => console.log(x));\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * source.next('a');\r\n * source.next('b');\r\n * source.next('c');\r\n * source.complete();\r\n *\r\n * // Outputs\r\n * // 'a'\r\n * // false\r\n * // 'b'\r\n * // 'c'\r\n * ```\r\n *\r\n * Emit `true` for an empty Observable\r\n *\r\n * ```ts\r\n * import { EMPTY, isEmpty } from 'rxjs';\r\n *\r\n * const result = EMPTY.pipe(isEmpty());\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Outputs\r\n * // true\r\n * ```\r\n *\r\n * @see {@link count}\r\n * @see {@link EMPTY}\r\n *\r\n * @return A function that returns an Observable that emits boolean value\r\n * indicating whether the source Observable was empty or not.\r\n */\r\nexport function isEmpty<T>(): OperatorFunction<T, boolean> {\r\n  return operate((source, subscriber) => {\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        () => {\r\n          subscriber.next(false);\r\n          subscriber.complete();\r\n        },\r\n        () => {\r\n          subscriber.next(true);\r\n          subscriber.complete();\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n", "import { EMPTY } from '../observable/empty';\r\nimport { MonoTypeOperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Waits for the source to complete, then emits the last N values from the source,\r\n * as specified by the `count` argument.\r\n *\r\n * ![](takeLast.png)\r\n *\r\n * `takeLast` results in an observable that will hold values up to `count` values in memory,\r\n * until the source completes. It then pushes all values in memory to the consumer, in the\r\n * order they were received from the source, then notifies the consumer that it is\r\n * complete.\r\n *\r\n * If for some reason the source completes before the `count` supplied to `takeLast` is reached,\r\n * all values received until that point are emitted, and then completion is notified.\r\n *\r\n * **Warning**: Using `takeLast` with an observable that never completes will result\r\n * in an observable that never emits a value.\r\n *\r\n * ## Example\r\n *\r\n * Take the last 3 values of an Observable with many values\r\n *\r\n * ```ts\r\n * import { range, takeLast } from 'rxjs';\r\n *\r\n * const many = range(1, 100);\r\n * const lastThree = many.pipe(takeLast(3));\r\n * lastThree.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link take}\r\n * @see {@link takeUntil}\r\n * @see {@link takeWhile}\r\n * @see {@link skip}\r\n *\r\n * @param count The maximum number of values to emit from the end of\r\n * the sequence of values emitted by the source Observable.\r\n * @return A function that returns an Observable that emits at most the last\r\n * `count` values emitted by the source Observable.\r\n */\r\nexport function takeLast<T>(count: number): MonoTypeOperatorFunction<T> {\r\n  return count <= 0\r\n    ? () => EMPTY\r\n    : operate((source, subscriber) => {\r\n        // This buffer will hold the values we are going to emit\r\n        // when the source completes. Since we only want to take the\r\n        // last N values, we can't emit until we're sure we're not getting\r\n        // any more values.\r\n        let buffer: T[] = [];\r\n        source.subscribe(\r\n          createOperatorSubscriber(\r\n            subscriber,\r\n            (value) => {\r\n              // Add the most recent value onto the end of our buffer.\r\n              buffer.push(value);\r\n              // If our buffer is now larger than the number of values we\r\n              // want to take, we remove the oldest value from the buffer.\r\n              count < buffer.length && buffer.shift();\r\n            },\r\n            () => {\r\n              // The source completed, we now know what are last values\r\n              // are, emit them in the order they were received.\r\n              for (const value of buffer) {\r\n                subscriber.next(value);\r\n              }\r\n              subscriber.complete();\r\n            },\r\n            // Errors are passed through to the consumer\r\n            undefined,\r\n            () => {\r\n              // During finalization release the values in our buffer.\r\n              buffer = null!;\r\n            }\r\n          )\r\n        );\r\n      });\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { EmptyError } from '../util/EmptyError';\r\nimport { OperatorFunction, TruthyTypesOf } from '../types';\r\nimport { filter } from './filter';\r\nimport { takeLast } from './takeLast';\r\nimport { throwIfEmpty } from './throwIfEmpty';\r\nimport { defaultIfEmpty } from './defaultIfEmpty';\r\nimport { identity } from '../util/identity';\r\n\r\nexport function last<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\r\nexport function last<T, D>(predicate: BooleanConstructor, defaultValue: D): OperatorFunction<T, TruthyTypesOf<T> | D>;\r\nexport function last<T, D = T>(predicate?: null, defaultValue?: D): OperatorFunction<T, T | D>;\r\nexport function last<T, S extends T>(\r\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\r\n  defaultValue?: S\r\n): OperatorFunction<T, S>;\r\nexport function last<T, D = T>(\r\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\r\n  defaultValue?: D\r\n): OperatorFunction<T, T | D>;\r\n\r\n/**\r\n * Returns an Observable that emits only the last item emitted by the source Observable.\r\n * It optionally takes a predicate function as a parameter, in which case, rather than emitting\r\n * the last item from the source Observable, the resulting Observable will emit the last item\r\n * from the source Observable that satisfies the predicate.\r\n *\r\n * ![](last.png)\r\n *\r\n * It will emit an error notification if the source completes without notification or one that matches\r\n * the predicate. It returns the last value or if a predicate is provided last value that matches the\r\n * predicate. It returns the given default value if no notification is emitted or matches the predicate.\r\n *\r\n * ## Examples\r\n *\r\n * Last alphabet from the sequence\r\n *\r\n * ```ts\r\n * import { from, last } from 'rxjs';\r\n *\r\n * const source = from(['x', 'y', 'z']);\r\n * const result = source.pipe(last());\r\n *\r\n * result.subscribe(value => console.log(`Last alphabet: ${ value }`));\r\n *\r\n * // Outputs\r\n * // Last alphabet: z\r\n * ```\r\n *\r\n * Default value when the value in the predicate is not matched\r\n *\r\n * ```ts\r\n * import { from, last } from 'rxjs';\r\n *\r\n * const source = from(['x', 'y', 'z']);\r\n * const result = source.pipe(last(char => char === 'a', 'not found'));\r\n *\r\n * result.subscribe(value => console.log(`'a' is ${ value }.`));\r\n *\r\n * // Outputs\r\n * // 'a' is not found.\r\n * ```\r\n *\r\n * @see {@link skip}\r\n * @see {@link skipUntil}\r\n * @see {@link skipLast}\r\n * @see {@link skipWhile}\r\n * @see {@link first}\r\n *\r\n * @throws {EmptyError} Delivers an `EmptyError` to the Observer's `error`\r\n * callback if the Observable completes before any `next` notification was sent.\r\n *\r\n * @param predicate The condition any source emitted item has to satisfy.\r\n * @param defaultValue An optional default value to provide if last `predicate`\r\n * isn't met or no values were emitted.\r\n * @return A function that returns an Observable that emits only the last item\r\n * satisfying the given condition from the source, or an error notification\r\n * with an `EmptyError` object if no such items are emitted.\r\n */\r\nexport function last<T, D>(\r\n  predicate?: ((value: T, index: number, source: Observable<T>) => boolean) | null,\r\n  defaultValue?: D\r\n): OperatorFunction<T, T | D> {\r\n  const hasDefaultValue = arguments.length >= 2;\r\n  return (source: Observable<T>) =>\r\n    source.pipe(\r\n      predicate ? filter((v, i) => predicate(v, i, source)) : identity,\r\n      takeLast(1),\r\n      hasDefaultValue ? defaultIfEmpty(defaultValue!) : throwIfEmpty(() => new EmptyError())\r\n    );\r\n}\r\n", "import { Notification } from '../Notification';\r\nimport { OperatorFunction, ObservableNotification } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Represents all of the notifications from the source Observable as `next`\r\n * emissions marked with their original types within {@link Notification}\r\n * objects.\r\n *\r\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\r\n * {@link Notification} objects, emitted as `next` on the output Observable.\r\n * </span>\r\n *\r\n * ![](materialize.png)\r\n *\r\n * `materialize` returns an Observable that emits a `next` notification for each\r\n * `next`, `error`, or `complete` emission of the source Observable. When the\r\n * source Observable emits `complete`, the output Observable will emit `next` as\r\n * a Notification of type \"complete\", and then it will emit `complete` as well.\r\n * When the source Observable emits `error`, the output will emit `next` as a\r\n * Notification of type \"error\", and then `complete`.\r\n *\r\n * This operator is useful for producing metadata of the source Observable, to\r\n * be consumed as `next` emissions. Use it in conjunction with\r\n * {@link dematerialize}.\r\n *\r\n * ## Example\r\n *\r\n * Convert a faulty Observable to an Observable of Notifications\r\n *\r\n * ```ts\r\n * import { of, materialize, map } from 'rxjs';\r\n *\r\n * const letters = of('a', 'b', 13, 'd');\r\n * const upperCase = letters.pipe(map((x: any) => x.toUpperCase()));\r\n * const materialized = upperCase.pipe(materialize());\r\n *\r\n * materialized.subscribe(x => console.log(x));\r\n *\r\n * // Results in the following:\r\n * // - Notification { kind: 'N', value: 'A', error: undefined, hasValue: true }\r\n * // - Notification { kind: 'N', value: 'B', error: undefined, hasValue: true }\r\n * // - Notification { kind: 'E', value: undefined, error: TypeError { message: x.toUpperCase is not a function }, hasValue: false }\r\n * ```\r\n *\r\n * @see {@link Notification}\r\n * @see {@link dematerialize}\r\n *\r\n * @return A function that returns an Observable that emits\r\n * {@link Notification} objects that wrap the original emissions from the\r\n * source Observable with metadata.\r\n */\r\nexport function materialize<T>(): OperatorFunction<T, Notification<T> & ObservableNotification<T>> {\r\n  return operate((source, subscriber) => {\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value) => {\r\n          subscriber.next(Notification.createNext(value));\r\n        },\r\n        () => {\r\n          subscriber.next(Notification.createComplete());\r\n          subscriber.complete();\r\n        },\r\n        (err) => {\r\n          subscriber.next(Notification.createError(err));\r\n          subscriber.complete();\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n", "import { reduce } from './reduce';\r\nimport { MonoTypeOperatorFunction } from '../types';\r\nimport { isFunction } from '../util/isFunction';\r\n\r\n/**\r\n * The `max` operator operates on an Observable that emits numbers (or items that\r\n * can be compared with a provided function), and when source Observable completes\r\n * it emits a single item: the item with the largest value.\r\n *\r\n * ![](max.png)\r\n *\r\n * ## Examples\r\n *\r\n * Get the maximal value of a series of numbers\r\n *\r\n * ```ts\r\n * import { of, max } from 'rxjs';\r\n *\r\n * of(5, 4, 7, 2, 8)\r\n *   .pipe(max())\r\n *   .subscribe(x => console.log(x));\r\n *\r\n * // Outputs\r\n * // 8\r\n * ```\r\n *\r\n * Use a comparer function to get the maximal item\r\n *\r\n * ```ts\r\n * import { of, max } from 'rxjs';\r\n *\r\n * of(\r\n *   { age: 7, name: 'Foo' },\r\n *   { age: 5, name: 'Bar' },\r\n *   { age: 9, name: 'Beer' }\r\n * ).pipe(\r\n *   max((a, b) => a.age < b.age ? -1 : 1)\r\n * )\r\n * .subscribe(x => console.log(x.name));\r\n *\r\n * // Outputs\r\n * // 'Beer'\r\n * ```\r\n *\r\n * @see {@link min}\r\n *\r\n * @param comparer Optional comparer function that it will use instead of its\r\n * default to compare the value of two items.\r\n * @return A function that returns an Observable that emits item with the\r\n * largest value.\r\n */\r\nexport function max<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T> {\r\n  return reduce(isFunction(comparer) ? (x, y) => (comparer(x, y) > 0 ? x : y) : (x, y) => (x > y ? x : y));\r\n}\r\n", "import { mergeMap } from './mergeMap';\r\n\r\n/**\r\n * @deprecated Renamed to {@link mergeMap}. Will be removed in v8.\r\n */\r\nexport const flatMap = mergeMap;\r\n", "import { OperatorFunction, ObservedValueOf, ObservableInput } from '../types';\r\nimport { mergeMap } from './mergeMap';\r\nimport { isFunction } from '../util/isFunction';\r\n\r\n/** @deprecated Will be removed in v9. Use {@link mergeMap} instead: `mergeMap(() => result)` */\r\nexport function mergeMapTo<O extends ObservableInput<unknown>>(\r\n  innerObservable: O,\r\n  concurrent?: number\r\n): OperatorFunction<unknown, ObservedValueOf<O>>;\r\n/**\r\n * @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead.\r\n * Details: https://rxjs.dev/deprecations/resultSelector\r\n */\r\nexport function mergeMapTo<T, R, O extends ObservableInput<unknown>>(\r\n  innerObservable: O,\r\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R,\r\n  concurrent?: number\r\n): OperatorFunction<T, R>;\r\n/* tslint:enable:max-line-length */\r\n\r\n/**\r\n * Projects each source value to the same Observable which is merged multiple\r\n * times in the output Observable.\r\n *\r\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\r\n * to the same inner Observable.</span>\r\n *\r\n * ![](mergeMapTo.png)\r\n *\r\n * Maps each source value to the given Observable `innerObservable` regardless\r\n * of the source value, and then merges those resulting Observables into one\r\n * single Observable, which is the output Observable.\r\n *\r\n * ## Example\r\n *\r\n * For each click event, start an interval Observable ticking every 1 second\r\n *\r\n * ```ts\r\n * import { fromEvent, mergeMapTo, interval } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(mergeMapTo(interval(1000)));\r\n *\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link concatMapTo}\r\n * @see {@link merge}\r\n * @see {@link mergeAll}\r\n * @see {@link mergeMap}\r\n * @see {@link mergeScan}\r\n * @see {@link switchMapTo}\r\n *\r\n * @param innerObservable An `ObservableInput` to replace each value from the\r\n * source Observable.\r\n * @param concurrent Maximum number of input Observables being subscribed to\r\n * concurrently.\r\n * @return A function that returns an Observable that emits items from the\r\n * given `innerObservable`.\r\n * @deprecated Will be removed in v9. Use {@link mergeMap} instead: `mergeMap(() => result)`\r\n */\r\nexport function mergeMapTo<T, R, O extends ObservableInput<unknown>>(\r\n  innerObservable: O,\r\n  resultSelector?: ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R) | number,\r\n  concurrent: number = Infinity\r\n): OperatorFunction<T, ObservedValueOf<O> | R> {\r\n  if (isFunction(resultSelector)) {\r\n    return mergeMap(() => innerObservable, resultSelector, concurrent);\r\n  }\r\n  if (typeof resultSelector === 'number') {\r\n    concurrent = resultSelector;\r\n  }\r\n  return mergeMap(() => innerObservable, concurrent);\r\n}\r\n", "import { ObservableInput, OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { mergeInternals } from './mergeInternals';\r\n\r\n/**\r\n * Applies an accumulator function over the source Observable where the\r\n * accumulator function itself returns an Observable, then each intermediate\r\n * Observable returned is merged into the output Observable.\r\n *\r\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\r\n * by the accumulator are merged into the outer Observable.</span>\r\n *\r\n * The first parameter of the `mergeScan` is an `accumulator` function which is\r\n * being called every time the source Observable emits a value. `mergeScan` will\r\n * subscribe to the value returned by the `accumulator` function and will emit\r\n * values to the subscriber emitted by inner Observable.\r\n *\r\n * The `accumulator` function is being called with three parameters passed to it:\r\n * `acc`, `value` and `index`. The `acc` parameter is used as the state parameter\r\n * whose value is initially set to the `seed` parameter (the second parameter\r\n * passed to the `mergeScan` operator).\r\n *\r\n * `mergeScan` internally keeps the value of the `acc` parameter: as long as the\r\n * source Observable emits without inner Observable emitting, the `acc` will be\r\n * set to `seed`. The next time the inner Observable emits a value, `mergeScan`\r\n * will internally remember it and it will be passed to the `accumulator`\r\n * function as `acc` parameter the next time source emits.\r\n *\r\n * The `value` parameter of the `accumulator` function is the value emitted by the\r\n * source Observable, while the `index` is a number which represent the order of the\r\n * current emission by the source Observable. It starts with 0.\r\n *\r\n * The last parameter to the `mergeScan` is the `concurrent` value which defaults\r\n * to Infinity. It represents the maximum number of inner Observable subscriptions\r\n * at a time.\r\n *\r\n * ## Example\r\n *\r\n * Count the number of click events\r\n *\r\n * ```ts\r\n * import { fromEvent, map, mergeScan, of } from 'rxjs';\r\n *\r\n * const click$ = fromEvent(document, 'click');\r\n * const one$ = click$.pipe(map(() => 1));\r\n * const seed = 0;\r\n * const count$ = one$.pipe(\r\n *   mergeScan((acc, one) => of(acc + one), seed)\r\n * );\r\n *\r\n * count$.subscribe(x => console.log(x));\r\n *\r\n * // Results:\r\n * // 1\r\n * // 2\r\n * // 3\r\n * // 4\r\n * // ...and so on for each click\r\n * ```\r\n *\r\n * @see {@link scan}\r\n * @see {@link switchScan}\r\n *\r\n * @param accumulator The accumulator function called on each source value.\r\n * @param seed The initial accumulation value.\r\n * @param concurrent Maximum number of input Observables being subscribed to\r\n * concurrently.\r\n * @return A function that returns an Observable of the accumulated values.\r\n */\r\nexport function mergeScan<T, R>(\r\n  accumulator: (acc: R, value: T, index: number) => ObservableInput<R>,\r\n  seed: R,\r\n  concurrent = Infinity\r\n): OperatorFunction<T, R> {\r\n  return operate((source, subscriber) => {\r\n    // The accumulated state.\r\n    let state = seed;\r\n\r\n    return mergeInternals(\r\n      source,\r\n      subscriber,\r\n      (value, index) => accumulator(state, value, index),\r\n      concurrent,\r\n      (value) => {\r\n        state = value;\r\n      },\r\n      false,\r\n      undefined,\r\n      () => (state = null!)\r\n    );\r\n  });\r\n}\r\n", "import { ObservableInput, ObservableInputTuple, OperatorFunction, SchedulerLike } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { mergeAll } from './mergeAll';\r\nimport { popNumber, popScheduler } from '../util/args';\r\nimport { from } from '../observable/from';\r\n\r\n/** @deprecated Replaced with {@link mergeWith}. Will be removed in v8. */\r\nexport function merge<T, A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): OperatorFunction<T, T | A[number]>;\r\n/** @deprecated Replaced with {@link mergeWith}. Will be removed in v8. */\r\nexport function merge<T, A extends readonly unknown[]>(\r\n  ...sourcesAndConcurrency: [...ObservableInputTuple<A>, number]\r\n): OperatorFunction<T, T | A[number]>;\r\n/** @deprecated Replaced with {@link mergeWith}. Will be removed in v8. */\r\nexport function merge<T, A extends readonly unknown[]>(\r\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike]\r\n): OperatorFunction<T, T | A[number]>;\r\n/** @deprecated Replaced with {@link mergeWith}. Will be removed in v8. */\r\nexport function merge<T, A extends readonly unknown[]>(\r\n  ...sourcesAndConcurrencyAndScheduler: [...ObservableInputTuple<A>, number, SchedulerLike]\r\n): OperatorFunction<T, T | A[number]>;\r\n\r\nexport function merge<T>(...args: unknown[]): OperatorFunction<T, unknown> {\r\n  const scheduler = popScheduler(args);\r\n  const concurrent = popNumber(args, Infinity);\r\n\r\n  return operate((source, subscriber) => {\r\n    mergeAll(concurrent)(from([source, ...(args as ObservableInput<T>[])], scheduler)).subscribe(subscriber);\r\n  });\r\n}\r\n", "import { ObservableInputTuple, OperatorFunction } from '../types';\r\nimport { merge } from './merge';\r\n\r\n/**\r\n * Merge the values from all observables to a single observable result.\r\n *\r\n * Creates an observable, that when subscribed to, subscribes to the source\r\n * observable, and all other sources provided as arguments. All values from\r\n * every source are emitted from the resulting subscription.\r\n *\r\n * When all sources complete, the resulting observable will complete.\r\n *\r\n * When any source errors, the resulting observable will error.\r\n *\r\n * ## Example\r\n *\r\n * Joining all outputs from multiple user input event streams\r\n *\r\n * ```ts\r\n * import { fromEvent, map, mergeWith } from 'rxjs';\r\n *\r\n * const clicks$ = fromEvent(document, 'click').pipe(map(() => 'click'));\r\n * const mousemoves$ = fromEvent(document, 'mousemove').pipe(map(() => 'mousemove'));\r\n * const dblclicks$ = fromEvent(document, 'dblclick').pipe(map(() => 'dblclick'));\r\n *\r\n * mousemoves$\r\n *   .pipe(mergeWith(clicks$, dblclicks$))\r\n *   .subscribe(x => console.log(x));\r\n *\r\n * // result (assuming user interactions)\r\n * // 'mousemove'\r\n * // 'mousemove'\r\n * // 'mousemove'\r\n * // 'click'\r\n * // 'click'\r\n * // 'dblclick'\r\n * ```\r\n *\r\n * @see {@link merge}\r\n *\r\n * @param otherSources the sources to combine the current source with.\r\n * @return A function that returns an Observable that merges the values from\r\n * all given Observables.\r\n */\r\nexport function mergeWith<T, A extends readonly unknown[]>(\r\n  ...otherSources: [...ObservableInputTuple<A>]\r\n): OperatorFunction<T, T | A[number]> {\r\n  return merge(...otherSources);\r\n}\r\n", "import { reduce } from './reduce';\r\nimport { MonoTypeOperatorFunction } from '../types';\r\nimport { isFunction } from '../util/isFunction';\r\n\r\n/**\r\n * The `min` operator operates on an Observable that emits numbers (or items that\r\n * can be compared with a provided function), and when source Observable completes\r\n * it emits a single item: the item with the smallest value.\r\n *\r\n * ![](min.png)\r\n *\r\n * ## Examples\r\n *\r\n * Get the minimal value of a series of numbers\r\n *\r\n * ```ts\r\n * import { of, min } from 'rxjs';\r\n *\r\n * of(5, 4, 7, 2, 8)\r\n *   .pipe(min())\r\n *   .subscribe(x => console.log(x));\r\n *\r\n * // Outputs\r\n * // 2\r\n * ```\r\n *\r\n * Use a comparer function to get the minimal item\r\n *\r\n * ```ts\r\n * import { of, min } from 'rxjs';\r\n *\r\n * of(\r\n *   { age: 7, name: 'Foo' },\r\n *   { age: 5, name: 'Bar' },\r\n *   { age: 9, name: 'Beer' }\r\n * ).pipe(\r\n *   min((a, b) => a.age < b.age ? -1 : 1)\r\n * )\r\n * .subscribe(x => console.log(x.name));\r\n *\r\n * // Outputs\r\n * // 'Bar'\r\n * ```\r\n *\r\n * @see {@link max}\r\n *\r\n * @param comparer Optional comparer function that it will use instead of its\r\n * default to compare the value of two items.\r\n * @return A function that returns an Observable that emits item with the\r\n * smallest value.\r\n */\r\nexport function min<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T> {\r\n  return reduce(isFunction(comparer) ? (x, y) => (comparer(x, y) < 0 ? x : y) : (x, y) => (x < y ? x : y));\r\n}\r\n", "import { Subject } from '../Subject';\r\nimport { Observable } from '../Observable';\r\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\r\nimport { OperatorFunction, UnaryFunction, ObservedValueOf, ObservableInput } from '../types';\r\nimport { isFunction } from '../util/isFunction';\r\nimport { connect } from './connect';\r\n\r\n/**\r\n * An operator that creates a {@link ConnectableObservable}, that when connected,\r\n * with the `connect` method, will use the provided subject to multicast the values\r\n * from the source to all consumers.\r\n *\r\n * @param subject The subject to multicast through.\r\n * @return A function that returns a {@link ConnectableObservable}\r\n * @deprecated Will be removed in v8. To create a connectable observable, use {@link connectable}.\r\n * If you're using {@link refCount} after `multicast`, use the {@link share} operator instead.\r\n * `multicast(subject), refCount()` is equivalent to\r\n * `share({ connector: () => subject, resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false })`.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport function multicast<T>(subject: Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\r\n\r\n/**\r\n * Because this is deprecated in favor of the {@link connect} operator, and was otherwise poorly documented,\r\n * rather than duplicate the effort of documenting the same behavior, please see documentation for the\r\n * {@link connect} operator.\r\n *\r\n * @param subject The subject used to multicast.\r\n * @param selector A setup function to setup the multicast\r\n * @return A function that returns an observable that mirrors the observable returned by the selector.\r\n * @deprecated Will be removed in v8. Use the {@link connect} operator instead.\r\n * `multicast(subject, selector)` is equivalent to\r\n * `connect(selector, { connector: () => subject })`.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport function multicast<T, O extends ObservableInput<any>>(\r\n  subject: Subject<T>,\r\n  selector: (shared: Observable<T>) => O\r\n): OperatorFunction<T, ObservedValueOf<O>>;\r\n\r\n/**\r\n * An operator that creates a {@link ConnectableObservable}, that when connected,\r\n * with the `connect` method, will use the provided subject to multicast the values\r\n * from the source to all consumers.\r\n *\r\n * @param subjectFactory A factory that will be called to create the subject. Passing a function here\r\n * will cause the underlying subject to be \"reset\" on error, completion, or refCounted unsubscription of\r\n * the source.\r\n * @return A function that returns a {@link ConnectableObservable}\r\n * @deprecated Will be removed in v8. To create a connectable observable, use {@link connectable}.\r\n * If you're using {@link refCount} after `multicast`, use the {@link share} operator instead.\r\n * `multicast(() => new BehaviorSubject('test')), refCount()` is equivalent to\r\n * `share({ connector: () => new BehaviorSubject('test') })`.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport function multicast<T>(subjectFactory: () => Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\r\n\r\n/**\r\n * Because this is deprecated in favor of the {@link connect} operator, and was otherwise poorly documented,\r\n * rather than duplicate the effort of documenting the same behavior, please see documentation for the\r\n * {@link connect} operator.\r\n *\r\n * @param subjectFactory A factory that creates the subject used to multicast.\r\n * @param selector A function to setup the multicast and select the output.\r\n * @return A function that returns an observable that mirrors the observable returned by the selector.\r\n * @deprecated Will be removed in v8. Use the {@link connect} operator instead.\r\n * `multicast(subjectFactory, selector)` is equivalent to\r\n * `connect(selector, { connector: subjectFactory })`.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport function multicast<T, O extends ObservableInput<any>>(\r\n  subjectFactory: () => Subject<T>,\r\n  selector: (shared: Observable<T>) => O\r\n): OperatorFunction<T, ObservedValueOf<O>>;\r\n\r\n/**\r\n * @deprecated Will be removed in v8. Use the {@link connectable} observable, the {@link connect} operator or the\r\n * {@link share} operator instead. See the overloads below for equivalent replacement examples of this operator's\r\n * behaviors.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport function multicast<T, R>(\r\n  subjectOrSubjectFactory: Subject<T> | (() => Subject<T>),\r\n  selector?: (source: Observable<T>) => Observable<R>\r\n): OperatorFunction<T, R> {\r\n  const subjectFactory = isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : () => subjectOrSubjectFactory;\r\n\r\n  if (isFunction(selector)) {\r\n    // If a selector function is provided, then we're a \"normal\" operator that isn't\r\n    // going to return a ConnectableObservable. We can use `connect` to do what we\r\n    // need to do.\r\n    return connect(selector, {\r\n      connector: subjectFactory,\r\n    });\r\n  }\r\n\r\n  return (source: Observable<T>) => new ConnectableObservable<any>(source, subjectFactory);\r\n}\r\n", "import { ObservableInputTuple, OperatorFunction } from '../types';\r\nimport { argsOrArgArray } from '../util/argsOrArgArray';\r\nimport { onErrorResumeNext as oERNCreate } from '../observable/onErrorResumeNext';\r\n\r\nexport function onErrorResumeNextWith<T, A extends readonly unknown[]>(\r\n  sources: [...ObservableInputTuple<A>]\r\n): OperatorFunction<T, T | A[number]>;\r\nexport function onErrorResumeNextWith<T, A extends readonly unknown[]>(\r\n  ...sources: [...ObservableInputTuple<A>]\r\n): OperatorFunction<T, T | A[number]>;\r\n\r\n/**\r\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\r\n * that was passed.\r\n *\r\n * <span class=\"informal\">Execute series of Observables, subscribes to next one on error or complete.</span>\r\n *\r\n * ![](onErrorResumeNext.png)\r\n *\r\n * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\r\n * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\r\n * as the source.\r\n *\r\n * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\r\n * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\r\n * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\r\n * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\r\n * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\r\n * be happening until there is no more Observables left in the series, at which point returned Observable will\r\n * complete - even if the last subscribed stream ended with an error.\r\n *\r\n * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\r\n * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\r\n * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\r\n * an error.\r\n *\r\n * Note that you do not get any access to errors emitted by the Observables. In particular do not\r\n * expect these errors to appear in error callback passed to {@link Observable#subscribe}. If you want to take\r\n * specific actions based on what error was emitted by an Observable, you should try out {@link catchError} instead.\r\n *\r\n *\r\n * ## Example\r\n *\r\n * Subscribe to the next Observable after map fails\r\n *\r\n * ```ts\r\n * import { of, onErrorResumeNext, map } from 'rxjs';\r\n *\r\n * of(1, 2, 3, 0)\r\n *   .pipe(\r\n *     map(x => {\r\n *       if (x === 0) {\r\n *         throw Error();\r\n *       }\r\n *\r\n *       return 10 / x;\r\n *     }),\r\n *     onErrorResumeNext(of(1, 2, 3))\r\n *   )\r\n *   .subscribe({\r\n *     next: val => console.log(val),\r\n *     error: err => console.log(err),          // Will never be called.\r\n *     complete: () => console.log('that\\'s it!')\r\n *   });\r\n *\r\n * // Logs:\r\n * // 10\r\n * // 5\r\n * // 3.3333333333333335\r\n * // 1\r\n * // 2\r\n * // 3\r\n * // 'that's it!'\r\n * ```\r\n *\r\n * @see {@link concat}\r\n * @see {@link catchError}\r\n *\r\n * @param sources `ObservableInput`s passed either directly or as an array.\r\n * @return A function that returns an Observable that emits values from source\r\n * Observable, but - if it errors - subscribes to the next passed Observable\r\n * and so on, until it completes or runs out of Observables.\r\n */\r\nexport function onErrorResumeNextWith<T, A extends readonly unknown[]>(\r\n  ...sources: [[...ObservableInputTuple<A>]] | [...ObservableInputTuple<A>]\r\n): OperatorFunction<T, T | A[number]> {\r\n  // For some reason, TS 4.1 RC gets the inference wrong here and infers the\r\n  // result to be `A[number][]` - completely dropping the ObservableInput part\r\n  // of the type. This makes no sense whatsoever. As a workaround, the type is\r\n  // asserted explicitly.\r\n  const nextSources = argsOrArgArray(sources) as unknown as ObservableInputTuple<A>;\r\n\r\n  return (source) => oERNCreate(source, ...nextSources);\r\n}\r\n\r\n/**\r\n * @deprecated Renamed. Use {@link onErrorResumeNextWith} instead. Will be removed in v8.\r\n */\r\nexport const onErrorResumeNext = onErrorResumeNextWith;\r\n", "import { OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Groups pairs of consecutive emissions together and emits them as an array of\r\n * two values.\r\n *\r\n * <span class=\"informal\">Puts the current value and previous value together as\r\n * an array, and emits that.</span>\r\n *\r\n * ![](pairwise.png)\r\n *\r\n * The Nth emission from the source Observable will cause the output Observable\r\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\r\n * pair. For this reason, `pairwise` emits on the second and subsequent\r\n * emissions from the source Observable, but not on the first emission, because\r\n * there is no previous value in that case.\r\n *\r\n * ## Example\r\n *\r\n * On every click (starting from the second), emit the relative distance to the previous click\r\n *\r\n * ```ts\r\n * import { fromEvent, pairwise, map } from 'rxjs';\r\n *\r\n * const clicks = fromEvent<PointerEvent>(document, 'click');\r\n * const pairs = clicks.pipe(pairwise());\r\n * const distance = pairs.pipe(\r\n *   map(([first, second]) => {\r\n *     const x0 = first.clientX;\r\n *     const y0 = first.clientY;\r\n *     const x1 = second.clientX;\r\n *     const y1 = second.clientY;\r\n *     return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\r\n *   })\r\n * );\r\n *\r\n * distance.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link buffer}\r\n * @see {@link bufferCount}\r\n *\r\n * @return A function that returns an Observable of pairs (as arrays) of\r\n * consecutive values from the source Observable.\r\n */\r\nexport function pairwise<T>(): OperatorFunction<T, [T, T]> {\r\n  return operate((source, subscriber) => {\r\n    let prev: T;\r\n    let hasPrev = false;\r\n    source.subscribe(\r\n      createOperatorSubscriber(subscriber, (value) => {\r\n        const p = prev;\r\n        prev = value;\r\n        hasPrev && subscriber.next([p, value]);\r\n        hasPrev = true;\r\n      })\r\n    );\r\n  });\r\n}\r\n", "import { map } from './map';\r\nimport { OperatorFunction } from '../types';\r\n\r\n/* tslint:disable:max-line-length */\r\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\r\nexport function pluck<T, K1 extends keyof T>(k1: K1): OperatorFunction<T, T[K1]>;\r\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\r\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1]>(k1: K1, k2: K2): OperatorFunction<T, T[K1][K2]>;\r\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\r\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(\r\n  k1: K1,\r\n  k2: K2,\r\n  k3: K3\r\n): OperatorFunction<T, T[K1][K2][K3]>;\r\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\r\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3]>(\r\n  k1: K1,\r\n  k2: K2,\r\n  k3: K3,\r\n  k4: K4\r\n): OperatorFunction<T, T[K1][K2][K3][K4]>;\r\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\r\nexport function pluck<\r\n  T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n  K5 extends keyof T[K1][K2][K3][K4]\r\n>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5): OperatorFunction<T, T[K1][K2][K3][K4][K5]>;\r\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\r\nexport function pluck<\r\n  T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n  K5 extends keyof T[K1][K2][K3][K4],\r\n  K6 extends keyof T[K1][K2][K3][K4][K5]\r\n>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5, k6: K6): OperatorFunction<T, T[K1][K2][K3][K4][K5][K6]>;\r\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\r\nexport function pluck<\r\n  T,\r\n  K1 extends keyof T,\r\n  K2 extends keyof T[K1],\r\n  K3 extends keyof T[K1][K2],\r\n  K4 extends keyof T[K1][K2][K3],\r\n  K5 extends keyof T[K1][K2][K3][K4],\r\n  K6 extends keyof T[K1][K2][K3][K4][K5]\r\n>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5, k6: K6, ...rest: string[]): OperatorFunction<T, unknown>;\r\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\r\nexport function pluck<T>(...properties: string[]): OperatorFunction<T, unknown>;\r\n/* tslint:enable:max-line-length */\r\n\r\n/**\r\n * Maps each source value to its specified nested property.\r\n *\r\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\r\n * the nested properties of every emitted value.</span>\r\n *\r\n * ![](pluck.png)\r\n *\r\n * Given a list of strings or numbers describing a path to a property, retrieves\r\n * the value of a specified nested property from all values in the source\r\n * Observable. If a property can't be resolved, it will return `undefined` for\r\n * that value.\r\n *\r\n * ## Example\r\n *\r\n * Map every click to the tagName of the clicked target element\r\n *\r\n * ```ts\r\n * import { fromEvent, pluck } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const tagNames = clicks.pipe(pluck('target', 'tagName'));\r\n *\r\n * tagNames.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link map}\r\n *\r\n * @param properties The nested properties to pluck from each source\r\n * value.\r\n * @return A function that returns an Observable of property values from the\r\n * source values.\r\n * @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8.\r\n */\r\nexport function pluck<T, R>(...properties: Array<string | number | symbol>): OperatorFunction<T, R> {\r\n  const length = properties.length;\r\n  if (length === 0) {\r\n    throw new Error('list of properties cannot be empty.');\r\n  }\r\n  return map((x) => {\r\n    let currentProp: any = x;\r\n    for (let i = 0; i < length; i++) {\r\n      const p = currentProp?.[properties[i]];\r\n      if (typeof p !== 'undefined') {\r\n        currentProp = p;\r\n      } else {\r\n        return undefined;\r\n      }\r\n    }\r\n    return currentProp;\r\n  });\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { Subject } from '../Subject';\r\nimport { multicast } from './multicast';\r\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\r\nimport { MonoTypeOperatorFunction, OperatorFunction, UnaryFunction, ObservableInput, ObservedValueOf } from '../types';\r\nimport { connect } from './connect';\r\n\r\n/**\r\n * Returns a connectable observable that, when connected, will multicast\r\n * all values through a single underlying {@link Subject} instance.\r\n *\r\n * @deprecated Will be removed in v8. To create a connectable observable, use {@link connectable}.\r\n * `source.pipe(publish())` is equivalent to\r\n * `connectable(source, { connector: () => new Subject(), resetOnDisconnect: false })`.\r\n * If you're using {@link refCount} after `publish`, use {@link share} operator instead.\r\n * `source.pipe(publish(), refCount())` is equivalent to\r\n * `source.pipe(share({ resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false }))`.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport function publish<T>(): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\r\n\r\n/**\r\n * Returns an observable, that when subscribed to, creates an underlying {@link Subject},\r\n * provides an observable view of it to a `selector` function, takes the observable result of\r\n * that selector function and subscribes to it, sending its values to the consumer, _then_ connects\r\n * the subject to the original source.\r\n *\r\n * @param selector A function used to setup multicasting prior to automatic connection.\r\n *\r\n * @deprecated Will be removed in v8. Use the {@link connect} operator instead.\r\n * `publish(selector)` is equivalent to `connect(selector)`.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport function publish<T, O extends ObservableInput<any>>(selector: (shared: Observable<T>) => O): OperatorFunction<T, ObservedValueOf<O>>;\r\n\r\n/**\r\n * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\r\n * before it begins emitting items to those Observers that have subscribed to it.\r\n *\r\n * <span class=\"informal\">Makes a cold Observable hot</span>\r\n *\r\n * ![](publish.png)\r\n *\r\n * ## Examples\r\n *\r\n * Make `source$` hot by applying `publish` operator, then merge each inner observable into a single one\r\n * and subscribe\r\n *\r\n * ```ts\r\n * import { zip, interval, of, map, publish, merge, tap } from 'rxjs';\r\n *\r\n * const source$ = zip(interval(2000), of(1, 2, 3, 4, 5, 6, 7, 8, 9))\r\n *   .pipe(map(([, number]) => number));\r\n *\r\n * source$\r\n *   .pipe(\r\n *     publish(multicasted$ =>\r\n *       merge(\r\n *         multicasted$.pipe(tap(x => console.log('Stream 1:', x))),\r\n *         multicasted$.pipe(tap(x => console.log('Stream 2:', x))),\r\n *         multicasted$.pipe(tap(x => console.log('Stream 3:', x)))\r\n *       )\r\n *     )\r\n *   )\r\n *   .subscribe();\r\n *\r\n * // Results every two seconds\r\n * // Stream 1: 1\r\n * // Stream 2: 1\r\n * // Stream 3: 1\r\n * // ...\r\n * // Stream 1: 9\r\n * // Stream 2: 9\r\n * // Stream 3: 9\r\n * ```\r\n *\r\n * @see {@link publishLast}\r\n * @see {@link publishReplay}\r\n * @see {@link publishBehavior}\r\n *\r\n * @param selector Optional selector function which can use the multicasted source sequence as many times\r\n * as needed, without causing multiple subscriptions to the source sequence.\r\n * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\r\n * @return A function that returns a ConnectableObservable that upon connection\r\n * causes the source Observable to emit items to its Observers.\r\n * @deprecated Will be removed in v8. Use the {@link connectable} observable, the {@link connect} operator or the\r\n * {@link share} operator instead. See the overloads below for equivalent replacement examples of this operator's\r\n * behaviors.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport function publish<T, R>(selector?: OperatorFunction<T, R>): MonoTypeOperatorFunction<T> | OperatorFunction<T, R> {\r\n  return selector ? (source) => connect(selector)(source) : (source) => multicast(new Subject<T>())(source);\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { BehaviorSubject } from '../BehaviorSubject';\r\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\r\nimport { UnaryFunction } from '../types';\r\n\r\n/**\r\n * Creates a {@link ConnectableObservable} that utilizes a {@link BehaviorSubject}.\r\n *\r\n * @param initialValue The initial value passed to the {@link BehaviorSubject}.\r\n * @return A function that returns a {@link ConnectableObservable}\r\n * @deprecated Will be removed in v8. To create a connectable observable that uses a\r\n * {@link BehaviorSubject} under the hood, use {@link connectable}.\r\n * `source.pipe(publishBehavior(initValue))` is equivalent to\r\n * `connectable(source, { connector: () => new BehaviorSubject(initValue), resetOnDisconnect: false })`.\r\n * If you're using {@link refCount} after `publishBehavior`, use the {@link share} operator instead.\r\n * `source.pipe(publishBehavior(initValue), refCount())` is equivalent to\r\n * `source.pipe(share({ connector: () => new BehaviorSubject(initValue), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false  }))`.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport function publishBehavior<T>(initialValue: T): UnaryFunction<Observable<T>, ConnectableObservable<T>> {\r\n  // Note that this has *never* supported the selector function.\r\n  return (source) => {\r\n    const subject = new BehaviorSubject<T>(initialValue);\r\n    return new ConnectableObservable(source, () => subject);\r\n  };\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { AsyncSubject } from '../AsyncSubject';\r\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\r\nimport { UnaryFunction } from '../types';\r\n\r\n/**\r\n * Returns a connectable observable sequence that shares a single subscription to the\r\n * underlying sequence containing only the last notification.\r\n *\r\n * ![](publishLast.png)\r\n *\r\n * Similar to {@link publish}, but it waits until the source observable completes and stores\r\n * the last emitted value.\r\n * Similarly to {@link publishReplay} and {@link publishBehavior}, this keeps storing the last\r\n * value even if it has no more subscribers. If subsequent subscriptions happen, they will\r\n * immediately get that last stored value and complete.\r\n *\r\n * ## Example\r\n *\r\n * ```ts\r\n * import { ConnectableObservable, interval, publishLast, tap, take } from 'rxjs';\r\n *\r\n * const connectable = <ConnectableObservable<number>>interval(1000)\r\n *   .pipe(\r\n *     tap(x => console.log('side effect', x)),\r\n *     take(3),\r\n *     publishLast()\r\n *   );\r\n *\r\n * connectable.subscribe({\r\n *   next: x => console.log('Sub. A', x),\r\n *   error: err => console.log('Sub. A Error', err),\r\n *   complete: () => console.log('Sub. A Complete')\r\n * });\r\n *\r\n * connectable.subscribe({\r\n *   next: x => console.log('Sub. B', x),\r\n *   error: err => console.log('Sub. B Error', err),\r\n *   complete: () => console.log('Sub. B Complete')\r\n * });\r\n *\r\n * connectable.connect();\r\n *\r\n * // Results:\r\n * // 'side effect 0'   - after one second\r\n * // 'side effect 1'   - after two seconds\r\n * // 'side effect 2'   - after three seconds\r\n * // 'Sub. A 2'        - immediately after 'side effect 2'\r\n * // 'Sub. B 2'\r\n * // 'Sub. A Complete'\r\n * // 'Sub. B Complete'\r\n * ```\r\n *\r\n * @see {@link ConnectableObservable}\r\n * @see {@link publish}\r\n * @see {@link publishReplay}\r\n * @see {@link publishBehavior}\r\n *\r\n * @return A function that returns an Observable that emits elements of a\r\n * sequence produced by multicasting the source sequence.\r\n * @deprecated Will be removed in v8. To create a connectable observable with an\r\n * {@link AsyncSubject} under the hood, use {@link connectable}.\r\n * `source.pipe(publishLast())` is equivalent to\r\n * `connectable(source, { connector: () => new AsyncSubject(), resetOnDisconnect: false })`.\r\n * If you're using {@link refCount} after `publishLast`, use the {@link share} operator instead.\r\n * `source.pipe(publishLast(), refCount())` is equivalent to\r\n * `source.pipe(share({ connector: () => new AsyncSubject(), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false }))`.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport function publishLast<T>(): UnaryFunction<Observable<T>, ConnectableObservable<T>> {\r\n  // Note that this has *never* supported a selector function like `publish` and `publishReplay`.\r\n  return (source) => {\r\n    const subject = new AsyncSubject<T>();\r\n    return new ConnectableObservable(source, () => subject);\r\n  };\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { ReplaySubject } from '../ReplaySubject';\r\nimport { multicast } from './multicast';\r\nimport { MonoTypeOperatorFunction, OperatorFunction, TimestampProvider, ObservableInput, ObservedValueOf } from '../types';\r\nimport { isFunction } from '../util/isFunction';\r\n\r\n/**\r\n * Creates a {@link ConnectableObservable} that uses a {@link ReplaySubject}\r\n * internally.\r\n *\r\n * @param bufferSize The buffer size for the underlying {@link ReplaySubject}.\r\n * @param windowTime The window time for the underlying {@link ReplaySubject}.\r\n * @param timestampProvider The timestamp provider for the underlying {@link ReplaySubject}.\r\n * @deprecated Will be removed in v8. To create a connectable observable that uses a\r\n * {@link ReplaySubject} under the hood, use {@link connectable}.\r\n * `source.pipe(publishReplay(size, time, scheduler))` is equivalent to\r\n * `connectable(source, { connector: () => new ReplaySubject(size, time, scheduler), resetOnDisconnect: false })`.\r\n * If you're using {@link refCount} after `publishReplay`, use the {@link share} operator instead.\r\n * `publishReplay(size, time, scheduler), refCount()` is equivalent to\r\n * `share({ connector: () => new ReplaySubject(size, time, scheduler), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false })`.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport function publishReplay<T>(\r\n  bufferSize?: number,\r\n  windowTime?: number,\r\n  timestampProvider?: TimestampProvider\r\n): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * Creates an observable, that when subscribed to, will create a {@link ReplaySubject},\r\n * and pass an observable from it (using [asObservable](api/index/class/Subject#asObservable)) to\r\n * the `selector` function, which then returns an observable that is subscribed to before\r\n * \"connecting\" the source to the internal `ReplaySubject`.\r\n *\r\n * Since this is deprecated, for additional details see the documentation for {@link connect}.\r\n *\r\n * @param bufferSize The buffer size for the underlying {@link ReplaySubject}.\r\n * @param windowTime The window time for the underlying {@link ReplaySubject}.\r\n * @param selector A function used to setup the multicast.\r\n * @param timestampProvider The timestamp provider for the underlying {@link ReplaySubject}.\r\n * @deprecated Will be removed in v8. Use the {@link connect} operator instead.\r\n * `source.pipe(publishReplay(size, window, selector, scheduler))` is equivalent to\r\n * `source.pipe(connect(selector, { connector: () => new ReplaySubject(size, window, scheduler) }))`.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport function publishReplay<T, O extends ObservableInput<any>>(\r\n  bufferSize: number | undefined,\r\n  windowTime: number | undefined,\r\n  selector: (shared: Observable<T>) => O,\r\n  timestampProvider?: TimestampProvider\r\n): OperatorFunction<T, ObservedValueOf<O>>;\r\n\r\n/**\r\n * Creates a {@link ConnectableObservable} that uses a {@link ReplaySubject}\r\n * internally.\r\n *\r\n * @param bufferSize The buffer size for the underlying {@link ReplaySubject}.\r\n * @param windowTime The window time for the underlying {@link ReplaySubject}.\r\n * @param selector Passing `undefined` here determines that this operator will return a {@link ConnectableObservable}.\r\n * @param timestampProvider The timestamp provider for the underlying {@link ReplaySubject}.\r\n * @deprecated Will be removed in v8. To create a connectable observable that uses a\r\n * {@link ReplaySubject} under the hood, use {@link connectable}.\r\n * `source.pipe(publishReplay(size, time, scheduler))` is equivalent to\r\n * `connectable(source, { connector: () => new ReplaySubject(size, time, scheduler), resetOnDisconnect: false })`.\r\n * If you're using {@link refCount} after `publishReplay`, use the {@link share} operator instead.\r\n * `publishReplay(size, time, scheduler), refCount()` is equivalent to\r\n * `share({ connector: () => new ReplaySubject(size, time, scheduler), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false })`.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport function publishReplay<T, O extends ObservableInput<any>>(\r\n  bufferSize: number | undefined,\r\n  windowTime: number | undefined,\r\n  selector: undefined,\r\n  timestampProvider: TimestampProvider\r\n): OperatorFunction<T, ObservedValueOf<O>>;\r\n\r\n/**\r\n * @deprecated Will be removed in v8. Use the {@link connectable} observable, the {@link connect} operator or the\r\n * {@link share} operator instead. See the overloads below for equivalent replacement examples of this operator's\r\n * behaviors.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport function publishReplay<T, R>(\r\n  bufferSize?: number,\r\n  windowTime?: number,\r\n  selectorOrScheduler?: TimestampProvider | OperatorFunction<T, R>,\r\n  timestampProvider?: TimestampProvider\r\n) {\r\n  if (selectorOrScheduler && !isFunction(selectorOrScheduler)) {\r\n    timestampProvider = selectorOrScheduler;\r\n  }\r\n  const selector = isFunction(selectorOrScheduler) ? selectorOrScheduler : undefined;\r\n  // Note, we're passing `selector!` here, because at runtime, `undefined` is an acceptable argument\r\n  // but it makes our TypeScript signature for `multicast` unhappy (as it should, because it's gross).\r\n  return (source: Observable<T>) => multicast(new ReplaySubject<T>(bufferSize, windowTime, timestampProvider), selector!)(source);\r\n}\r\n", "import { OperatorFunction, ObservableInputTuple } from '../types';\r\nimport { raceInit } from '../observable/race';\r\nimport { operate } from '../util/lift';\r\nimport { identity } from '../util/identity';\r\n\r\n/**\r\n * Creates an Observable that mirrors the first source Observable to emit a next,\r\n * error or complete notification from the combination of the Observable to which\r\n * the operator is applied and supplied Observables.\r\n *\r\n * ## Example\r\n *\r\n * ```ts\r\n * import { interval, map, raceWith } from 'rxjs';\r\n *\r\n * const obs1 = interval(7000).pipe(map(() => 'slow one'));\r\n * const obs2 = interval(3000).pipe(map(() => 'fast one'));\r\n * const obs3 = interval(5000).pipe(map(() => 'medium one'));\r\n *\r\n * obs1\r\n *   .pipe(raceWith(obs2, obs3))\r\n *   .subscribe(winner => console.log(winner));\r\n *\r\n * // Outputs\r\n * // a series of 'fast one'\r\n * ```\r\n *\r\n * @param otherSources Sources used to race for which Observable emits first.\r\n * @return A function that returns an Observable that mirrors the output of the\r\n * first Observable to emit an item.\r\n */\r\nexport function raceWith<T, A extends readonly unknown[]>(\r\n  ...otherSources: [...ObservableInputTuple<A>]\r\n): OperatorFunction<T, T | A[number]> {\r\n  return !otherSources.length\r\n    ? identity\r\n    : operate((source, subscriber) => {\r\n        raceInit<T | A[number]>([source, ...otherSources])(subscriber);\r\n      });\r\n}\r\n", "import { Subscription } from '../Subscription';\r\nimport { EMPTY } from '../observable/empty';\r\nimport { operate } from '../util/lift';\r\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { timer } from '../observable/timer';\r\n\r\nexport interface RepeatConfig {\r\n  /**\r\n   * The number of times to repeat the source. Defaults to `Infinity`.\r\n   */\r\n  count?: number;\r\n\r\n  /**\r\n   * If a `number`, will delay the repeat of the source by that number of milliseconds.\r\n   * If a function, it will provide the number of times the source has been subscribed to,\r\n   * and the return value should be a valid observable input that will notify when the source\r\n   * should be repeated. If the notifier observable is empty, the result will complete.\r\n   */\r\n  delay?: number | ((count: number) => ObservableInput<any>);\r\n}\r\n\r\n/**\r\n * Returns an Observable that will resubscribe to the source stream when the source stream completes.\r\n *\r\n * <span class=\"informal\">Repeats all values emitted on the source. It's like {@link retry}, but for non error cases.</span>\r\n *\r\n * ![](repeat.png)\r\n *\r\n * Repeat will output values from a source until the source completes, then it will resubscribe to the\r\n * source a specified number of times, with a specified delay. Repeat can be particularly useful in\r\n * combination with closing operators like {@link take}, {@link takeUntil}, {@link first}, or {@link takeWhile},\r\n * as it can be used to restart a source again from scratch.\r\n *\r\n * Repeat is very similar to {@link retry}, where {@link retry} will resubscribe to the source in the error case, but\r\n * `repeat` will resubscribe if the source completes.\r\n *\r\n * Note that `repeat` will _not_ catch errors. Use {@link retry} for that.\r\n *\r\n * - `repeat(0)` returns an empty observable\r\n * - `repeat()` will repeat forever\r\n * - `repeat({ delay: 200 })` will repeat forever, with a delay of 200ms between repetitions.\r\n * - `repeat({ count: 2, delay: 400 })` will repeat twice, with a delay of 400ms between repetitions.\r\n * - `repeat({ delay: (count) => timer(count * 1000) })` will repeat forever, but will have a delay that grows by one second for each repetition.\r\n *\r\n * ## Example\r\n *\r\n * Repeat a message stream\r\n *\r\n * ```ts\r\n * import { of, repeat } from 'rxjs';\r\n *\r\n * const source = of('Repeat message');\r\n * const result = source.pipe(repeat(3));\r\n *\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Results\r\n * // 'Repeat message'\r\n * // 'Repeat message'\r\n * // 'Repeat message'\r\n * ```\r\n *\r\n * Repeat 3 values, 2 times\r\n *\r\n * ```ts\r\n * import { interval, take, repeat } from 'rxjs';\r\n *\r\n * const source = interval(1000);\r\n * const result = source.pipe(take(3), repeat(2));\r\n *\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Results every second\r\n * // 0\r\n * // 1\r\n * // 2\r\n * // 0\r\n * // 1\r\n * // 2\r\n * ```\r\n *\r\n * Defining two complex repeats with delays on the same source.\r\n * Note that the second repeat cannot be called until the first\r\n * repeat as exhausted it's count.\r\n *\r\n * ```ts\r\n * import { defer, of, repeat } from 'rxjs';\r\n *\r\n * const source = defer(() => {\r\n *    return of(`Hello, it is ${new Date()}`)\r\n * });\r\n *\r\n * source.pipe(\r\n *    // Repeat 3 times with a delay of 1 second between repetitions\r\n *    repeat({\r\n *      count: 3,\r\n *      delay: 1000,\r\n *    }),\r\n *\r\n *    // *Then* repeat forever, but with an exponential step-back\r\n *    // maxing out at 1 minute.\r\n *    repeat({\r\n *      delay: (count) => timer(Math.min(60000, 2 ^ count * 1000))\r\n *    })\r\n * )\r\n * ```\r\n *\r\n * @see {@link repeatWhen}\r\n * @see {@link retry}\r\n *\r\n * @param countOrConfig Either the number of times the source Observable items are repeated\r\n * (a count of 0 will yield an empty Observable) or a {@link RepeatConfig} object.\r\n */\r\nexport function repeat<T>(countOrConfig?: number | RepeatConfig): MonoTypeOperatorFunction<T> {\r\n  let count = Infinity;\r\n  let delay: RepeatConfig['delay'];\r\n\r\n  if (countOrConfig != null) {\r\n    if (typeof countOrConfig === 'object') {\r\n      ({ count = Infinity, delay } = countOrConfig);\r\n    } else {\r\n      count = countOrConfig;\r\n    }\r\n  }\r\n\r\n  return count <= 0\r\n    ? () => EMPTY\r\n    : operate((source, subscriber) => {\r\n        let soFar = 0;\r\n        let sourceSub: Subscription | null;\r\n\r\n        const resubscribe = () => {\r\n          sourceSub?.unsubscribe();\r\n          sourceSub = null;\r\n          if (delay != null) {\r\n            const notifier = typeof delay === 'number' ? timer(delay) : innerFrom(delay(soFar));\r\n            const notifierSubscriber = createOperatorSubscriber(subscriber, () => {\r\n              notifierSubscriber.unsubscribe();\r\n              subscribeToSource();\r\n            });\r\n            notifier.subscribe(notifierSubscriber);\r\n          } else {\r\n            subscribeToSource();\r\n          }\r\n        };\r\n\r\n        const subscribeToSource = () => {\r\n          let syncUnsub = false;\r\n          sourceSub = source.subscribe(\r\n            createOperatorSubscriber(subscriber, undefined, () => {\r\n              if (++soFar < count) {\r\n                if (sourceSub) {\r\n                  resubscribe();\r\n                } else {\r\n                  syncUnsub = true;\r\n                }\r\n              } else {\r\n                subscriber.complete();\r\n              }\r\n            })\r\n          );\r\n\r\n          if (syncUnsub) {\r\n            resubscribe();\r\n          }\r\n        };\r\n\r\n        subscribeToSource();\r\n      });\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { Subject } from '../Subject';\r\nimport { Subscription } from '../Subscription';\r\n\r\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\r\n * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\r\n * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\r\n * this method will resubscribe to the source Observable.\r\n *\r\n * ![](repeatWhen.png)\r\n *\r\n * ## Example\r\n *\r\n * Repeat a message stream on click\r\n *\r\n * ```ts\r\n * import { of, fromEvent, repeatWhen } from 'rxjs';\r\n *\r\n * const source = of('Repeat message');\r\n * const documentClick$ = fromEvent(document, 'click');\r\n *\r\n * const result = source.pipe(repeatWhen(() => documentClick$));\r\n *\r\n * result.subscribe(data => console.log(data))\r\n * ```\r\n *\r\n * @see {@link repeat}\r\n * @see {@link retry}\r\n * @see {@link retryWhen}\r\n *\r\n * @param notifier Function that receives an Observable of notifications with\r\n * which a user can `complete` or `error`, aborting the repetition.\r\n * @return A function that returns an Observable that mirrors the source\r\n * Observable with the exception of a `complete`.\r\n * @deprecated Will be removed in v9 or v10. Use {@link repeat}'s {@link RepeatConfig#delay delay} option instead.\r\n * Instead of `repeatWhen(() => notify$)`, use: `repeat({ delay: () => notify$ })`.\r\n */\r\nexport function repeatWhen<T>(notifier: (notifications: Observable<void>) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    let innerSub: Subscription | null;\r\n    let syncResub = false;\r\n    let completions$: Subject<void>;\r\n    let isNotifierComplete = false;\r\n    let isMainComplete = false;\r\n\r\n    /**\r\n     * Checks to see if we can complete the result, completes it, and returns `true` if it was completed.\r\n     */\r\n    const checkComplete = () => isMainComplete && isNotifierComplete && (subscriber.complete(), true);\r\n    /**\r\n     * Gets the subject to send errors through. If it doesn't exist,\r\n     * we know we need to setup the notifier.\r\n     */\r\n    const getCompletionSubject = () => {\r\n      if (!completions$) {\r\n        completions$ = new Subject();\r\n\r\n        // If the call to `notifier` throws, it will be caught by the OperatorSubscriber\r\n        // In the main subscription -- in `subscribeForRepeatWhen`.\r\n        innerFrom(notifier(completions$)).subscribe(\r\n          createOperatorSubscriber(\r\n            subscriber,\r\n            () => {\r\n              if (innerSub) {\r\n                subscribeForRepeatWhen();\r\n              } else {\r\n                // If we don't have an innerSub yet, that's because the inner subscription\r\n                // call hasn't even returned yet. We've arrived here synchronously.\r\n                // So we flag that we want to resub, such that we can ensure finalization\r\n                // happens before we resubscribe.\r\n                syncResub = true;\r\n              }\r\n            },\r\n            () => {\r\n              isNotifierComplete = true;\r\n              checkComplete();\r\n            }\r\n          )\r\n        );\r\n      }\r\n      return completions$;\r\n    };\r\n\r\n    const subscribeForRepeatWhen = () => {\r\n      isMainComplete = false;\r\n\r\n      innerSub = source.subscribe(\r\n        createOperatorSubscriber(subscriber, undefined, () => {\r\n          isMainComplete = true;\r\n          // Check to see if we are complete, and complete if so.\r\n          // If we are not complete. Get the subject. This calls the `notifier` function.\r\n          // If that function fails, it will throw and `.next()` will not be reached on this\r\n          // line. The thrown error is caught by the _complete handler in this\r\n          // `OperatorSubscriber` and handled appropriately.\r\n          !checkComplete() && getCompletionSubject().next();\r\n        })\r\n      );\r\n\r\n      if (syncResub) {\r\n        // Ensure that the inner subscription is torn down before\r\n        // moving on to the next subscription in the synchronous case.\r\n        // If we don't do this here, all inner subscriptions will not be\r\n        // torn down until the entire observable is done.\r\n        innerSub.unsubscribe();\r\n        // It is important to null this out. Not only to free up memory, but\r\n        // to make sure code above knows we are in a subscribing state to\r\n        // handle synchronous resubscription.\r\n        innerSub = null;\r\n        // We may need to do this multiple times, so reset the flags.\r\n        syncResub = false;\r\n        // Resubscribe\r\n        subscribeForRepeatWhen();\r\n      }\r\n    };\r\n\r\n    // Start the subscription\r\n    subscribeForRepeatWhen();\r\n  });\r\n}\r\n", "import { MonoTypeOperatorFunction, ObservableInput } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { Subscription } from '../Subscription';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { identity } from '../util/identity';\r\nimport { timer } from '../observable/timer';\r\nimport { innerFrom } from '../observable/innerFrom';\r\n\r\n/**\r\n * The {@link retry} operator configuration object. `retry` either accepts a `number`\r\n * or an object described by this interface.\r\n */\r\nexport interface RetryConfig {\r\n  /**\r\n   * The maximum number of times to retry. If `count` is omitted, `retry` will try to\r\n   * resubscribe on errors infinite number of times.\r\n   */\r\n  count?: number;\r\n  /**\r\n   * The number of milliseconds to delay before retrying, OR a function to\r\n   * return a notifier for delaying. If a function is given, that function should\r\n   * return a notifier that, when it emits will retry the source. If the notifier\r\n   * completes _without_ emitting, the resulting observable will complete without error,\r\n   * if the notifier errors, the error will be pushed to the result.\r\n   */\r\n  delay?: number | ((error: any, retryCount: number) => ObservableInput<any>);\r\n  /**\r\n   * Whether or not to reset the retry counter when the retried subscription\r\n   * emits its first value.\r\n   */\r\n  resetOnSuccess?: boolean;\r\n}\r\n\r\nexport function retry<T>(count?: number): MonoTypeOperatorFunction<T>;\r\nexport function retry<T>(config: RetryConfig): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * Returns an Observable that mirrors the source Observable with the exception of an `error`.\r\n *\r\n * If the source Observable calls `error`, this method will resubscribe to the source Observable for a maximum of\r\n * `count` resubscriptions rather than propagating the `error` call.\r\n *\r\n * ![](retry.png)\r\n *\r\n * The number of retries is determined by the `count` parameter. It can be set either by passing a number to\r\n * `retry` function or by setting `count` property when `retry` is configured using {@link RetryConfig}. If\r\n * `count` is omitted, `retry` will try to resubscribe on errors infinite number of times.\r\n *\r\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those\r\n * emitted during failed subscriptions. For example, if an Observable fails at first but emits `[1, 2]` then\r\n * succeeds the second time and emits: `[1, 2, 3, 4, 5, complete]` then the complete stream of emissions and\r\n * notifications would be: `[1, 2, 1, 2, 3, 4, 5, complete]`.\r\n *\r\n * ## Example\r\n *\r\n * ```ts\r\n * import { interval, mergeMap, throwError, of, retry } from 'rxjs';\r\n *\r\n * const source = interval(1000);\r\n * const result = source.pipe(\r\n *   mergeMap(val => val > 5 ? throwError(() => 'Error!') : of(val)),\r\n *   retry(2) // retry 2 times on error\r\n * );\r\n *\r\n * result.subscribe({\r\n *   next: value => console.log(value),\r\n *   error: err => console.log(`${ err }: Retried 2 times then quit!`)\r\n * });\r\n *\r\n * // Output:\r\n * // 0..1..2..3..4..5..\r\n * // 0..1..2..3..4..5..\r\n * // 0..1..2..3..4..5..\r\n * // 'Error!: Retried 2 times then quit!'\r\n * ```\r\n *\r\n * @see {@link retryWhen}\r\n *\r\n * @param configOrCount Either number of retry attempts before failing or a\r\n * {@link RetryConfig} object.\r\n * @return A function that returns an Observable that will resubscribe to the\r\n * source stream when the source stream errors, at most `count` times.\r\n */\r\nexport function retry<T>(configOrCount: number | RetryConfig = Infinity): MonoTypeOperatorFunction<T> {\r\n  let config: RetryConfig;\r\n  if (configOrCount && typeof configOrCount === 'object') {\r\n    config = configOrCount;\r\n  } else {\r\n    config = {\r\n      count: configOrCount as number,\r\n    };\r\n  }\r\n  const { count = Infinity, delay, resetOnSuccess: resetOnSuccess = false } = config;\r\n\r\n  return count <= 0\r\n    ? identity\r\n    : operate((source, subscriber) => {\r\n        let soFar = 0;\r\n        let innerSub: Subscription | null;\r\n        const subscribeForRetry = () => {\r\n          let syncUnsub = false;\r\n          innerSub = source.subscribe(\r\n            createOperatorSubscriber(\r\n              subscriber,\r\n              (value) => {\r\n                // If we're resetting on success\r\n                if (resetOnSuccess) {\r\n                  soFar = 0;\r\n                }\r\n                subscriber.next(value);\r\n              },\r\n              // Completions are passed through to consumer.\r\n              undefined,\r\n              (err) => {\r\n                if (soFar++ < count) {\r\n                  // We are still under our retry count\r\n                  const resub = () => {\r\n                    if (innerSub) {\r\n                      innerSub.unsubscribe();\r\n                      innerSub = null;\r\n                      subscribeForRetry();\r\n                    } else {\r\n                      syncUnsub = true;\r\n                    }\r\n                  };\r\n\r\n                  if (delay != null) {\r\n                    // The user specified a retry delay.\r\n                    // They gave us a number, use a timer, otherwise, it's a function,\r\n                    // and we're going to call it to get a notifier.\r\n                    const notifier = typeof delay === 'number' ? timer(delay) : innerFrom(delay(err, soFar));\r\n                    const notifierSubscriber = createOperatorSubscriber(\r\n                      subscriber,\r\n                      () => {\r\n                        // After we get the first notification, we\r\n                        // unsubscribe from the notifier, because we don't want anymore\r\n                        // and we resubscribe to the source.\r\n                        notifierSubscriber.unsubscribe();\r\n                        resub();\r\n                      },\r\n                      () => {\r\n                        // The notifier completed without emitting.\r\n                        // The author is telling us they want to complete.\r\n                        subscriber.complete();\r\n                      }\r\n                    );\r\n                    notifier.subscribe(notifierSubscriber);\r\n                  } else {\r\n                    // There was no notifier given. Just resub immediately.\r\n                    resub();\r\n                  }\r\n                } else {\r\n                  // We're past our maximum number of retries.\r\n                  // Just send along the error.\r\n                  subscriber.error(err);\r\n                }\r\n              }\r\n            )\r\n          );\r\n          if (syncUnsub) {\r\n            innerSub.unsubscribe();\r\n            innerSub = null;\r\n            subscribeForRetry();\r\n          }\r\n        };\r\n        subscribeForRetry();\r\n      });\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { Subject } from '../Subject';\r\nimport { Subscription } from '../Subscription';\r\n\r\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\r\n * calls `error`, this method will emit the Throwable that caused the error to the `ObservableInput` returned from `notifier`.\r\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\r\n * subscription. Otherwise this method will resubscribe to the source Observable.\r\n *\r\n * ![](retryWhen.png)\r\n *\r\n * Retry an observable sequence on error based on custom criteria.\r\n *\r\n * ## Example\r\n *\r\n * ```ts\r\n * import { interval, map, retryWhen, tap, delayWhen, timer } from 'rxjs';\r\n *\r\n * const source = interval(1000);\r\n * const result = source.pipe(\r\n *   map(value => {\r\n *     if (value > 5) {\r\n *       // error will be picked up by retryWhen\r\n *       throw value;\r\n *     }\r\n *     return value;\r\n *   }),\r\n *   retryWhen(errors =>\r\n *     errors.pipe(\r\n *       // log error message\r\n *       tap(value => console.log(`Value ${ value } was too high!`)),\r\n *       // restart in 5 seconds\r\n *       delayWhen(value => timer(value * 1000))\r\n *     )\r\n *   )\r\n * );\r\n *\r\n * result.subscribe(value => console.log(value));\r\n *\r\n * // results:\r\n * // 0\r\n * // 1\r\n * // 2\r\n * // 3\r\n * // 4\r\n * // 5\r\n * // 'Value 6 was too high!'\r\n * // - Wait 5 seconds then repeat\r\n * ```\r\n *\r\n * @see {@link retry}\r\n *\r\n * @param notifier Function that receives an Observable of notifications with which a\r\n * user can `complete` or `error`, aborting the retry.\r\n * @return A function that returns an Observable that mirrors the source\r\n * Observable with the exception of an `error`.\r\n * @deprecated Will be removed in v9 or v10, use {@link retry}'s `delay` option instead.\r\n * Will be removed in v9 or v10. Use {@link retry}'s {@link RetryConfig#delay delay} option instead.\r\n * Instead of `retryWhen(() => notify$)`, use: `retry({ delay: () => notify$ })`.\r\n */\r\nexport function retryWhen<T>(notifier: (errors: Observable<any>) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    let innerSub: Subscription | null;\r\n    let syncResub = false;\r\n    let errors$: Subject<any>;\r\n\r\n    const subscribeForRetryWhen = () => {\r\n      innerSub = source.subscribe(\r\n        createOperatorSubscriber(subscriber, undefined, undefined, (err) => {\r\n          if (!errors$) {\r\n            errors$ = new Subject();\r\n            innerFrom(notifier(errors$)).subscribe(\r\n              createOperatorSubscriber(subscriber, () =>\r\n                // If we have an innerSub, this was an asynchronous call, kick off the retry.\r\n                // Otherwise, if we don't have an innerSub yet, that's because the inner subscription\r\n                // call hasn't even returned yet. We've arrived here synchronously.\r\n                // So we flag that we want to resub, such that we can ensure finalization\r\n                // happens before we resubscribe.\r\n                innerSub ? subscribeForRetryWhen() : (syncResub = true)\r\n              )\r\n            );\r\n          }\r\n          if (errors$) {\r\n            // We have set up the notifier without error.\r\n            errors$.next(err);\r\n          }\r\n        })\r\n      );\r\n\r\n      if (syncResub) {\r\n        // Ensure that the inner subscription is torn down before\r\n        // moving on to the next subscription in the synchronous case.\r\n        // If we don't do this here, all inner subscriptions will not be\r\n        // torn down until the entire observable is done.\r\n        innerSub.unsubscribe();\r\n        innerSub = null;\r\n        // We may need to do this multiple times, so reset the flag.\r\n        syncResub = false;\r\n        // Resubscribe\r\n        subscribeForRetryWhen();\r\n      }\r\n    };\r\n\r\n    // Start the subscription\r\n    subscribeForRetryWhen();\r\n  });\r\n}\r\n", "import { innerFrom } from '../observable/innerFrom';\r\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { noop } from '../util/noop';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Emits the most recently emitted value from the source Observable whenever\r\n * another Observable, the `notifier`, emits.\r\n *\r\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\r\n * the `notifier` `ObservableInput` emits something.</span>\r\n *\r\n * ![](sample.png)\r\n *\r\n * Whenever the `notifier` `ObservableInput` emits a value, `sample`\r\n * looks at the source Observable and emits whichever value it has most recently\r\n * emitted since the previous sampling, unless the source has not emitted\r\n * anything since the previous sampling. The `notifier` is subscribed to as soon\r\n * as the output Observable is subscribed.\r\n *\r\n * ## Example\r\n *\r\n * On every click, sample the most recent `seconds` timer\r\n *\r\n * ```ts\r\n * import { fromEvent, interval, sample } from 'rxjs';\r\n *\r\n * const seconds = interval(1000);\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = seconds.pipe(sample(clicks));\r\n *\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link audit}\r\n * @see {@link debounce}\r\n * @see {@link sampleTime}\r\n * @see {@link throttle}\r\n *\r\n * @param notifier The `ObservableInput` to use for sampling the\r\n * source Observable.\r\n * @return A function that returns an Observable that emits the results of\r\n * sampling the values emitted by the source Observable whenever the notifier\r\n * Observable emits value or completes.\r\n */\r\nexport function sample<T>(notifier: ObservableInput<any>): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    let hasValue = false;\r\n    let lastValue: T | null = null;\r\n    source.subscribe(\r\n      createOperatorSubscriber(subscriber, (value) => {\r\n        hasValue = true;\r\n        lastValue = value;\r\n      })\r\n    );\r\n    innerFrom(notifier).subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        () => {\r\n          if (hasValue) {\r\n            hasValue = false;\r\n            const value = lastValue!;\r\n            lastValue = null;\r\n            subscriber.next(value);\r\n          }\r\n        },\r\n        noop\r\n      )\r\n    );\r\n  });\r\n}\r\n", "import { asyncScheduler } from '../scheduler/async';\r\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\r\nimport { sample } from './sample';\r\nimport { interval } from '../observable/interval';\r\n\r\n/**\r\n * Emits the most recently emitted value from the source Observable within\r\n * periodic time intervals.\r\n *\r\n * <span class=\"informal\">Samples the source Observable at periodic time\r\n * intervals, emitting what it samples.</span>\r\n *\r\n * ![](sampleTime.png)\r\n *\r\n * `sampleTime` periodically looks at the source Observable and emits whichever\r\n * value it has most recently emitted since the previous sampling, unless the\r\n * source has not emitted anything since the previous sampling. The sampling\r\n * happens periodically in time every `period` milliseconds (or the time unit\r\n * defined by the optional `scheduler` argument). The sampling starts as soon as\r\n * the output Observable is subscribed.\r\n *\r\n * ## Example\r\n *\r\n * Every second, emit the most recent click at most once\r\n *\r\n * ```ts\r\n * import { fromEvent, sampleTime } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(sampleTime(1000));\r\n *\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link auditTime}\r\n * @see {@link debounceTime}\r\n * @see {@link delay}\r\n * @see {@link sample}\r\n * @see {@link throttleTime}\r\n *\r\n * @param period The sampling period expressed in milliseconds or the time unit\r\n * determined internally by the optional `scheduler`.\r\n * @param scheduler The {@link SchedulerLike} to use for managing the timers\r\n * that handle the sampling.\r\n * @return A function that returns an Observable that emits the results of\r\n * sampling the values emitted by the source Observable at the specified time\r\n * interval.\r\n */\r\nexport function sampleTime<T>(period: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\r\n  return sample(interval(period, scheduler));\r\n}\r\n", "import { OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { scanInternals } from './scanInternals';\r\n\r\nexport function scan<V, A = V>(accumulator: (acc: A | V, value: V, index: number) => A): OperatorFunction<V, V | A>;\r\nexport function scan<V, A>(accumulator: (acc: A, value: V, index: number) => A, seed: A): OperatorFunction<V, A>;\r\nexport function scan<V, A, S>(accumulator: (acc: A | S, value: V, index: number) => A, seed: S): OperatorFunction<V, A>;\r\n\r\n// TODO: link to a \"redux pattern\" section in the guide (location TBD)\r\n\r\n/**\r\n * Useful for encapsulating and managing state. Applies an accumulator (or \"reducer function\")\r\n * to each value from the source after an initial state is established -- either via\r\n * a `seed` value (second argument), or from the first value from the source.\r\n *\r\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\r\n * accumulation state after each update</span>\r\n *\r\n * ![](scan.png)\r\n *\r\n * This operator maintains an internal state and emits it after processing each value as follows:\r\n *\r\n * 1. First value arrives\r\n *   - If a `seed` value was supplied (as the second argument to `scan`), let `state = seed` and `value = firstValue`.\r\n *   - If NO `seed` value was supplied (no second argument), let `state = firstValue` and go to 3.\r\n * 2. Let `state = accumulator(state, value)`.\r\n *   - If an error is thrown by `accumulator`, notify the consumer of an error. The process ends.\r\n * 3. Emit `state`.\r\n * 4. Next value arrives, let `value = nextValue`, go to 2.\r\n *\r\n * ## Examples\r\n *\r\n * An average of previous numbers. This example shows how\r\n * not providing a `seed` can prime the stream with the\r\n * first value from the source.\r\n *\r\n * ```ts\r\n * import { of, scan, map } from 'rxjs';\r\n *\r\n * const numbers$ = of(1, 2, 3);\r\n *\r\n * numbers$\r\n *   .pipe(\r\n *     // Get the sum of the numbers coming in.\r\n *     scan((total, n) => total + n),\r\n *     // Get the average by dividing the sum by the total number\r\n *     // received so far (which is 1 more than the zero-based index).\r\n *     map((sum, index) => sum / (index + 1))\r\n *   )\r\n *   .subscribe(console.log);\r\n * ```\r\n *\r\n * The Fibonacci sequence. This example shows how you can use\r\n * a seed to prime accumulation process. Also... you know... Fibonacci.\r\n * So important to like, computers and stuff that its whiteboarded\r\n * in job interviews. Now you can show them the Rx version! (Please don't, haha)\r\n *\r\n * ```ts\r\n * import { interval, scan, map, startWith } from 'rxjs';\r\n *\r\n * const firstTwoFibs = [0, 1];\r\n * // An endless stream of Fibonacci numbers.\r\n * const fibonacci$ = interval(1000).pipe(\r\n *   // Scan to get the fibonacci numbers (after 0, 1)\r\n *   scan(([a, b]) => [b, a + b], firstTwoFibs),\r\n *   // Get the second number in the tuple, it's the one you calculated\r\n *   map(([, n]) => n),\r\n *   // Start with our first two digits :)\r\n *   startWith(...firstTwoFibs)\r\n * );\r\n *\r\n * fibonacci$.subscribe(console.log);\r\n * ```\r\n *\r\n * @see {@link expand}\r\n * @see {@link mergeScan}\r\n * @see {@link reduce}\r\n * @see {@link switchScan}\r\n *\r\n * @param accumulator A \"reducer function\". This will be called for each value after an initial state is\r\n * acquired.\r\n * @param seed The initial state. If this is not provided, the first value from the source will\r\n * be used as the initial state, and emitted without going through the accumulator. All subsequent values\r\n * will be processed by the accumulator function. If this is provided, all values will go through\r\n * the accumulator function.\r\n * @return A function that returns an Observable of the accumulated values.\r\n */\r\nexport function scan<V, A, S>(accumulator: (acc: V | A | S, value: V, index: number) => A, seed?: S): OperatorFunction<V, V | A> {\r\n  // providing a seed of `undefined` *should* be valid and trigger\r\n  // hasSeed! so don't use `seed !== undefined` checks!\r\n  // For this reason, we have to check it here at the original call site\r\n  // otherwise inside Operator/Subscriber we won't know if `undefined`\r\n  // means they didn't provide anything or if they literally provided `undefined`\r\n  return operate(scanInternals(accumulator, seed as S, arguments.length >= 2, true));\r\n}\r\n", "import { OperatorFunction, ObservableInput } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { innerFrom } from '../observable/innerFrom';\r\n\r\n/**\r\n * Compares all values of two observables in sequence using an optional comparator function\r\n * and returns an observable of a single boolean value representing whether or not the two sequences\r\n * are equal.\r\n *\r\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\r\n *\r\n * ![](sequenceEqual.png)\r\n *\r\n * `sequenceEqual` subscribes to source observable and `compareTo` `ObservableInput` (that internally\r\n * gets converted to an observable) and buffers incoming values from each observable. Whenever either\r\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\r\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\r\n * observables completes, the operator will wait for the other observable to complete; If the other\r\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\r\n * completes or emits after the other completes, the returned observable will never complete.\r\n *\r\n * ## Example\r\n *\r\n * Figure out if the Konami code matches\r\n *\r\n * ```ts\r\n * import { from, fromEvent, map, bufferCount, mergeMap, sequenceEqual } from 'rxjs';\r\n *\r\n * const codes = from([\r\n *   'ArrowUp',\r\n *   'ArrowUp',\r\n *   'ArrowDown',\r\n *   'ArrowDown',\r\n *   'ArrowLeft',\r\n *   'ArrowRight',\r\n *   'ArrowLeft',\r\n *   'ArrowRight',\r\n *   'KeyB',\r\n *   'KeyA',\r\n *   'Enter', // no start key, clearly.\r\n * ]);\r\n *\r\n * const keys = fromEvent<KeyboardEvent>(document, 'keyup').pipe(map(e => e.code));\r\n * const matches = keys.pipe(\r\n *   bufferCount(11, 1),\r\n *   mergeMap(last11 => from(last11).pipe(sequenceEqual(codes)))\r\n * );\r\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\r\n * ```\r\n *\r\n * @see {@link combineLatest}\r\n * @see {@link zip}\r\n * @see {@link withLatestFrom}\r\n *\r\n * @param compareTo The `ObservableInput` sequence to compare the source sequence to.\r\n * @param comparator An optional function to compare each value pair.\r\n *\r\n * @return A function that returns an Observable that emits a single boolean\r\n * value representing whether or not the values emitted by the source\r\n * Observable and provided `ObservableInput` were equal in sequence.\r\n */\r\nexport function sequenceEqual<T>(\r\n  compareTo: ObservableInput<T>,\r\n  comparator: (a: T, b: T) => boolean = (a, b) => a === b\r\n): OperatorFunction<T, boolean> {\r\n  return operate((source, subscriber) => {\r\n    // The state for the source observable\r\n    const aState = createState<T>();\r\n    // The state for the compareTo observable;\r\n    const bState = createState<T>();\r\n\r\n    /** A utility to emit and complete */\r\n    const emit = (isEqual: boolean) => {\r\n      subscriber.next(isEqual);\r\n      subscriber.complete();\r\n    };\r\n\r\n    /**\r\n     * Creates a subscriber that subscribes to one of the sources, and compares its collected\r\n     * state -- `selfState` -- to the other source's collected state -- `otherState`. This\r\n     * is used for both streams.\r\n     */\r\n    const createSubscriber = (selfState: SequenceState<T>, otherState: SequenceState<T>) => {\r\n      const sequenceEqualSubscriber = createOperatorSubscriber(\r\n        subscriber,\r\n        (a: T) => {\r\n          const { buffer, complete } = otherState;\r\n          if (buffer.length === 0) {\r\n            // If there's no values in the other buffer\r\n            // and the other stream is complete, we know\r\n            // this isn't a match, because we got one more value.\r\n            // Otherwise, we push onto our buffer, so when the other\r\n            // stream emits, it can pull this value off our buffer and check it\r\n            // at the appropriate time.\r\n            complete ? emit(false) : selfState.buffer.push(a);\r\n          } else {\r\n            // If the other stream *does* have values in its buffer,\r\n            // pull the oldest one off so we can compare it to what we\r\n            // just got. If it wasn't a match, emit `false` and complete.\r\n            !comparator(a, buffer.shift()!) && emit(false);\r\n          }\r\n        },\r\n        () => {\r\n          // Or observable completed\r\n          selfState.complete = true;\r\n          const { complete, buffer } = otherState;\r\n          // If the other observable is also complete, and there's\r\n          // still stuff left in their buffer, it doesn't match, if their\r\n          // buffer is empty, then it does match. This is because we can't\r\n          // possibly get more values here anymore.\r\n          complete && emit(buffer.length === 0);\r\n          // Be sure to clean up our stream as soon as possible if we can.\r\n          sequenceEqualSubscriber?.unsubscribe();\r\n        }\r\n      );\r\n\r\n      return sequenceEqualSubscriber;\r\n    };\r\n\r\n    // Subscribe to each source.\r\n    source.subscribe(createSubscriber(aState, bState));\r\n    innerFrom(compareTo).subscribe(createSubscriber(bState, aState));\r\n  });\r\n}\r\n\r\n/**\r\n * A simple structure for the data used to test each sequence\r\n */\r\ninterface SequenceState<T> {\r\n  /** A temporary store for arrived values before they are checked */\r\n  buffer: T[];\r\n  /** Whether or not the sequence source has completed. */\r\n  complete: boolean;\r\n}\r\n\r\n/**\r\n * Creates a simple structure that is used to represent\r\n * data used to test each sequence.\r\n */\r\nfunction createState<T>(): SequenceState<T> {\r\n  return {\r\n    buffer: [],\r\n    complete: false,\r\n  };\r\n}\r\n", "import { innerFrom } from '../observable/innerFrom';\r\nimport { Subject } from '../Subject';\r\nimport { SafeSubscriber } from '../Subscriber';\r\nimport { Subscription } from '../Subscription';\r\nimport { MonoTypeOperatorFunction, SubjectLike, ObservableInput } from '../types';\r\nimport { operate } from '../util/lift';\r\n\r\nexport interface ShareConfig<T> {\r\n  /**\r\n   * The factory used to create the subject that will connect the source observable to\r\n   * multicast consumers.\r\n   */\r\n  connector?: () => SubjectLike<T>;\r\n  /**\r\n   * If `true`, the resulting observable will reset internal state on error from source and return to a \"cold\" state. This\r\n   * allows the resulting observable to be \"retried\" in the event of an error.\r\n   * If `false`, when an error comes from the source it will push the error into the connecting subject, and the subject\r\n   * will remain the connecting subject, meaning the resulting observable will not go \"cold\" again, and subsequent retries\r\n   * or resubscriptions will resubscribe to that same subject. In all cases, RxJS subjects will emit the same error again, however\r\n   * {@link ReplaySubject} will also push its buffered values before pushing the error.\r\n   * It is also possible to pass a notifier factory returning an `ObservableInput` instead which grants more fine-grained\r\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\r\n   */\r\n  resetOnError?: boolean | ((error: any) => ObservableInput<any>);\r\n  /**\r\n   * If `true`, the resulting observable will reset internal state on completion from source and return to a \"cold\" state. This\r\n   * allows the resulting observable to be \"repeated\" after it is done.\r\n   * If `false`, when the source completes, it will push the completion through the connecting subject, and the subject\r\n   * will remain the connecting subject, meaning the resulting observable will not go \"cold\" again, and subsequent repeats\r\n   * or resubscriptions will resubscribe to that same subject.\r\n   * It is also possible to pass a notifier factory returning an `ObservableInput` instead which grants more fine-grained\r\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\r\n   */\r\n  resetOnComplete?: boolean | (() => ObservableInput<any>);\r\n  /**\r\n   * If `true`, when the number of subscribers to the resulting observable reaches zero due to those subscribers unsubscribing, the\r\n   * internal state will be reset and the resulting observable will return to a \"cold\" state. This means that the next\r\n   * time the resulting observable is subscribed to, a new subject will be created and the source will be subscribed to\r\n   * again.\r\n   * If `false`, when the number of subscribers to the resulting observable reaches zero due to unsubscription, the subject\r\n   * will remain connected to the source, and new subscriptions to the result will be connected through that same subject.\r\n   * It is also possible to pass a notifier factory returning an `ObservableInput` instead which grants more fine-grained\r\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\r\n   */\r\n  resetOnRefCountZero?: boolean | (() => ObservableInput<any>);\r\n}\r\n\r\nexport function share<T>(): MonoTypeOperatorFunction<T>;\r\n\r\nexport function share<T>(options: ShareConfig<T>): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\r\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\r\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\r\n * This is an alias for `multicast(() => new Subject()), refCount()`.\r\n *\r\n * The subscription to the underlying source Observable can be reset (unsubscribe and resubscribe for new subscribers),\r\n * if the subscriber count to the shared observable drops to 0, or if the source Observable errors or completes. It is\r\n * possible to use notifier factories for the resets to allow for behaviors like conditional or delayed resets. Please\r\n * note that resetting on error or complete of the source Observable does not behave like a transparent retry or restart\r\n * of the source because the error or complete will be forwarded to all subscribers and their subscription will be\r\n * closed. Only new subscribers after a reset on error or complete happened will cause a fresh subscription to the\r\n * source. To achieve transparent retries or restarts pipe the source through appropriate operators before sharing.\r\n *\r\n * ![](share.png)\r\n *\r\n * ## Example\r\n *\r\n * Generate new multicast Observable from the `source` Observable value\r\n *\r\n * ```ts\r\n * import { interval, tap, map, take, share } from 'rxjs';\r\n *\r\n * const source = interval(1000).pipe(\r\n *   tap(x => console.log('Processing: ', x)),\r\n *   map(x => x * x),\r\n *   take(6),\r\n *   share()\r\n * );\r\n *\r\n * source.subscribe(x => console.log('subscription 1: ', x));\r\n * source.subscribe(x => console.log('subscription 2: ', x));\r\n *\r\n * // Logs:\r\n * // Processing: 0\r\n * // subscription 1: 0\r\n * // subscription 2: 0\r\n * // Processing: 1\r\n * // subscription 1: 1\r\n * // subscription 2: 1\r\n * // Processing: 2\r\n * // subscription 1: 4\r\n * // subscription 2: 4\r\n * // Processing: 3\r\n * // subscription 1: 9\r\n * // subscription 2: 9\r\n * // Processing: 4\r\n * // subscription 1: 16\r\n * // subscription 2: 16\r\n * // Processing: 5\r\n * // subscription 1: 25\r\n * // subscription 2: 25\r\n * ```\r\n *\r\n * ## Example with notifier factory: Delayed reset\r\n *\r\n * ```ts\r\n * import { interval, take, share, timer } from 'rxjs';\r\n *\r\n * const source = interval(1000).pipe(\r\n *   take(3),\r\n *   share({\r\n *     resetOnRefCountZero: () => timer(1000)\r\n *   })\r\n * );\r\n *\r\n * const subscriptionOne = source.subscribe(x => console.log('subscription 1: ', x));\r\n * setTimeout(() => subscriptionOne.unsubscribe(), 1300);\r\n *\r\n * setTimeout(() => source.subscribe(x => console.log('subscription 2: ', x)), 1700);\r\n *\r\n * setTimeout(() => source.subscribe(x => console.log('subscription 3: ', x)), 5000);\r\n *\r\n * // Logs:\r\n * // subscription 1:  0\r\n * // (subscription 1 unsubscribes here)\r\n * // (subscription 2 subscribes here ~400ms later, source was not reset)\r\n * // subscription 2:  1\r\n * // subscription 2:  2\r\n * // (subscription 2 unsubscribes here)\r\n * // (subscription 3 subscribes here ~2000ms later, source did reset before)\r\n * // subscription 3:  0\r\n * // subscription 3:  1\r\n * // subscription 3:  2\r\n * ```\r\n *\r\n * @see {@link shareReplay}\r\n *\r\n * @return A function that returns an Observable that mirrors the source.\r\n */\r\nexport function share<T>(options: ShareConfig<T> = {}): MonoTypeOperatorFunction<T> {\r\n  const { connector = () => new Subject<T>(), resetOnError = true, resetOnComplete = true, resetOnRefCountZero = true } = options;\r\n  // It's necessary to use a wrapper here, as the _operator_ must be\r\n  // referentially transparent. Otherwise, it cannot be used in calls to the\r\n  // static `pipe` function - to create a partial pipeline.\r\n  //\r\n  // The _operator function_ - the function returned by the _operator_ - will\r\n  // not be referentially transparent - as it shares its source - but the\r\n  // _operator function_ is called when the complete pipeline is composed via a\r\n  // call to a source observable's `pipe` method - not when the static `pipe`\r\n  // function is called.\r\n  return (wrapperSource) => {\r\n    let connection: SafeSubscriber<T> | undefined;\r\n    let resetConnection: Subscription | undefined;\r\n    let subject: SubjectLike<T> | undefined;\r\n    let refCount = 0;\r\n    let hasCompleted = false;\r\n    let hasErrored = false;\r\n\r\n    const cancelReset = () => {\r\n      resetConnection?.unsubscribe();\r\n      resetConnection = undefined;\r\n    };\r\n    // Used to reset the internal state to a \"cold\"\r\n    // state, as though it had never been subscribed to.\r\n    const reset = () => {\r\n      cancelReset();\r\n      connection = subject = undefined;\r\n      hasCompleted = hasErrored = false;\r\n    };\r\n    const resetAndUnsubscribe = () => {\r\n      // We need to capture the connection before\r\n      // we reset (if we need to reset).\r\n      const conn = connection;\r\n      reset();\r\n      conn?.unsubscribe();\r\n    };\r\n\r\n    return operate<T, T>((source, subscriber) => {\r\n      refCount++;\r\n      if (!hasErrored && !hasCompleted) {\r\n        cancelReset();\r\n      }\r\n\r\n      // Create the subject if we don't have one yet. Grab a local reference to\r\n      // it as well, which avoids non-null assertions when using it and, if we\r\n      // connect to it now, then error/complete need a reference after it was\r\n      // reset.\r\n      const dest = (subject = subject ?? connector());\r\n\r\n      // Add the finalization directly to the subscriber - instead of returning it -\r\n      // so that the handling of the subscriber's unsubscription will be wired\r\n      // up _before_ the subscription to the source occurs. This is done so that\r\n      // the assignment to the source connection's `closed` property will be seen\r\n      // by synchronous firehose sources.\r\n      subscriber.add(() => {\r\n        refCount--;\r\n\r\n        // If we're resetting on refCount === 0, and it's 0, we only want to do\r\n        // that on \"unsubscribe\", really. Resetting on error or completion is a different\r\n        // configuration.\r\n        if (refCount === 0 && !hasErrored && !hasCompleted) {\r\n          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);\r\n        }\r\n      });\r\n\r\n      // The following line adds the subscription to the subscriber passed.\r\n      // Basically, `subscriber === dest.subscribe(subscriber)` is `true`.\r\n      dest.subscribe(subscriber);\r\n\r\n      if (\r\n        !connection &&\r\n        // Check this shareReplay is still activate - it can be reset to 0\r\n        // and be \"unsubscribed\" _before_ it actually subscribes.\r\n        // If we were to subscribe then, it'd leak and get stuck.\r\n        refCount > 0\r\n      ) {\r\n        // We need to create a subscriber here - rather than pass an observer and\r\n        // assign the returned subscription to connection - because it's possible\r\n        // for reentrant subscriptions to the shared observable to occur and in\r\n        // those situations we want connection to be already-assigned so that we\r\n        // don't create another connection to the source.\r\n        connection = new SafeSubscriber({\r\n          next: (value) => dest.next(value),\r\n          error: (err) => {\r\n            hasErrored = true;\r\n            cancelReset();\r\n            resetConnection = handleReset(reset, resetOnError, err);\r\n            dest.error(err);\r\n          },\r\n          complete: () => {\r\n            hasCompleted = true;\r\n            cancelReset();\r\n            resetConnection = handleReset(reset, resetOnComplete);\r\n            dest.complete();\r\n          },\r\n        });\r\n        innerFrom(source).subscribe(connection);\r\n      }\r\n    })(wrapperSource);\r\n  };\r\n}\r\n\r\nfunction handleReset<T extends unknown[] = never[]>(\r\n  reset: () => void,\r\n  on: boolean | ((...args: T) => ObservableInput<any>),\r\n  ...args: T\r\n): Subscription | undefined {\r\n  if (on === true) {\r\n    reset();\r\n    return;\r\n  }\r\n\r\n  if (on === false) {\r\n    return;\r\n  }\r\n\r\n  const onSubscriber = new SafeSubscriber({\r\n    next: () => {\r\n      onSubscriber.unsubscribe();\r\n      reset();\r\n    },\r\n  });\r\n\r\n  return innerFrom(on(...args)).subscribe(onSubscriber);\r\n}\r\n", "import { ReplaySubject } from '../ReplaySubject';\r\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\r\nimport { share } from './share';\r\n\r\nexport interface ShareReplayConfig {\r\n  bufferSize?: number;\r\n  windowTime?: number;\r\n  refCount: boolean;\r\n  scheduler?: SchedulerLike;\r\n}\r\n\r\nexport function shareReplay<T>(config: ShareReplayConfig): MonoTypeOperatorFunction<T>;\r\nexport function shareReplay<T>(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * Share source and replay specified number of emissions on subscription.\r\n *\r\n * This operator is a specialization of `replay` that connects to a source observable\r\n * and multicasts through a `ReplaySubject` constructed with the specified arguments.\r\n * A successfully completed source will stay cached in the `shareReplay`ed observable forever,\r\n * but an errored source can be retried.\r\n *\r\n * ## Why use `shareReplay`?\r\n *\r\n * You generally want to use `shareReplay` when you have side-effects or taxing computations\r\n * that you do not wish to be executed amongst multiple subscribers.\r\n * It may also be valuable in situations where you know you will have late subscribers to\r\n * a stream that need access to previously emitted values.\r\n * This ability to replay values on subscription is what differentiates {@link share} and `shareReplay`.\r\n *\r\n * ## Reference counting\r\n *\r\n * By default `shareReplay` will use `refCount` of false, meaning that it will _not_ unsubscribe the\r\n * source when the reference counter drops to zero, i.e. the inner `ReplaySubject` will _not_ be unsubscribed\r\n * (and potentially run for ever).\r\n * This is the default as it is expected that `shareReplay` is often used to keep around expensive to setup\r\n * observables which we want to keep running instead of having to do the expensive setup again.\r\n *\r\n * As of RXJS version 6.4.0 a new overload signature was added to allow for manual control over what\r\n * happens when the operators internal reference counter drops to zero.\r\n * If `refCount` is true, the source will be unsubscribed from once the reference count drops to zero, i.e.\r\n * the inner `ReplaySubject` will be unsubscribed. All new subscribers will receive value emissions from a\r\n * new `ReplaySubject` which in turn will cause a new subscription to the source observable.\r\n *\r\n * ## Examples\r\n *\r\n * Example with a third subscriber coming late to the party\r\n *\r\n * ```ts\r\n * import { interval, take, shareReplay } from 'rxjs';\r\n *\r\n * const shared$ = interval(2000).pipe(\r\n *   take(6),\r\n *   shareReplay(3)\r\n * );\r\n *\r\n * shared$.subscribe(x => console.log('sub A: ', x));\r\n * shared$.subscribe(y => console.log('sub B: ', y));\r\n *\r\n * setTimeout(() => {\r\n *   shared$.subscribe(y => console.log('sub C: ', y));\r\n * }, 11000);\r\n *\r\n * // Logs:\r\n * // (after ~2000 ms)\r\n * // sub A: 0\r\n * // sub B: 0\r\n * // (after ~4000 ms)\r\n * // sub A: 1\r\n * // sub B: 1\r\n * // (after ~6000 ms)\r\n * // sub A: 2\r\n * // sub B: 2\r\n * // (after ~8000 ms)\r\n * // sub A: 3\r\n * // sub B: 3\r\n * // (after ~10000 ms)\r\n * // sub A: 4\r\n * // sub B: 4\r\n * // (after ~11000 ms, sub C gets the last 3 values)\r\n * // sub C: 2\r\n * // sub C: 3\r\n * // sub C: 4\r\n * // (after ~12000 ms)\r\n * // sub A: 5\r\n * // sub B: 5\r\n * // sub C: 5\r\n * ```\r\n *\r\n * Example for `refCount` usage\r\n *\r\n * ```ts\r\n * import { Observable, tap, interval, shareReplay, take } from 'rxjs';\r\n *\r\n * const log = <T>(name: string, source: Observable<T>) => source.pipe(\r\n *   tap({\r\n *     subscribe: () => console.log(`${ name }: subscribed`),\r\n *     next: value => console.log(`${ name }: ${ value }`),\r\n *     complete: () => console.log(`${ name }: completed`),\r\n *     finalize: () => console.log(`${ name }: unsubscribed`)\r\n *   })\r\n * );\r\n *\r\n * const obs$ = log('source', interval(1000));\r\n *\r\n * const shared$ = log('shared', obs$.pipe(\r\n *   shareReplay({ bufferSize: 1, refCount: true }),\r\n *   take(2)\r\n * ));\r\n *\r\n * shared$.subscribe(x => console.log('sub A: ', x));\r\n * shared$.subscribe(y => console.log('sub B: ', y));\r\n *\r\n * // PRINTS:\r\n * // shared: subscribed <-- reference count = 1\r\n * // source: subscribed\r\n * // shared: subscribed <-- reference count = 2\r\n * // source: 0\r\n * // shared: 0\r\n * // sub A: 0\r\n * // shared: 0\r\n * // sub B: 0\r\n * // source: 1\r\n * // shared: 1\r\n * // sub A: 1\r\n * // shared: completed <-- take(2) completes the subscription for sub A\r\n * // shared: unsubscribed <-- reference count = 1\r\n * // shared: 1\r\n * // sub B: 1\r\n * // shared: completed <-- take(2) completes the subscription for sub B\r\n * // shared: unsubscribed <-- reference count = 0\r\n * // source: unsubscribed <-- replaySubject unsubscribes from source observable because the reference count dropped to 0 and refCount is true\r\n *\r\n * // In case of refCount being false, the unsubscribe is never called on the source and the source would keep on emitting, even if no subscribers\r\n * // are listening.\r\n * // source: 2\r\n * // source: 3\r\n * // source: 4\r\n * // ...\r\n * ```\r\n *\r\n * @see {@link publish}\r\n * @see {@link share}\r\n * @see {@link publishReplay}\r\n *\r\n * @param configOrBufferSize Maximum element count of the replay buffer or {@link ShareReplayConfig configuration}\r\n * object.\r\n * @param windowTime Maximum time length of the replay buffer in milliseconds.\r\n * @param scheduler Scheduler where connected observers within the selector function\r\n * will be invoked on.\r\n * @return A function that returns an Observable sequence that contains the\r\n * elements of a sequence produced by multicasting the source sequence within a\r\n * selector function.\r\n */\r\nexport function shareReplay<T>(\r\n  configOrBufferSize?: ShareReplayConfig | number,\r\n  windowTime?: number,\r\n  scheduler?: SchedulerLike\r\n): MonoTypeOperatorFunction<T> {\r\n  let bufferSize: number;\r\n  let refCount = false;\r\n  if (configOrBufferSize && typeof configOrBufferSize === 'object') {\r\n    ({ bufferSize = Infinity, windowTime = Infinity, refCount = false, scheduler } = configOrBufferSize);\r\n  } else {\r\n    bufferSize = (configOrBufferSize ?? Infinity) as number;\r\n  }\r\n  return share<T>({\r\n    connector: () => new ReplaySubject(bufferSize, windowTime, scheduler),\r\n    resetOnError: true,\r\n    resetOnComplete: false,\r\n    resetOnRefCountZero: refCount,\r\n  });\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { EmptyError } from '../util/EmptyError';\r\n\r\nimport { MonoTypeOperatorFunction, OperatorFunction, TruthyTypesOf } from '../types';\r\nimport { SequenceError } from '../util/SequenceError';\r\nimport { NotFoundError } from '../util/NotFoundError';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\nexport function single<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\r\nexport function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * Returns an observable that asserts that only one value is\r\n * emitted from the observable that matches the predicate. If no\r\n * predicate is provided, then it will assert that the observable\r\n * only emits one value.\r\n *\r\n * If the source Observable did not emit `next` before completion, it\r\n * will emit an {@link EmptyError} to the Observer's `error` callback.\r\n *\r\n * In the event that two values are found that match the predicate,\r\n * or when there are two values emitted and no predicate, it will\r\n * emit a {@link SequenceError} to the Observer's `error` callback.\r\n *\r\n * In the event that no values match the predicate, if one is provided,\r\n * it will emit a {@link NotFoundError} to the Observer's `error` callback.\r\n *\r\n * ## Example\r\n *\r\n * Expect only `name` beginning with `'B'`\r\n *\r\n * ```ts\r\n * import { of, single } from 'rxjs';\r\n *\r\n * const source1 = of(\r\n *  { name: 'Ben' },\r\n *  { name: 'Tracy' },\r\n *  { name: 'Laney' },\r\n *  { name: 'Lily' }\r\n * );\r\n *\r\n * source1\r\n *   .pipe(single(x => x.name.startsWith('B')))\r\n *   .subscribe(x => console.log(x));\r\n * // Emits 'Ben'\r\n *\r\n *\r\n * const source2 = of(\r\n *  { name: 'Ben' },\r\n *  { name: 'Tracy' },\r\n *  { name: 'Bradley' },\r\n *  { name: 'Lincoln' }\r\n * );\r\n *\r\n * source2\r\n *   .pipe(single(x => x.name.startsWith('B')))\r\n *   .subscribe({ error: err => console.error(err) });\r\n * // Error emitted: SequenceError('Too many values match')\r\n *\r\n *\r\n * const source3 = of(\r\n *  { name: 'Laney' },\r\n *  { name: 'Tracy' },\r\n *  { name: 'Lily' },\r\n *  { name: 'Lincoln' }\r\n * );\r\n *\r\n * source3\r\n *   .pipe(single(x => x.name.startsWith('B')))\r\n *   .subscribe({ error: err => console.error(err) });\r\n * // Error emitted: NotFoundError('No values match')\r\n * ```\r\n *\r\n * @see {@link first}\r\n * @see {@link find}\r\n * @see {@link findIndex}\r\n * @see {@link elementAt}\r\n *\r\n * @throws {NotFoundError} Delivers a `NotFoundError` to the Observer's `error`\r\n * callback if the Observable completes before any `next` notification was sent.\r\n * @throws {SequenceError} Delivers a `SequenceError` if more than one value is\r\n * emitted that matches the provided predicate. If no predicate is provided, it\r\n * will deliver a `SequenceError` if more than one value comes from the source.\r\n * @throws {EmptyError} Delivers an `EmptyError` if no values were `next`ed prior\r\n * to completion.\r\n *\r\n * @param predicate A predicate function to evaluate items emitted by the source\r\n * Observable.\r\n * @return A function that returns an Observable that emits the single item\r\n * emitted by the source Observable that matches the predicate.\r\n */\r\nexport function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    let hasValue = false;\r\n    let singleValue: T;\r\n    let seenValue = false;\r\n    let index = 0;\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value) => {\r\n          seenValue = true;\r\n          if (!predicate || predicate(value, index++, source)) {\r\n            hasValue && subscriber.error(new SequenceError('Too many matching values'));\r\n            hasValue = true;\r\n            singleValue = value;\r\n          }\r\n        },\r\n        () => {\r\n          if (hasValue) {\r\n            subscriber.next(singleValue);\r\n            subscriber.complete();\r\n          } else {\r\n            subscriber.error(seenValue ? new NotFoundError('No matching values') : new EmptyError());\r\n          }\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n", "import { MonoTypeOperatorFunction } from '../types';\r\nimport { filter } from './filter';\r\n\r\n/**\r\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\r\n *\r\n * ![](skip.png)\r\n *\r\n * Skips the values until the sent notifications are equal or less than provided skip count. It raises\r\n * an error if skip count is equal or more than the actual number of emits and source raises an error.\r\n *\r\n * ## Example\r\n *\r\n * Skip the values before the emission\r\n *\r\n * ```ts\r\n * import { interval, skip } from 'rxjs';\r\n *\r\n * // emit every half second\r\n * const source = interval(500);\r\n * // skip the first 10 emitted values\r\n * const result = source.pipe(skip(10));\r\n *\r\n * result.subscribe(value => console.log(value));\r\n * // output: 10...11...12...13...\r\n * ```\r\n *\r\n * @see {@link last}\r\n * @see {@link skipWhile}\r\n * @see {@link skipUntil}\r\n * @see {@link skipLast}\r\n *\r\n * @param count The number of times, items emitted by source Observable should be skipped.\r\n * @return A function that returns an Observable that skips the first `count`\r\n * values emitted by the source Observable.\r\n */\r\nexport function skip<T>(count: number): MonoTypeOperatorFunction<T> {\r\n  return filter((_, index) => count <= index);\r\n}\r\n", "import { MonoTypeOperatorFunction } from '../types';\r\nimport { identity } from '../util/identity';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Skip a specified number of values before the completion of an observable.\r\n *\r\n * ![](skipLast.png)\r\n *\r\n * Returns an observable that will emit values as soon as it can, given a number of\r\n * skipped values. For example, if you `skipLast(3)` on a source, when the source\r\n * emits its fourth value, the first value the source emitted will finally be emitted\r\n * from the returned observable, as it is no longer part of what needs to be skipped.\r\n *\r\n * All values emitted by the result of `skipLast(N)` will be delayed by `N` emissions,\r\n * as each value is held in a buffer until enough values have been emitted that that\r\n * the buffered value may finally be sent to the consumer.\r\n *\r\n * After subscribing, unsubscribing will not result in the emission of the buffered\r\n * skipped values.\r\n *\r\n * ## Example\r\n *\r\n * Skip the last 2 values of an observable with many values\r\n *\r\n * ```ts\r\n * import { of, skipLast } from 'rxjs';\r\n *\r\n * const numbers = of(1, 2, 3, 4, 5);\r\n * const skipLastTwo = numbers.pipe(skipLast(2));\r\n * skipLastTwo.subscribe(x => console.log(x));\r\n *\r\n * // Results in:\r\n * // 1 2 3\r\n * // (4 and 5 are skipped)\r\n * ```\r\n *\r\n * @see {@link skip}\r\n * @see {@link skipUntil}\r\n * @see {@link skipWhile}\r\n * @see {@link take}\r\n *\r\n * @param skipCount Number of elements to skip from the end of the source Observable.\r\n * @return A function that returns an Observable that skips the last `count`\r\n * values emitted by the source Observable.\r\n */\r\nexport function skipLast<T>(skipCount: number): MonoTypeOperatorFunction<T> {\r\n  return skipCount <= 0\r\n    ? // For skipCounts less than or equal to zero, we are just mirroring the source.\r\n      identity\r\n    : operate((source, subscriber) => {\r\n        // A ring buffer to hold the values while we wait to see\r\n        // if we can emit it or it's part of the \"skipped\" last values.\r\n        // Note that it is the _same size_ as the skip count.\r\n        let ring: T[] = new Array(skipCount);\r\n        // The number of values seen so far. This is used to get\r\n        // the index of the current value when it arrives.\r\n        let seen = 0;\r\n        source.subscribe(\r\n          createOperatorSubscriber(subscriber, (value) => {\r\n            // Get the index of the value we have right now\r\n            // relative to all other values we've seen, then\r\n            // increment `seen`. This ensures we've moved to\r\n            // the next slot in our ring buffer.\r\n            const valueIndex = seen++;\r\n            if (valueIndex < skipCount) {\r\n              // If we haven't seen enough values to fill our buffer yet,\r\n              // Then we aren't to a number of seen values where we can\r\n              // emit anything, so let's just start by filling the ring buffer.\r\n              ring[valueIndex] = value;\r\n            } else {\r\n              // We are traversing over the ring array in such\r\n              // a way that when we get to the end, we loop back\r\n              // and go to the start.\r\n              const index = valueIndex % skipCount;\r\n              // Pull the oldest value out so we can emit it,\r\n              // and stuff the new value in it's place.\r\n              const oldValue = ring[index];\r\n              ring[index] = value;\r\n              // Emit the old value. It is important that this happens\r\n              // after we swap the value in the buffer, if it happens\r\n              // before we swap the value in the buffer, then a synchronous\r\n              // source can get the buffer out of whack.\r\n              subscriber.next(oldValue);\r\n            }\r\n          })\r\n        );\r\n\r\n        return () => {\r\n          // Release our values in memory\r\n          ring = null!;\r\n        };\r\n      });\r\n}\r\n", "import { MonoTypeOperatorFunction, ObservableInput } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { noop } from '../util/noop';\r\n\r\n/**\r\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\r\n *\r\n * The `skipUntil` operator causes the observable stream to skip the emission of values until the passed in observable\r\n * emits the first value. This can be particularly useful in combination with user interactions, responses of HTTP\r\n * requests or waiting for specific times to pass by.\r\n *\r\n * ![](skipUntil.png)\r\n *\r\n * Internally, the `skipUntil` operator subscribes to the passed in `notifier` `ObservableInput` (which gets converted\r\n * to an Observable) in order to recognize the emission of its first value. When `notifier` emits next, the operator\r\n * unsubscribes from it and starts emitting the values of the *source* observable until it completes or errors. It\r\n * will never let the *source* observable emit any values if the `notifier` completes or throws an error without\r\n * emitting a value before.\r\n *\r\n * ## Example\r\n *\r\n * In the following example, all emitted values of the interval observable are skipped until the user clicks anywhere\r\n * within the page\r\n *\r\n * ```ts\r\n * import { interval, fromEvent, skipUntil } from 'rxjs';\r\n *\r\n * const intervalObservable = interval(1000);\r\n * const click = fromEvent(document, 'click');\r\n *\r\n * const emitAfterClick = intervalObservable.pipe(\r\n *   skipUntil(click)\r\n * );\r\n * // clicked at 4.6s. output: 5...6...7...8........ or\r\n * // clicked at 7.3s. output: 8...9...10..11.......\r\n * emitAfterClick.subscribe(value => console.log(value));\r\n * ```\r\n *\r\n * @see {@link last}\r\n * @see {@link skip}\r\n * @see {@link skipWhile}\r\n * @see {@link skipLast}\r\n *\r\n * @param notifier An `ObservableInput` that has to emit an item before the source Observable elements begin to\r\n * be mirrored by the resulting Observable.\r\n * @return A function that returns an Observable that skips items from the\r\n * source Observable until the `notifier` Observable emits an item, then emits the\r\n * remaining items.\r\n */\r\nexport function skipUntil<T>(notifier: ObservableInput<any>): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    let taking = false;\r\n\r\n    const skipSubscriber = createOperatorSubscriber(\r\n      subscriber,\r\n      () => {\r\n        skipSubscriber?.unsubscribe();\r\n        taking = true;\r\n      },\r\n      noop\r\n    );\r\n\r\n    innerFrom(notifier).subscribe(skipSubscriber);\r\n\r\n    source.subscribe(createOperatorSubscriber(subscriber, (value) => taking && subscriber.next(value)));\r\n  });\r\n}\r\n", "import { Falsy, MonoTypeOperatorFunction, OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\nexport function skipWhile<T>(predicate: BooleanConstructor): OperatorFunction<T, Extract<T, Falsy> extends never ? never : T>;\r\nexport function skipWhile<T>(predicate: (value: T, index: number) => true): OperatorFunction<T, never>;\r\nexport function skipWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\r\n * true, but emits all further source items as soon as the condition becomes false.\r\n *\r\n * ![](skipWhile.png)\r\n *\r\n * Skips all the notifications with a truthy predicate. It will not skip the notifications when the predicate is falsy.\r\n * It can also be skipped using index. Once the predicate is true, it will not be called again.\r\n *\r\n * ## Example\r\n *\r\n * Skip some super heroes\r\n *\r\n * ```ts\r\n * import { from, skipWhile } from 'rxjs';\r\n *\r\n * const source = from(['Green Arrow', 'SuperMan', 'Flash', 'SuperGirl', 'Black Canary'])\r\n * // Skip the heroes until SuperGirl\r\n * const example = source.pipe(skipWhile(hero => hero !== 'SuperGirl'));\r\n * // output: SuperGirl, Black Canary\r\n * example.subscribe(femaleHero => console.log(femaleHero));\r\n * ```\r\n *\r\n * Skip values from the array until index 5\r\n *\r\n * ```ts\r\n * import { from, skipWhile } from 'rxjs';\r\n *\r\n * const source = from([1, 2, 3, 4, 5, 6, 7, 9, 10]);\r\n * const example = source.pipe(skipWhile((_, i) => i !== 5));\r\n * // output: 6, 7, 9, 10\r\n * example.subscribe(value => console.log(value));\r\n * ```\r\n *\r\n * @see {@link last}\r\n * @see {@link skip}\r\n * @see {@link skipUntil}\r\n * @see {@link skipLast}\r\n *\r\n * @param predicate A function to test each item emitted from the source Observable.\r\n * @return A function that returns an Observable that begins emitting items\r\n * emitted by the source Observable when the specified predicate becomes false.\r\n */\r\nexport function skipWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    let taking = false;\r\n    let index = 0;\r\n    source.subscribe(\r\n      createOperatorSubscriber(subscriber, (value) => (taking || (taking = !predicate(value, index++))) && subscriber.next(value))\r\n    );\r\n  });\r\n}\r\n", "import { concat } from '../observable/concat';\r\nimport { OperatorFunction, SchedulerLike, ValueFromArray } from '../types';\r\nimport { popScheduler } from '../util/args';\r\nimport { operate } from '../util/lift';\r\n\r\n// Devs are more likely to pass null or undefined than they are a scheduler\r\n// without accompanying values. To make things easier for (naughty) devs who\r\n// use the `strictNullChecks: false` TypeScript compiler option, these\r\n// overloads with explicit null and undefined values are included.\r\n\r\nexport function startWith<T>(value: null): OperatorFunction<T, T | null>;\r\nexport function startWith<T>(value: undefined): OperatorFunction<T, T | undefined>;\r\n\r\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `concatAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\r\nexport function startWith<T, A extends readonly unknown[] = T[]>(\r\n  ...valuesAndScheduler: [...A, SchedulerLike]\r\n): OperatorFunction<T, T | ValueFromArray<A>>;\r\nexport function startWith<T, A extends readonly unknown[] = T[]>(...values: A): OperatorFunction<T, T | ValueFromArray<A>>;\r\n\r\n/**\r\n * Returns an observable that, at the moment of subscription, will synchronously emit all\r\n * values provided to this operator, then subscribe to the source and mirror all of its emissions\r\n * to subscribers.\r\n *\r\n * This is a useful way to know when subscription has occurred on an existing observable.\r\n *\r\n * <span class=\"informal\">First emits its arguments in order, and then any\r\n * emissions from the source.</span>\r\n *\r\n * ![](startWith.png)\r\n *\r\n * ## Examples\r\n *\r\n * Emit a value when a timer starts.\r\n *\r\n * ```ts\r\n * import { timer, map, startWith } from 'rxjs';\r\n *\r\n * timer(1000)\r\n *   .pipe(\r\n *     map(() => 'timer emit'),\r\n *     startWith('timer start')\r\n *   )\r\n *   .subscribe(x => console.log(x));\r\n *\r\n * // results:\r\n * // 'timer start'\r\n * // 'timer emit'\r\n * ```\r\n *\r\n * @param values Items you want the modified Observable to emit first.\r\n * @return A function that returns an Observable that synchronously emits\r\n * provided values before subscribing to the source Observable.\r\n *\r\n * @see {@link endWith}\r\n * @see {@link finalize}\r\n * @see {@link concat}\r\n */\r\nexport function startWith<T, D>(...values: D[]): OperatorFunction<T, T | D> {\r\n  const scheduler = popScheduler(values);\r\n  return operate((source, subscriber) => {\r\n    // Here we can't pass `undefined` as a scheduler, because if we did, the\r\n    // code inside of `concat` would be confused by the `undefined`, and treat it\r\n    // like an invalid observable. So we have to split it two different ways.\r\n    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);\r\n  });\r\n}\r\n", "import { Subscriber } from '../Subscriber';\r\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/* tslint:disable:max-line-length */\r\nexport function switchMap<T, O extends ObservableInput<any>>(\r\n  project: (value: T, index: number) => O\r\n): OperatorFunction<T, ObservedValueOf<O>>;\r\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\r\nexport function switchMap<T, O extends ObservableInput<any>>(\r\n  project: (value: T, index: number) => O,\r\n  resultSelector: undefined\r\n): OperatorFunction<T, ObservedValueOf<O>>;\r\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\r\nexport function switchMap<T, R, O extends ObservableInput<any>>(\r\n  project: (value: T, index: number) => O,\r\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\r\n): OperatorFunction<T, R>;\r\n/* tslint:enable:max-line-length */\r\n\r\n/**\r\n * Projects each source value to an Observable which is merged in the output\r\n * Observable, emitting values only from the most recently projected Observable.\r\n *\r\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\r\n * these inner Observables using {@link switchAll}.</span>\r\n *\r\n * ![](switchMap.png)\r\n *\r\n * Returns an Observable that emits items based on applying a function that you\r\n * supply to each item emitted by the source Observable, where that function\r\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\r\n * inner Observables, the output Observable begins emitting the items emitted by\r\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\r\n * stops emitting items from the earlier-emitted inner Observable and begins\r\n * emitting items from the new one. It continues to behave like this for\r\n * subsequent inner Observables.\r\n *\r\n * ## Example\r\n *\r\n * Generate new Observable according to source Observable values\r\n *\r\n * ```ts\r\n * import { of, switchMap } from 'rxjs';\r\n *\r\n * const switched = of(1, 2, 3).pipe(switchMap(x => of(x, x ** 2, x ** 3)));\r\n * switched.subscribe(x => console.log(x));\r\n * // outputs\r\n * // 1\r\n * // 1\r\n * // 1\r\n * // 2\r\n * // 4\r\n * // 8\r\n * // 3\r\n * // 9\r\n * // 27\r\n * ```\r\n *\r\n * Restart an interval Observable on every click event\r\n *\r\n * ```ts\r\n * import { fromEvent, switchMap, interval } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(switchMap(() => interval(1000)));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link concatMap}\r\n * @see {@link exhaustMap}\r\n * @see {@link mergeMap}\r\n * @see {@link switchAll}\r\n * @see {@link switchMapTo}\r\n *\r\n * @param project A function that, when applied to an item emitted by the source\r\n * Observable, returns an Observable.\r\n * @return A function that returns an Observable that emits the result of\r\n * applying the projection function (and the optional deprecated\r\n * `resultSelector`) to each item emitted by the source Observable and taking\r\n * only the values from the most recently projected inner Observable.\r\n */\r\nexport function switchMap<T, R, O extends ObservableInput<any>>(\r\n  project: (value: T, index: number) => O,\r\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\r\n): OperatorFunction<T, ObservedValueOf<O> | R> {\r\n  return operate((source, subscriber) => {\r\n    let innerSubscriber: Subscriber<ObservedValueOf<O>> | null = null;\r\n    let index = 0;\r\n    // Whether or not the source subscription has completed\r\n    let isComplete = false;\r\n\r\n    // We only complete the result if the source is complete AND we don't have an active inner subscription.\r\n    // This is called both when the source completes and when the inners complete.\r\n    const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();\r\n\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value) => {\r\n          // Cancel the previous inner subscription if there was one\r\n          innerSubscriber?.unsubscribe();\r\n          let innerIndex = 0;\r\n          const outerIndex = index++;\r\n          // Start the next inner subscription\r\n          innerFrom(project(value, outerIndex)).subscribe(\r\n            (innerSubscriber = createOperatorSubscriber(\r\n              subscriber,\r\n              // When we get a new inner value, next it through. Note that this is\r\n              // handling the deprecate result selector here. This is because with this architecture\r\n              // it ends up being smaller than using the map operator.\r\n              (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue),\r\n              () => {\r\n                // The inner has completed. Null out the inner subscriber to\r\n                // free up memory and to signal that we have no inner subscription\r\n                // currently.\r\n                innerSubscriber = null!;\r\n                checkComplete();\r\n              }\r\n            ))\r\n          );\r\n        },\r\n        () => {\r\n          isComplete = true;\r\n          checkComplete();\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n", "import { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\r\nimport { switchMap } from './switchMap';\r\nimport { identity } from '../util/identity';\r\n\r\n/**\r\n * Converts a higher-order Observable into a first-order Observable\r\n * producing values only from the most recent observable sequence\r\n *\r\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\r\n *\r\n * ![](switchAll.png)\r\n *\r\n * `switchAll` subscribes to a source that is an observable of observables, also known as a\r\n * \"higher-order observable\" (or `Observable<Observable<T>>`). It subscribes to the most recently\r\n * provided \"inner observable\" emitted by the source, unsubscribing from any previously subscribed\r\n * to inner observable, such that only the most recent inner observable may be subscribed to at\r\n * any point in time. The resulting observable returned by `switchAll` will only complete if the\r\n * source observable completes, *and* any currently subscribed to inner observable also has completed,\r\n * if there are any.\r\n *\r\n * ## Examples\r\n *\r\n * Spawn a new interval observable for each click event, but for every new\r\n * click, cancel the previous interval and subscribe to the new one\r\n *\r\n * ```ts\r\n * import { fromEvent, tap, map, interval, switchAll } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click').pipe(tap(() => console.log('click')));\r\n * const source = clicks.pipe(map(() => interval(1000)));\r\n *\r\n * source\r\n *   .pipe(switchAll())\r\n *   .subscribe(x => console.log(x));\r\n *\r\n * // Output\r\n * // click\r\n * // 0\r\n * // 1\r\n * // 2\r\n * // 3\r\n * // ...\r\n * // click\r\n * // 0\r\n * // 1\r\n * // 2\r\n * // ...\r\n * // click\r\n * // ...\r\n * ```\r\n *\r\n * @see {@link combineLatestAll}\r\n * @see {@link concatAll}\r\n * @see {@link exhaustAll}\r\n * @see {@link switchMap}\r\n * @see {@link switchMapTo}\r\n * @see {@link mergeAll}\r\n *\r\n * @return A function that returns an Observable that converts a higher-order\r\n * Observable into a first-order Observable producing values only from the most\r\n * recent Observable sequence.\r\n */\r\nexport function switchAll<O extends ObservableInput<any>>(): OperatorFunction<O, ObservedValueOf<O>> {\r\n  return switchMap(identity);\r\n}\r\n", "import { switchMap } from './switchMap';\r\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\r\nimport { isFunction } from '../util/isFunction';\r\n\r\n/** @deprecated Will be removed in v9. Use {@link switchMap} instead: `switchMap(() => result)` */\r\nexport function switchMapTo<O extends ObservableInput<unknown>>(observable: O): OperatorFunction<unknown, ObservedValueOf<O>>;\r\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\r\nexport function switchMapTo<O extends ObservableInput<unknown>>(\r\n  observable: O,\r\n  resultSelector: undefined\r\n): OperatorFunction<unknown, ObservedValueOf<O>>;\r\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\r\nexport function switchMapTo<T, R, O extends ObservableInput<unknown>>(\r\n  observable: O,\r\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\r\n): OperatorFunction<T, R>;\r\n\r\n/**\r\n * Projects each source value to the same Observable which is flattened multiple\r\n * times with {@link switchMap} in the output Observable.\r\n *\r\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\r\n * always to the same inner Observable.</span>\r\n *\r\n * ![](switchMapTo.png)\r\n *\r\n * Maps each source value to the given Observable `innerObservable` regardless\r\n * of the source value, and then flattens those resulting Observables into one\r\n * single Observable, which is the output Observable. The output Observables\r\n * emits values only from the most recently emitted instance of\r\n * `innerObservable`.\r\n *\r\n * ## Example\r\n *\r\n * Restart an interval Observable on every click event\r\n *\r\n * ```ts\r\n * import { fromEvent, switchMapTo, interval } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(switchMapTo(interval(1000)));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link concatMapTo}\r\n * @see {@link switchAll}\r\n * @see {@link switchMap}\r\n * @see {@link mergeMapTo}\r\n *\r\n * @param innerObservable An `ObservableInput` to replace each value from the\r\n * source Observable.\r\n * @return A function that returns an Observable that emits items from the\r\n * given `innerObservable` (and optionally transformed through the deprecated\r\n * `resultSelector`) every time a value is emitted on the source Observable,\r\n * and taking only the values from the most recently projected inner\r\n * Observable.\r\n * @deprecated Will be removed in v9. Use {@link switchMap} instead: `switchMap(() => result)`\r\n */\r\nexport function switchMapTo<T, R, O extends ObservableInput<unknown>>(\r\n  innerObservable: O,\r\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\r\n): OperatorFunction<T, ObservedValueOf<O> | R> {\r\n  return isFunction(resultSelector) ? switchMap(() => innerObservable, resultSelector) : switchMap(() => innerObservable);\r\n}\r\n", "import { ObservableInput, ObservedValueOf, OperatorFunction } from '../types';\r\nimport { switchMap } from './switchMap';\r\nimport { operate } from '../util/lift';\r\n\r\n// TODO: Generate a marble diagram for these docs.\r\n\r\n/**\r\n * Applies an accumulator function over the source Observable where the\r\n * accumulator function itself returns an Observable, emitting values\r\n * only from the most recently returned Observable.\r\n *\r\n * <span class=\"informal\">It's like {@link mergeScan}, but only the most recent\r\n * Observable returned by the accumulator is merged into the outer Observable.</span>\r\n *\r\n * @see {@link scan}\r\n * @see {@link mergeScan}\r\n * @see {@link switchMap}\r\n *\r\n * @param accumulator\r\n * The accumulator function called on each source value.\r\n * @param seed The initial accumulation value.\r\n * @return A function that returns an observable of the accumulated values.\r\n */\r\nexport function switchScan<T, R, O extends ObservableInput<any>>(\r\n  accumulator: (acc: R, value: T, index: number) => O,\r\n  seed: R\r\n): OperatorFunction<T, ObservedValueOf<O>> {\r\n  return operate((source, subscriber) => {\r\n    // The state we will keep up to date to pass into our\r\n    // accumulator function at each new value from the source.\r\n    let state = seed;\r\n\r\n    // Use `switchMap` on our `source` to do the work of creating\r\n    // this operator. Note the backwards order here of `switchMap()(source)`\r\n    // to avoid needing to use `pipe` unnecessarily\r\n    switchMap(\r\n      // On each value from the source, call the accumulator with\r\n      // our previous state, the value and the index.\r\n      (value: T, index) => accumulator(state, value, index),\r\n      // Using the deprecated result selector here as a dirty trick\r\n      // to update our state with the flattened value.\r\n      (_, innerValue) => ((state = innerValue), innerValue)\r\n    )(source).subscribe(subscriber);\r\n\r\n    return () => {\r\n      // Release state on finalization\r\n      state = null!;\r\n    };\r\n  });\r\n}\r\n", "import { MonoTypeOperatorFunction, ObservableInput } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { noop } from '../util/noop';\r\n\r\n/**\r\n * Emits the values emitted by the source Observable until a `notifier`\r\n * Observable emits a value.\r\n *\r\n * <span class=\"informal\">Lets values pass until a second Observable,\r\n * `notifier`, emits a value. Then, it completes.</span>\r\n *\r\n * ![](takeUntil.png)\r\n *\r\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\r\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\r\n * emits a value, the output Observable stops mirroring the source Observable\r\n * and completes. If the `notifier` doesn't emit any value and completes\r\n * then `takeUntil` will pass all values.\r\n *\r\n * ## Example\r\n *\r\n * Tick every second until the first click happens\r\n *\r\n * ```ts\r\n * import { interval, fromEvent, takeUntil } from 'rxjs';\r\n *\r\n * const source = interval(1000);\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = source.pipe(takeUntil(clicks));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link take}\r\n * @see {@link takeLast}\r\n * @see {@link takeWhile}\r\n * @see {@link skip}\r\n *\r\n * @param notifier The `ObservableInput` whose first emitted value will cause the output\r\n * Observable of `takeUntil` to stop emitting values from the source Observable.\r\n * @return A function that returns an Observable that emits the values from the\r\n * source Observable until `notifier` emits its first value.\r\n */\r\nexport function takeUntil<T>(notifier: ObservableInput<any>): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, () => subscriber.complete(), noop));\r\n    !subscriber.closed && source.subscribe(subscriber);\r\n  });\r\n}\r\n", "import { OperatorFunction, MonoTypeOperatorFunction, TruthyTypesOf } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\nexport function takeWhile<T>(predicate: BooleanConstructor, inclusive: true): MonoTypeOperatorFunction<T>;\r\nexport function takeWhile<T>(predicate: BooleanConstructor, inclusive: false): OperatorFunction<T, TruthyTypesOf<T>>;\r\nexport function takeWhile<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\r\nexport function takeWhile<T, S extends T>(predicate: (value: T, index: number) => value is S): OperatorFunction<T, S>;\r\nexport function takeWhile<T, S extends T>(predicate: (value: T, index: number) => value is S, inclusive: false): OperatorFunction<T, S>;\r\nexport function takeWhile<T>(predicate: (value: T, index: number) => boolean, inclusive?: boolean): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * Emits values emitted by the source Observable so long as each value satisfies\r\n * the given `predicate`, and then completes as soon as this `predicate` is not\r\n * satisfied.\r\n *\r\n * <span class=\"informal\">Takes values from the source only while they pass the\r\n * condition given. When the first value does not satisfy, it completes.</span>\r\n *\r\n * ![](takeWhile.png)\r\n *\r\n * `takeWhile` subscribes and begins mirroring the source Observable. Each value\r\n * emitted on the source is given to the `predicate` function which returns a\r\n * boolean, representing a condition to be satisfied by the source values. The\r\n * output Observable emits the source values until such time as the `predicate`\r\n * returns false, at which point `takeWhile` stops mirroring the source\r\n * Observable and completes the output Observable.\r\n *\r\n * ## Example\r\n *\r\n * Emit click events only while the clientX property is greater than 200\r\n *\r\n * ```ts\r\n * import { fromEvent, takeWhile } from 'rxjs';\r\n *\r\n * const clicks = fromEvent<PointerEvent>(document, 'click');\r\n * const result = clicks.pipe(takeWhile(ev => ev.clientX > 200));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link take}\r\n * @see {@link takeLast}\r\n * @see {@link takeUntil}\r\n * @see {@link skip}\r\n *\r\n * @param predicate A function that evaluates a value emitted by the source\r\n * Observable and returns a boolean. Also takes the (zero-based) index as the\r\n * second argument.\r\n * @param inclusive When set to `true` the value that caused `predicate` to\r\n * return `false` will also be emitted.\r\n * @return A function that returns an Observable that emits values from the\r\n * source Observable so long as each value satisfies the condition defined by\r\n * the `predicate`, then completes.\r\n */\r\nexport function takeWhile<T>(predicate: (value: T, index: number) => boolean, inclusive = false): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    let index = 0;\r\n    source.subscribe(\r\n      createOperatorSubscriber(subscriber, (value) => {\r\n        const result = predicate(value, index++);\r\n        (result || inclusive) && subscriber.next(value);\r\n        !result && subscriber.complete();\r\n      })\r\n    );\r\n  });\r\n}\r\n", "import { MonoTypeOperatorFunction, Observer } from '../types';\r\nimport { isFunction } from '../util/isFunction';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { identity } from '../util/identity';\r\n\r\n/**\r\n * An extension to the {@link Observer} interface used only by the {@link tap} operator.\r\n *\r\n * It provides a useful set of callbacks a user can register to do side-effects in\r\n * cases other than what the usual {@link Observer} callbacks are\r\n * ({@link guide/glossary-and-semantics#next next},\r\n * {@link guide/glossary-and-semantics#error error} and/or\r\n * {@link guide/glossary-and-semantics#complete complete}).\r\n *\r\n * ## Example\r\n *\r\n * ```ts\r\n * import { fromEvent, switchMap, tap, interval, take } from 'rxjs';\r\n *\r\n * const source$ = fromEvent(document, 'click');\r\n * const result$ = source$.pipe(\r\n *   switchMap((_, i) => i % 2 === 0\r\n *     ? fromEvent(document, 'mousemove').pipe(\r\n *         tap({\r\n *           subscribe: () => console.log('Subscribed to the mouse move events after click #' + i),\r\n *           unsubscribe: () => console.log('Mouse move events #' + i + ' unsubscribed'),\r\n *           finalize: () => console.log('Mouse move events #' + i + ' finalized')\r\n *         })\r\n *       )\r\n *     : interval(1_000).pipe(\r\n *         take(5),\r\n *         tap({\r\n *           subscribe: () => console.log('Subscribed to the 1-second interval events after click #' + i),\r\n *           unsubscribe: () => console.log('1-second interval events #' + i + ' unsubscribed'),\r\n *           finalize: () => console.log('1-second interval events #' + i + ' finalized')\r\n *         })\r\n *       )\r\n *   )\r\n * );\r\n *\r\n * const subscription = result$.subscribe({\r\n *   next: console.log\r\n * });\r\n *\r\n * setTimeout(() => {\r\n *   console.log('Unsubscribe after 60 seconds');\r\n *   subscription.unsubscribe();\r\n * }, 60_000);\r\n * ```\r\n */\r\nexport interface TapObserver<T> extends Observer<T> {\r\n  /**\r\n   * The callback that `tap` operator invokes at the moment when the source Observable\r\n   * gets subscribed to.\r\n   */\r\n  subscribe: () => void;\r\n  /**\r\n   * The callback that `tap` operator invokes when an explicit\r\n   * {@link guide/glossary-and-semantics#unsubscription unsubscribe} happens. It won't get invoked on\r\n   * `error` or `complete` events.\r\n   */\r\n  unsubscribe: () => void;\r\n  /**\r\n   * The callback that `tap` operator invokes when any kind of\r\n   * {@link guide/glossary-and-semantics#finalization finalization} happens - either when\r\n   * the source Observable `error`s or `complete`s or when it gets explicitly unsubscribed\r\n   * by the user. There is no difference in using this callback or the {@link finalize}\r\n   * operator, but if you're already using `tap` operator, you can use this callback\r\n   * instead. You'd get the same result in either case.\r\n   */\r\n  finalize: () => void;\r\n}\r\nexport function tap<T>(observerOrNext?: Partial<TapObserver<T>> | ((value: T) => void)): MonoTypeOperatorFunction<T>;\r\n/** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\r\nexport function tap<T>(\r\n  next?: ((value: T) => void) | null,\r\n  error?: ((error: any) => void) | null,\r\n  complete?: (() => void) | null\r\n): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * Used to perform side-effects for notifications from the source observable\r\n *\r\n * <span class=\"informal\">Used when you want to affect outside state with a notification without altering the notification</span>\r\n *\r\n * ![](tap.png)\r\n *\r\n * Tap is designed to allow the developer a designated place to perform side effects. While you _could_ perform side-effects\r\n * inside of a `map` or a `mergeMap`, that would make their mapping functions impure, which isn't always a big deal, but will\r\n * make it so you can't do things like memoize those functions. The `tap` operator is designed solely for such side-effects to\r\n * help you remove side-effects from other operations.\r\n *\r\n * For any notification, next, error, or complete, `tap` will call the appropriate callback you have provided to it, via a function\r\n * reference, or a partial observer, then pass that notification down the stream.\r\n *\r\n * The observable returned by `tap` is an exact mirror of the source, with one exception: Any error that occurs -- synchronously -- in a handler\r\n * provided to `tap` will be emitted as an error from the returned observable.\r\n *\r\n * > Be careful! You can mutate objects as they pass through the `tap` operator's handlers.\r\n *\r\n * The most common use of `tap` is actually for debugging. You can place a `tap(console.log)` anywhere\r\n * in your observable `pipe`, log out the notifications as they are emitted by the source returned by the previous\r\n * operation.\r\n *\r\n * ## Examples\r\n *\r\n * Check a random number before it is handled. Below is an observable that will use a random number between 0 and 1,\r\n * and emit `'big'` or `'small'` depending on the size of that number. But we wanted to log what the original number\r\n * was, so we have added a `tap(console.log)`.\r\n *\r\n * ```ts\r\n * import { of, tap, map } from 'rxjs';\r\n *\r\n * of(Math.random()).pipe(\r\n *   tap(console.log),\r\n *   map(n => n > 0.5 ? 'big' : 'small')\r\n * ).subscribe(console.log);\r\n * ```\r\n *\r\n * Using `tap` to analyze a value and force an error. Below is an observable where in our system we only\r\n * want to emit numbers 3 or less we get from another source. We can force our observable to error\r\n * using `tap`.\r\n *\r\n * ```ts\r\n * import { of, tap } from 'rxjs';\r\n *\r\n * const source = of(1, 2, 3, 4, 5);\r\n *\r\n * source.pipe(\r\n *   tap(n => {\r\n *     if (n > 3) {\r\n *       throw new TypeError(`Value ${ n } is greater than 3`);\r\n *     }\r\n *   })\r\n * )\r\n * .subscribe({ next: console.log, error: err => console.log(err.message) });\r\n * ```\r\n *\r\n * We want to know when an observable completes before moving on to the next observable. The system\r\n * below will emit a random series of `'X'` characters from 3 different observables in sequence. The\r\n * only way we know when one observable completes and moves to the next one, in this case, is because\r\n * we have added a `tap` with the side effect of logging to console.\r\n *\r\n * ```ts\r\n * import { of, concatMap, interval, take, map, tap } from 'rxjs';\r\n *\r\n * of(1, 2, 3).pipe(\r\n *   concatMap(n => interval(1000).pipe(\r\n *     take(Math.round(Math.random() * 10)),\r\n *     map(() => 'X'),\r\n *     tap({ complete: () => console.log(`Done with ${ n }`) })\r\n *   ))\r\n * )\r\n * .subscribe(console.log);\r\n * ```\r\n *\r\n * @see {@link finalize}\r\n * @see {@link TapObserver}\r\n *\r\n * @param observerOrNext A next handler or partial observer\r\n * @param error An error handler\r\n * @param complete A completion handler\r\n * @return A function that returns an Observable identical to the source, but\r\n * runs the specified Observer or callback(s) for each item.\r\n */\r\nexport function tap<T>(\r\n  observerOrNext?: Partial<TapObserver<T>> | ((value: T) => void) | null,\r\n  error?: ((e: any) => void) | null,\r\n  complete?: (() => void) | null\r\n): MonoTypeOperatorFunction<T> {\r\n  // We have to check to see not only if next is a function,\r\n  // but if error or complete were passed. This is because someone\r\n  // could technically call tap like `tap(null, fn)` or `tap(null, null, fn)`.\r\n  const tapObserver =\r\n    isFunction(observerOrNext) || error || complete\r\n      ? // tslint:disable-next-line: no-object-literal-type-assertion\r\n        ({ next: observerOrNext as Exclude<typeof observerOrNext, Partial<TapObserver<T>>>, error, complete } as Partial<TapObserver<T>>)\r\n      : observerOrNext;\r\n\r\n  return tapObserver\r\n    ? operate((source, subscriber) => {\r\n        tapObserver.subscribe?.();\r\n        let isUnsub = true;\r\n        source.subscribe(\r\n          createOperatorSubscriber(\r\n            subscriber,\r\n            (value) => {\r\n              tapObserver.next?.(value);\r\n              subscriber.next(value);\r\n            },\r\n            () => {\r\n              isUnsub = false;\r\n              tapObserver.complete?.();\r\n              subscriber.complete();\r\n            },\r\n            (err) => {\r\n              isUnsub = false;\r\n              tapObserver.error?.(err);\r\n              subscriber.error(err);\r\n            },\r\n            () => {\r\n              if (isUnsub) {\r\n                tapObserver.unsubscribe?.();\r\n              }\r\n              tapObserver.finalize?.();\r\n            }\r\n          )\r\n        );\r\n      })\r\n    : // Tap was called with no valid tap observer or handler\r\n      // (e.g. `tap(null, null, null)` or `tap(null)` or `tap()`)\r\n      // so we're going to just mirror the source.\r\n      identity;\r\n}\r\n", "import { Subscription } from '../Subscription';\r\n\r\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { innerFrom } from '../observable/innerFrom';\r\n\r\n/**\r\n * An object interface used by {@link throttle} or {@link throttleTime} that ensure\r\n * configuration options of these operators.\r\n *\r\n * @see {@link throttle}\r\n * @see {@link throttleTime}\r\n */\r\nexport interface ThrottleConfig {\r\n  /**\r\n   * If `true`, the resulting Observable will emit the first value from the source\r\n   * Observable at the **start** of the \"throttling\" process (when starting an\r\n   * internal timer that prevents other emissions from the source to pass through).\r\n   * If `false`, it will not emit the first value from the source Observable at the\r\n   * start of the \"throttling\" process.\r\n   *\r\n   * If not provided, defaults to: `true`.\r\n   */\r\n  leading?: boolean;\r\n  /**\r\n   * If `true`, the resulting Observable will emit the last value from the source\r\n   * Observable at the **end** of the \"throttling\" process (when ending an internal\r\n   * timer that prevents other emissions from the source to pass through).\r\n   * If `false`, it will not emit the last value from the source Observable at the\r\n   * end of the \"throttling\" process.\r\n   *\r\n   * If not provided, defaults to: `false`.\r\n   */\r\n  trailing?: boolean;\r\n}\r\n\r\n/**\r\n * Emits a value from the source Observable, then ignores subsequent source\r\n * values for a duration determined by another Observable, then repeats this\r\n * process.\r\n *\r\n * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\r\n * duration is determined by a second Observable.</span>\r\n *\r\n * ![](throttle.svg)\r\n *\r\n * `throttle` emits the source Observable values on the output Observable\r\n * when its internal timer is disabled, and ignores source values when the timer\r\n * is enabled. Initially, the timer is disabled. As soon as the first source\r\n * value arrives, it is forwarded to the output Observable, and then the timer\r\n * is enabled by calling the `durationSelector` function with the source value,\r\n * which returns the \"duration\" Observable. When the duration Observable emits a\r\n * value, the timer is disabled, and this process repeats for the\r\n * next source value.\r\n *\r\n * ## Example\r\n *\r\n * Emit clicks at a rate of at most one click per second\r\n *\r\n * ```ts\r\n * import { fromEvent, throttle, interval } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(throttle(() => interval(1000)));\r\n *\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link audit}\r\n * @see {@link debounce}\r\n * @see {@link delayWhen}\r\n * @see {@link sample}\r\n * @see {@link throttleTime}\r\n *\r\n * @param durationSelector A function that receives a value from the source\r\n * Observable, for computing the silencing duration for each source value,\r\n * returned as an `ObservableInput`.\r\n * @param config A configuration object to define `leading` and `trailing`\r\n * behavior. Defaults to `{ leading: true, trailing: false }`.\r\n * @return A function that returns an Observable that performs the throttle\r\n * operation to limit the rate of emissions from the source.\r\n */\r\nexport function throttle<T>(durationSelector: (value: T) => ObservableInput<any>, config?: ThrottleConfig): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    const { leading = true, trailing = false } = config ?? {};\r\n    let hasValue = false;\r\n    let sendValue: T | null = null;\r\n    let throttled: Subscription | null = null;\r\n    let isComplete = false;\r\n\r\n    const endThrottling = () => {\r\n      throttled?.unsubscribe();\r\n      throttled = null;\r\n      if (trailing) {\r\n        send();\r\n        isComplete && subscriber.complete();\r\n      }\r\n    };\r\n\r\n    const cleanupThrottling = () => {\r\n      throttled = null;\r\n      isComplete && subscriber.complete();\r\n    };\r\n\r\n    const startThrottle = (value: T) =>\r\n      (throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling)));\r\n\r\n    const send = () => {\r\n      if (hasValue) {\r\n        // Ensure we clear out our value and hasValue flag\r\n        // before we emit, otherwise reentrant code can cause\r\n        // issues here.\r\n        hasValue = false;\r\n        const value = sendValue!;\r\n        sendValue = null;\r\n        // Emit the value.\r\n        subscriber.next(value);\r\n        !isComplete && startThrottle(value);\r\n      }\r\n    };\r\n\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        // Regarding the presence of throttled.closed in the following\r\n        // conditions, if a synchronous duration selector is specified - weird,\r\n        // but legal - an already-closed subscription will be assigned to\r\n        // throttled, so the subscription's closed property needs to be checked,\r\n        // too.\r\n        (value) => {\r\n          hasValue = true;\r\n          sendValue = value;\r\n          !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));\r\n        },\r\n        () => {\r\n          isComplete = true;\r\n          !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n", "import { asyncScheduler } from '../scheduler/async';\r\nimport { throttle, ThrottleConfig } from './throttle';\r\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\r\nimport { timer } from '../observable/timer';\r\n\r\n/**\r\n * Emits a value from the source Observable, then ignores subsequent source\r\n * values for `duration` milliseconds, then repeats this process.\r\n *\r\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\r\n * next `duration` milliseconds.</span>\r\n *\r\n * ![](throttleTime.png)\r\n *\r\n * `throttleTime` emits the source Observable values on the output Observable\r\n * when its internal timer is disabled, and ignores source values when the timer\r\n * is enabled. Initially, the timer is disabled. As soon as the first source\r\n * value arrives, it is forwarded to the output Observable, and then the timer\r\n * is enabled. After `duration` milliseconds (or the time unit determined\r\n * internally by the optional `scheduler`) has passed, the timer is disabled,\r\n * and this process repeats for the next source value. Optionally takes a\r\n * {@link SchedulerLike} for managing timers.\r\n *\r\n * ## Examples\r\n *\r\n * ### Limit click rate\r\n *\r\n * Emit clicks at a rate of at most one click per second\r\n *\r\n * ```ts\r\n * import { fromEvent, throttleTime } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(throttleTime(1000));\r\n *\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link auditTime}\r\n * @see {@link debounceTime}\r\n * @see {@link delay}\r\n * @see {@link sampleTime}\r\n * @see {@link throttle}\r\n *\r\n * @param duration Time to wait before emitting another value after\r\n * emitting the last value, measured in milliseconds or the time unit determined\r\n * internally by the optional `scheduler`.\r\n * @param scheduler The {@link SchedulerLike} to use for\r\n * managing the timers that handle the throttling. Defaults to {@link asyncScheduler}.\r\n * @param config A configuration object to define `leading` and\r\n * `trailing` behavior. Defaults to `{ leading: true, trailing: false }`.\r\n * @return A function that returns an Observable that performs the throttle\r\n * operation to limit the rate of emissions from the source.\r\n */\r\nexport function throttleTime<T>(\r\n  duration: number,\r\n  scheduler: SchedulerLike = asyncScheduler,\r\n  config?: ThrottleConfig\r\n): MonoTypeOperatorFunction<T> {\r\n  const duration$ = timer(duration, scheduler);\r\n  return throttle(() => duration$, config);\r\n}\r\n", "import { asyncScheduler } from '../scheduler/async';\r\nimport { SchedulerLike, OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Emits an object containing the current value, and the time that has\r\n * passed between emitting the current value and the previous value, which is\r\n * calculated by using the provided `scheduler`'s `now()` method to retrieve\r\n * the current time at each emission, then calculating the difference. The `scheduler`\r\n * defaults to {@link asyncScheduler}, so by default, the `interval` will be in\r\n * milliseconds.\r\n *\r\n * <span class=\"informal\">Convert an Observable that emits items into one that\r\n * emits indications of the amount of time elapsed between those emissions.</span>\r\n *\r\n * ![](timeInterval.png)\r\n *\r\n * ## Example\r\n *\r\n * Emit interval between current value with the last value\r\n *\r\n * ```ts\r\n * import { interval, timeInterval } from 'rxjs';\r\n *\r\n * const seconds = interval(1000);\r\n *\r\n * seconds\r\n *   .pipe(timeInterval())\r\n *   .subscribe(value => console.log(value));\r\n *\r\n * // NOTE: The values will never be this precise,\r\n * // intervals created with `interval` or `setInterval`\r\n * // are non-deterministic.\r\n *\r\n * // { value: 0, interval: 1000 }\r\n * // { value: 1, interval: 1000 }\r\n * // { value: 2, interval: 1000 }\r\n * ```\r\n *\r\n * @param scheduler Scheduler used to get the current time.\r\n * @return A function that returns an Observable that emits information about\r\n * value and interval.\r\n */\r\nexport function timeInterval<T>(scheduler: SchedulerLike = asyncScheduler): OperatorFunction<T, TimeInterval<T>> {\r\n  return operate((source, subscriber) => {\r\n    let last = scheduler.now();\r\n    source.subscribe(\r\n      createOperatorSubscriber(subscriber, (value) => {\r\n        const now = scheduler.now();\r\n        const interval = now - last;\r\n        last = now;\r\n        subscriber.next(new TimeInterval(value, interval));\r\n      })\r\n    );\r\n  });\r\n}\r\n\r\n// TODO(benlesh): make this an interface, export the interface, but not the implemented class,\r\n// there's no reason users should be manually creating this type.\r\n\r\nexport class TimeInterval<T> {\r\n  /**\r\n   * @deprecated Internal implementation detail, do not construct directly. Will be made an interface in v8.\r\n   */\r\n  constructor(public value: T, public interval: number) {}\r\n}\r\n", "import { async } from '../scheduler/async';\r\nimport { isValidDate } from '../util/isDate';\r\nimport { ObservableInput, OperatorFunction, SchedulerLike } from '../types';\r\nimport { timeout } from './timeout';\r\n\r\n/** @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(someDate, a$, scheduler)`, use the configuration object\r\n * `timeout({ first: someDate, with: () => a$, scheduler })`. Will be removed in v8. */\r\nexport function timeoutWith<T, R>(dueBy: Date, switchTo: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>;\r\n/** @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(100, a$, scheduler)`, use the configuration object\r\n *  `timeout({ each: 100, with: () => a$, scheduler })`. Will be removed in v8. */\r\nexport function timeoutWith<T, R>(waitFor: number, switchTo: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>;\r\n\r\n/**\r\n * When the passed timespan elapses before the source emits any given value, it will unsubscribe from the source,\r\n * and switch the subscription to another observable.\r\n *\r\n * <span class=\"informal\">Used to switch to a different observable if your source is being slow.</span>\r\n *\r\n * Useful in cases where:\r\n *\r\n * - You want to switch to a different source that may be faster.\r\n * - You want to notify a user that the data stream is slow.\r\n * - You want to emit a custom error rather than the {@link TimeoutError} emitted\r\n *   by the default usage of {@link timeout}.\r\n *\r\n * If the first parameter is passed as Date and the time of the Date arrives before the first value arrives from the source,\r\n * it will unsubscribe from the source and switch the subscription to another observable.\r\n *\r\n * <span class=\"informal\">Use Date object to switch to a different observable if the first value doesn't arrive by a specific time.</span>\r\n *\r\n * Can be used to set a timeout only for the first value, however it's recommended to use the {@link timeout} operator with\r\n * the `first` configuration to get the same effect.\r\n *\r\n * ## Examples\r\n *\r\n * Fallback to a faster observable\r\n *\r\n * ```ts\r\n * import { interval, timeoutWith } from 'rxjs';\r\n *\r\n * const slow$ = interval(1000);\r\n * const faster$ = interval(500);\r\n *\r\n * slow$\r\n *   .pipe(timeoutWith(900, faster$))\r\n *   .subscribe(console.log);\r\n * ```\r\n *\r\n * Emit your own custom timeout error\r\n *\r\n * ```ts\r\n * import { interval, timeoutWith, throwError } from 'rxjs';\r\n *\r\n * class CustomTimeoutError extends Error {\r\n *   constructor() {\r\n *     super('It was too slow');\r\n *     this.name = 'CustomTimeoutError';\r\n *   }\r\n * }\r\n *\r\n * const slow$ = interval(1000);\r\n *\r\n * slow$\r\n *   .pipe(timeoutWith(900, throwError(() => new CustomTimeoutError())))\r\n *   .subscribe({\r\n *     error: err => console.error(err.message)\r\n *   });\r\n * ```\r\n *\r\n * @see {@link timeout}\r\n *\r\n * @param due When passed a number, used as the time (in milliseconds) allowed between each value from the source before timeout\r\n * is triggered. When passed a Date, used as the exact time at which the timeout will be triggered if the first value does not arrive.\r\n * @param withObservable The observable to switch to when timeout occurs.\r\n * @param scheduler The scheduler to use with time-related operations within this operator. Defaults to {@link asyncScheduler}\r\n * @return A function that returns an Observable that mirrors behaviour of the\r\n * source Observable, unless timeout happens when it starts emitting values\r\n * from the `ObservableInput` passed as a second parameter.\r\n * @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(100, a$, scheduler)`, use {@link timeout} with the configuration\r\n * object: `timeout({ each: 100, with: () => a$, scheduler })`. Instead of `timeoutWith(someDate, a$, scheduler)`, use {@link timeout}\r\n * with the configuration object: `timeout({ first: someDate, with: () => a$, scheduler })`. Will be removed in v8.\r\n */\r\nexport function timeoutWith<T, R>(\r\n  due: number | Date,\r\n  withObservable: ObservableInput<R>,\r\n  scheduler?: SchedulerLike\r\n): OperatorFunction<T, T | R> {\r\n  let first: number | Date | undefined;\r\n  let each: number | undefined;\r\n  let _with: () => ObservableInput<R>;\r\n  scheduler = scheduler ?? async;\r\n\r\n  if (isValidDate(due)) {\r\n    first = due;\r\n  } else if (typeof due === 'number') {\r\n    each = due;\r\n  }\r\n\r\n  if (withObservable) {\r\n    _with = () => withObservable;\r\n  } else {\r\n    throw new TypeError('No observable provided to switch to');\r\n  }\r\n\r\n  if (first == null && each == null) {\r\n    // Ensure timeout was provided at runtime.\r\n    throw new TypeError('No timeout provided.');\r\n  }\r\n\r\n  return timeout<T, ObservableInput<R>>({\r\n    first,\r\n    each,\r\n    scheduler,\r\n    with: _with,\r\n  });\r\n}\r\n", "import { OperatorFunction, TimestampProvider, Timestamp } from '../types';\r\nimport { dateTimestampProvider } from '../scheduler/dateTimestampProvider';\r\nimport { map } from './map';\r\n\r\n/**\r\n * Attaches a timestamp to each item emitted by an observable indicating when it was emitted\r\n *\r\n * The `timestamp` operator maps the *source* observable stream to an object of type\r\n * `{value: T, timestamp: R}`. The properties are generically typed. The `value` property contains the value\r\n * and type of the *source* observable. The `timestamp` is generated by the schedulers `now` function. By\r\n * default, it uses the `asyncScheduler` which simply returns `Date.now()` (milliseconds since 1970/01/01\r\n * 00:00:00:000) and therefore is of type `number`.\r\n *\r\n * ![](timestamp.png)\r\n *\r\n * ## Example\r\n *\r\n * In this example there is a timestamp attached to the document's click events\r\n *\r\n * ```ts\r\n * import { fromEvent, timestamp } from 'rxjs';\r\n *\r\n * const clickWithTimestamp = fromEvent(document, 'click').pipe(\r\n *   timestamp()\r\n * );\r\n *\r\n * // Emits data of type { value: PointerEvent, timestamp: number }\r\n * clickWithTimestamp.subscribe(data => {\r\n *   console.log(data);\r\n * });\r\n * ```\r\n *\r\n * @param timestampProvider An object with a `now()` method used to get the current timestamp.\r\n * @return A function that returns an Observable that attaches a timestamp to\r\n * each item emitted by the source Observable indicating when it was emitted.\r\n */\r\nexport function timestamp<T>(timestampProvider: TimestampProvider = dateTimestampProvider): OperatorFunction<T, Timestamp<T>> {\r\n  return map((value: T) => ({ value, timestamp: timestampProvider.now() }));\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { OperatorFunction, ObservableInput } from '../types';\r\nimport { Subject } from '../Subject';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { noop } from '../util/noop';\r\nimport { innerFrom } from '../observable/innerFrom';\r\n\r\n/**\r\n * Branch out the source Observable values as a nested Observable whenever\r\n * `windowBoundaries` emits.\r\n *\r\n * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\r\n * instead of an array.</span>\r\n *\r\n * ![](window.png)\r\n *\r\n * Returns an Observable that emits windows of items it collects from the source\r\n * Observable. The output Observable emits connected, non-overlapping\r\n * windows. It emits the current window and opens a new one whenever the\r\n * `windowBoundaries` emits an item. `windowBoundaries` can be any type that\r\n * `ObservableInput` accepts. It internally gets converted to an Observable.\r\n * Because each window is an Observable, the output is a higher-order Observable.\r\n *\r\n * ## Example\r\n *\r\n * In every window of 1 second each, emit at most 2 click events\r\n *\r\n * ```ts\r\n * import { fromEvent, interval, window, map, take, mergeAll } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const sec = interval(1000);\r\n * const result = clicks.pipe(\r\n *   window(sec),\r\n *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window\r\n *   mergeAll()                     // flatten the Observable-of-Observables\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link windowCount}\r\n * @see {@link windowTime}\r\n * @see {@link windowToggle}\r\n * @see {@link windowWhen}\r\n * @see {@link buffer}\r\n *\r\n * @param windowBoundaries An `ObservableInput` that completes the\r\n * previous window and starts a new window.\r\n * @return A function that returns an Observable of windows, which are\r\n * Observables emitting values of the source Observable.\r\n */\r\nexport function window<T>(windowBoundaries: ObservableInput<any>): OperatorFunction<T, Observable<T>> {\r\n  return operate((source, subscriber) => {\r\n    let windowSubject: Subject<T> = new Subject<T>();\r\n\r\n    subscriber.next(windowSubject.asObservable());\r\n\r\n    const errorHandler = (err: any) => {\r\n      windowSubject.error(err);\r\n      subscriber.error(err);\r\n    };\r\n\r\n    // Subscribe to our source\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value) => windowSubject?.next(value),\r\n        () => {\r\n          windowSubject.complete();\r\n          subscriber.complete();\r\n        },\r\n        errorHandler\r\n      )\r\n    );\r\n\r\n    // Subscribe to the window boundaries.\r\n    innerFrom(windowBoundaries).subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        () => {\r\n          windowSubject.complete();\r\n          subscriber.next((windowSubject = new Subject()));\r\n        },\r\n        noop,\r\n        errorHandler\r\n      )\r\n    );\r\n\r\n    return () => {\r\n      // Unsubscribing the subject ensures that anyone who has captured\r\n      // a reference to this window that tries to use it after it can\r\n      // no longer get values from the source will get an ObjectUnsubscribedError.\r\n      windowSubject?.unsubscribe();\r\n      windowSubject = null!;\r\n    };\r\n  });\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { Subject } from '../Subject';\r\nimport { OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Branch out the source Observable values as a nested Observable with each\r\n * nested Observable emitting at most `windowSize` values.\r\n *\r\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\r\n * Observable instead of an array.</span>\r\n *\r\n * ![](windowCount.png)\r\n *\r\n * Returns an Observable that emits windows of items it collects from the source\r\n * Observable. The output Observable emits windows every `startWindowEvery`\r\n * items, each containing no more than `windowSize` items. When the source\r\n * Observable completes or encounters an error, the output Observable emits\r\n * the current window and propagates the notification from the source\r\n * Observable. If `startWindowEvery` is not provided, then new windows are\r\n * started immediately at the start of the source and when each window completes\r\n * with size `windowSize`.\r\n *\r\n * ## Examples\r\n *\r\n * Ignore every 3rd click event, starting from the first one\r\n *\r\n * ```ts\r\n * import { fromEvent, windowCount, map, skip, mergeAll } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(\r\n *   windowCount(3),\r\n *   map(win => win.pipe(skip(1))), // skip first of every 3 clicks\r\n *   mergeAll()                     // flatten the Observable-of-Observables\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * Ignore every 3rd click event, starting from the third one\r\n *\r\n * ```ts\r\n * import { fromEvent, windowCount, mergeAll } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(\r\n *   windowCount(2, 3),\r\n *   mergeAll() // flatten the Observable-of-Observables\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link window}\r\n * @see {@link windowTime}\r\n * @see {@link windowToggle}\r\n * @see {@link windowWhen}\r\n * @see {@link bufferCount}\r\n *\r\n * @param windowSize The maximum number of values emitted by each window.\r\n * @param startWindowEvery Interval at which to start a new window. For example\r\n * if `startWindowEvery` is `2`, then a new window will be started on every\r\n * other value from the source. A new window is started at the beginning of the\r\n * source by default.\r\n * @return A function that returns an Observable of windows, which in turn are\r\n * Observable of values.\r\n */\r\nexport function windowCount<T>(windowSize: number, startWindowEvery: number = 0): OperatorFunction<T, Observable<T>> {\r\n  const startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;\r\n\r\n  return operate((source, subscriber) => {\r\n    let windows = [new Subject<T>()];\r\n    let starts: number[] = [];\r\n    let count = 0;\r\n\r\n    // Open the first window.\r\n    subscriber.next(windows[0].asObservable());\r\n\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value: T) => {\r\n          // Emit the value through all current windows.\r\n          // We don't need to create a new window yet, we\r\n          // do that as soon as we close one.\r\n          for (const window of windows) {\r\n            window.next(value);\r\n          }\r\n          // Here we're using the size of the window array to figure\r\n          // out if the oldest window has emitted enough values. We can do this\r\n          // because the size of the window array is a function of the values\r\n          // seen by the subscription. If it's time to close it, we complete\r\n          // it and remove it.\r\n          const c = count - windowSize + 1;\r\n          if (c >= 0 && c % startEvery === 0) {\r\n            windows.shift()!.complete();\r\n          }\r\n\r\n          // Look to see if the next count tells us it's time to open a new window.\r\n          // TODO: We need to figure out if this really makes sense. We're technically\r\n          // emitting windows *before* we have a value to emit them for. It's probably\r\n          // more expected that we should be emitting the window when the start\r\n          // count is reached -- not before.\r\n          if (++count % startEvery === 0) {\r\n            const window = new Subject<T>();\r\n            windows.push(window);\r\n            subscriber.next(window.asObservable());\r\n          }\r\n        },\r\n        () => {\r\n          while (windows.length > 0) {\r\n            windows.shift()!.complete();\r\n          }\r\n          subscriber.complete();\r\n        },\r\n        (err) => {\r\n          while (windows.length > 0) {\r\n            windows.shift()!.error(err);\r\n          }\r\n          subscriber.error(err);\r\n        },\r\n        () => {\r\n          starts = null!;\r\n          windows = null!;\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n", "import { Subject } from '../Subject';\r\nimport { asyncScheduler } from '../scheduler/async';\r\nimport { Observable } from '../Observable';\r\nimport { Subscription } from '../Subscription';\r\nimport { Observer, OperatorFunction, SchedulerLike } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { arrRemove } from '../util/arrRemove';\r\nimport { popScheduler } from '../util/args';\r\nimport { executeSchedule } from '../util/executeSchedule';\r\n\r\nexport function windowTime<T>(windowTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\r\nexport function windowTime<T>(\r\n  windowTimeSpan: number,\r\n  windowCreationInterval: number,\r\n  scheduler?: SchedulerLike\r\n): OperatorFunction<T, Observable<T>>;\r\nexport function windowTime<T>(\r\n  windowTimeSpan: number,\r\n  windowCreationInterval: number | null | void,\r\n  maxWindowSize: number,\r\n  scheduler?: SchedulerLike\r\n): OperatorFunction<T, Observable<T>>;\r\n\r\n/**\r\n * Branch out the source Observable values as a nested Observable periodically\r\n * in time.\r\n *\r\n * <span class=\"informal\">It's like {@link bufferTime}, but emits a nested\r\n * Observable instead of an array.</span>\r\n *\r\n * ![](windowTime.png)\r\n *\r\n * Returns an Observable that emits windows of items it collects from the source\r\n * Observable. The output Observable starts a new window periodically, as\r\n * determined by the `windowCreationInterval` argument. It emits each window\r\n * after a fixed timespan, specified by the `windowTimeSpan` argument. When the\r\n * source Observable completes or encounters an error, the output Observable\r\n * emits the current window and propagates the notification from the source\r\n * Observable. If `windowCreationInterval` is not provided, the output\r\n * Observable starts a new window when the previous window of duration\r\n * `windowTimeSpan` completes. If `maxWindowCount` is provided, each window\r\n * will emit at most fixed number of values. Window will complete immediately\r\n * after emitting last value and next one still will open as specified by\r\n * `windowTimeSpan` and `windowCreationInterval` arguments.\r\n *\r\n * ## Examples\r\n *\r\n * In every window of 1 second each, emit at most 2 click events\r\n *\r\n * ```ts\r\n * import { fromEvent, windowTime, map, take, mergeAll } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(\r\n *   windowTime(1000),\r\n *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window\r\n *   mergeAll()                     // flatten the Observable-of-Observables\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * Every 5 seconds start a window 1 second long, and emit at most 2 click events per window\r\n *\r\n * ```ts\r\n * import { fromEvent, windowTime, map, take, mergeAll } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(\r\n *   windowTime(1000, 5000),\r\n *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window\r\n *   mergeAll()                     // flatten the Observable-of-Observables\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * Same as example above but with `maxWindowCount` instead of `take`\r\n *\r\n * ```ts\r\n * import { fromEvent, windowTime, mergeAll } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(\r\n *   windowTime(1000, 5000, 2), // take at most 2 emissions from each window\r\n *   mergeAll()                 // flatten the Observable-of-Observables\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link window}\r\n * @see {@link windowCount}\r\n * @see {@link windowToggle}\r\n * @see {@link windowWhen}\r\n * @see {@link bufferTime}\r\n *\r\n * @param windowTimeSpan The amount of time, in milliseconds, to fill each window.\r\n * @param windowCreationInterval The interval at which to start new\r\n * windows.\r\n * @param maxWindowSize Max number of\r\n * values each window can emit before completion.\r\n * @param scheduler The scheduler on which to schedule the\r\n * intervals that determine window boundaries.\r\n * @return A function that returns an Observable of windows, which in turn are\r\n * Observables.\r\n */\r\nexport function windowTime<T>(windowTimeSpan: number, ...otherArgs: any[]): OperatorFunction<T, Observable<T>> {\r\n  const scheduler = popScheduler(otherArgs) ?? asyncScheduler;\r\n  const windowCreationInterval = (otherArgs[0] as number) ?? null;\r\n  const maxWindowSize = (otherArgs[1] as number) || Infinity;\r\n\r\n  return operate((source, subscriber) => {\r\n    // The active windows, their related subscriptions, and removal functions.\r\n    let windowRecords: WindowRecord<T>[] | null = [];\r\n    // If true, it means that every time we close a window, we want to start a new window.\r\n    // This is only really used for when *just* the time span is passed.\r\n    let restartOnClose = false;\r\n\r\n    const closeWindow = (record: { window: Subject<T>; subs: Subscription }) => {\r\n      const { window, subs } = record;\r\n      window.complete();\r\n      subs.unsubscribe();\r\n      arrRemove(windowRecords, record);\r\n      restartOnClose && startWindow();\r\n    };\r\n\r\n    /**\r\n     * Called every time we start a new window. This also does\r\n     * the work of scheduling the job to close the window.\r\n     */\r\n    const startWindow = () => {\r\n      if (windowRecords) {\r\n        const subs = new Subscription();\r\n        subscriber.add(subs);\r\n        const window = new Subject<T>();\r\n        const record = {\r\n          window,\r\n          subs,\r\n          seen: 0,\r\n        };\r\n        windowRecords.push(record);\r\n        subscriber.next(window.asObservable());\r\n        executeSchedule(subs, scheduler, () => closeWindow(record), windowTimeSpan);\r\n      }\r\n    };\r\n\r\n    if (windowCreationInterval !== null && windowCreationInterval >= 0) {\r\n      // The user passed both a windowTimeSpan (required), and a creation interval\r\n      // That means we need to start new window on the interval, and those windows need\r\n      // to wait the required time span before completing.\r\n      executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);\r\n    } else {\r\n      restartOnClose = true;\r\n    }\r\n\r\n    startWindow();\r\n\r\n    /**\r\n     * We need to loop over a copy of the window records several times in this operator.\r\n     * This is to save bytes over the wire more than anything.\r\n     * The reason we copy the array is that reentrant code could mutate the array while\r\n     * we are iterating over it.\r\n     */\r\n    const loop = (cb: (record: WindowRecord<T>) => void) => windowRecords!.slice().forEach(cb);\r\n\r\n    /**\r\n     * Used to notify all of the windows and the subscriber in the same way\r\n     * in the error and complete handlers.\r\n     */\r\n    const terminate = (cb: (consumer: Observer<any>) => void) => {\r\n      loop(({ window }) => cb(window));\r\n      cb(subscriber);\r\n      subscriber.unsubscribe();\r\n    };\r\n\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value: T) => {\r\n          // Notify all windows of the value.\r\n          loop((record) => {\r\n            record.window.next(value);\r\n            // If the window is over the max size, we need to close it.\r\n            maxWindowSize <= ++record.seen && closeWindow(record);\r\n          });\r\n        },\r\n        // Complete the windows and the downstream subscriber and clean up.\r\n        () => terminate((consumer) => consumer.complete()),\r\n        // Notify the windows and the downstream subscriber of the error and clean up.\r\n        (err) => terminate((consumer) => consumer.error(err))\r\n      )\r\n    );\r\n\r\n    // Additional finalization. This will be called when the\r\n    // destination tears down. Other finalizations are registered implicitly\r\n    // above via subscription.\r\n    return () => {\r\n      // Ensure that the buffer is released.\r\n      windowRecords = null!;\r\n    };\r\n  });\r\n}\r\n\r\ninterface WindowRecord<T> {\r\n  seen: number;\r\n  window: Subject<T>;\r\n  subs: Subscription;\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { Subject } from '../Subject';\r\nimport { Subscription } from '../Subscription';\r\nimport { ObservableInput, OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { noop } from '../util/noop';\r\nimport { arrRemove } from '../util/arrRemove';\r\n\r\n/**\r\n * Branch out the source Observable values as a nested Observable starting from\r\n * an emission from `openings` and ending when the output of `closingSelector`\r\n * emits.\r\n *\r\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\r\n * Observable instead of an array.</span>\r\n *\r\n * ![](windowToggle.png)\r\n *\r\n * Returns an Observable that emits windows of items it collects from the source\r\n * Observable. The output Observable emits windows that contain those items\r\n * emitted by the source Observable between the time when the `openings`\r\n * Observable emits an item and when the Observable returned by\r\n * `closingSelector` emits an item.\r\n *\r\n * ## Example\r\n *\r\n * Every other second, emit the click events from the next 500ms\r\n *\r\n * ```ts\r\n * import { fromEvent, interval, windowToggle, EMPTY, mergeAll } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const openings = interval(1000);\r\n * const result = clicks.pipe(\r\n *   windowToggle(openings, i => i % 2 ? interval(500) : EMPTY),\r\n *   mergeAll()\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link window}\r\n * @see {@link windowCount}\r\n * @see {@link windowTime}\r\n * @see {@link windowWhen}\r\n * @see {@link bufferToggle}\r\n *\r\n * @param openings An observable of notifications to start new windows.\r\n * @param closingSelector A function that takes the value emitted by the\r\n * `openings` observable and returns an Observable, which, when it emits a next\r\n * notification, signals that the associated window should complete.\r\n * @return A function that returns an Observable of windows, which in turn are\r\n * Observables.\r\n */\r\nexport function windowToggle<T, O>(\r\n  openings: ObservableInput<O>,\r\n  closingSelector: (openValue: O) => ObservableInput<any>\r\n): OperatorFunction<T, Observable<T>> {\r\n  return operate((source, subscriber) => {\r\n    const windows: Subject<T>[] = [];\r\n\r\n    const handleError = (err: any) => {\r\n      while (0 < windows.length) {\r\n        windows.shift()!.error(err);\r\n      }\r\n      subscriber.error(err);\r\n    };\r\n\r\n    innerFrom(openings).subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (openValue) => {\r\n          const window = new Subject<T>();\r\n          windows.push(window);\r\n          const closingSubscription = new Subscription();\r\n          const closeWindow = () => {\r\n            arrRemove(windows, window);\r\n            window.complete();\r\n            closingSubscription.unsubscribe();\r\n          };\r\n\r\n          let closingNotifier: Observable<any>;\r\n          try {\r\n            closingNotifier = innerFrom(closingSelector(openValue));\r\n          } catch (err) {\r\n            handleError(err);\r\n            return;\r\n          }\r\n\r\n          subscriber.next(window.asObservable());\r\n\r\n          closingSubscription.add(closingNotifier.subscribe(createOperatorSubscriber(subscriber, closeWindow, noop, handleError)));\r\n        },\r\n        noop\r\n      )\r\n    );\r\n\r\n    // Subscribe to the source to get things started.\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value: T) => {\r\n          // Copy the windows array before we emit to\r\n          // make sure we don't have issues with reentrant code.\r\n          const windowsCopy = windows.slice();\r\n          for (const window of windowsCopy) {\r\n            window.next(value);\r\n          }\r\n        },\r\n        () => {\r\n          // Complete all of our windows before we complete.\r\n          while (0 < windows.length) {\r\n            windows.shift()!.complete();\r\n          }\r\n          subscriber.complete();\r\n        },\r\n        handleError,\r\n        () => {\r\n          // Add this finalization so that all window subjects are\r\n          // disposed of. This way, if a user tries to subscribe\r\n          // to a window *after* the outer subscription has been unsubscribed,\r\n          // they will get an error, instead of waiting forever to\r\n          // see if a value arrives.\r\n          while (0 < windows.length) {\r\n            windows.shift()!.unsubscribe();\r\n          }\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n", "import { Subscriber } from '../Subscriber';\r\nimport { Observable } from '../Observable';\r\nimport { Subject } from '../Subject';\r\nimport { ObservableInput, OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { innerFrom } from '../observable/innerFrom';\r\n\r\n/**\r\n * Branch out the source Observable values as a nested Observable using a\r\n * factory function of closing Observables to determine when to start a new\r\n * window.\r\n *\r\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\r\n * Observable instead of an array.</span>\r\n *\r\n * ![](windowWhen.png)\r\n *\r\n * Returns an Observable that emits windows of items it collects from the source\r\n * Observable. The output Observable emits connected, non-overlapping windows.\r\n * It emits the current window and opens a new one whenever the Observable\r\n * produced by the specified `closingSelector` function emits an item. The first\r\n * window is opened immediately when subscribing to the output Observable.\r\n *\r\n * ## Example\r\n *\r\n * Emit only the first two clicks events in every window of [1-5] random seconds\r\n *\r\n * ```ts\r\n * import { fromEvent, windowWhen, interval, map, take, mergeAll } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(\r\n *   windowWhen(() => interval(1000 + Math.random() * 4000)),\r\n *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window\r\n *   mergeAll()                     // flatten the Observable-of-Observables\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link window}\r\n * @see {@link windowCount}\r\n * @see {@link windowTime}\r\n * @see {@link windowToggle}\r\n * @see {@link bufferWhen}\r\n *\r\n * @param closingSelector A function that takes no arguments and returns an\r\n * {@link ObservableInput} (that gets converted to Observable) that signals\r\n * (on either `next` or `complete`) when to close the previous window and\r\n * start a new one.\r\n * @return A function that returns an Observable of windows, which in turn are\r\n * Observables.\r\n */\r\nexport function windowWhen<T>(closingSelector: () => ObservableInput<any>): OperatorFunction<T, Observable<T>> {\r\n  return operate((source, subscriber) => {\r\n    let window: Subject<T> | null;\r\n    let closingSubscriber: Subscriber<any> | undefined;\r\n\r\n    /**\r\n     * When we get an error, we have to notify both the\r\n     * destination subscriber and the window.\r\n     */\r\n    const handleError = (err: any) => {\r\n      window!.error(err);\r\n      subscriber.error(err);\r\n    };\r\n\r\n    /**\r\n     * Called every time we need to open a window.\r\n     * Recursive, as it will start the closing notifier, which\r\n     * inevitably *should* call openWindow -- but may not if\r\n     * it is a \"never\" observable.\r\n     */\r\n    const openWindow = () => {\r\n      // We need to clean up our closing subscription,\r\n      // we only cared about the first next or complete notification.\r\n      closingSubscriber?.unsubscribe();\r\n\r\n      // Close our window before starting a new one.\r\n      window?.complete();\r\n\r\n      // Start the new window.\r\n      window = new Subject<T>();\r\n      subscriber.next(window.asObservable());\r\n\r\n      // Get our closing notifier.\r\n      let closingNotifier: Observable<any>;\r\n      try {\r\n        closingNotifier = innerFrom(closingSelector());\r\n      } catch (err) {\r\n        handleError(err);\r\n        return;\r\n      }\r\n\r\n      // Subscribe to the closing notifier, be sure\r\n      // to capture the subscriber (aka Subscription)\r\n      // so we can clean it up when we close the window\r\n      // and open a new one.\r\n      closingNotifier.subscribe((closingSubscriber = createOperatorSubscriber(subscriber, openWindow, openWindow, handleError)));\r\n    };\r\n\r\n    // Start the first window.\r\n    openWindow();\r\n\r\n    // Subscribe to the source\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value) => window!.next(value),\r\n        () => {\r\n          // The source completed, close the window and complete.\r\n          window!.complete();\r\n          subscriber.complete();\r\n        },\r\n        handleError,\r\n        () => {\r\n          // Be sure to clean up our closing subscription\r\n          // when this tears down.\r\n          closingSubscriber?.unsubscribe();\r\n          window = null!;\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n", "import { OperatorFunction, ObservableInputTuple } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { identity } from '../util/identity';\r\nimport { noop } from '../util/noop';\r\nimport { popResultSelector } from '../util/args';\r\n\r\nexport function withLatestFrom<T, O extends unknown[]>(...inputs: [...ObservableInputTuple<O>]): OperatorFunction<T, [T, ...O]>;\r\n\r\nexport function withLatestFrom<T, O extends unknown[], R>(\r\n  ...inputs: [...ObservableInputTuple<O>, (...value: [T, ...O]) => R]\r\n): OperatorFunction<T, R>;\r\n\r\n/**\r\n * Combines the source Observable with other Observables to create an Observable\r\n * whose values are calculated from the latest values of each, only when the\r\n * source emits.\r\n *\r\n * <span class=\"informal\">Whenever the source Observable emits a value, it\r\n * computes a formula using that value plus the latest values from other input\r\n * Observables, then emits the output of that formula.</span>\r\n *\r\n * ![](withLatestFrom.png)\r\n *\r\n * `withLatestFrom` combines each value from the source Observable (the\r\n * instance) with the latest values from the other input Observables only when\r\n * the source emits a value, optionally using a `project` function to determine\r\n * the value to be emitted on the output Observable. All input Observables must\r\n * emit at least one value before the output Observable will emit a value.\r\n *\r\n * ## Example\r\n *\r\n * On every click event, emit an array with the latest timer event plus the click event\r\n *\r\n * ```ts\r\n * import { fromEvent, interval, withLatestFrom } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const timer = interval(1000);\r\n * const result = clicks.pipe(withLatestFrom(timer));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link combineLatest}\r\n *\r\n * @param inputs An input Observable to combine with the source Observable. More\r\n * than one input Observables may be given as argument. If the last parameter is\r\n * a function, it will be used as a projection function for combining values\r\n * together. When the function is called, it receives all values in order of the\r\n * Observables passed, where the first parameter is a value from the source\r\n * Observable. (e.g.\r\n * `a.pipe(withLatestFrom(b, c), map(([a1, b1, c1]) => a1 + b1 + c1))`). If this\r\n * is not passed, arrays will be emitted on the output Observable.\r\n * @return A function that returns an Observable of projected values from the\r\n * most recent values from each input Observable, or an array of the most\r\n * recent values from each input Observable.\r\n */\r\nexport function withLatestFrom<T, R>(...inputs: any[]): OperatorFunction<T, R | any[]> {\r\n  const project = popResultSelector(inputs) as ((...args: any[]) => R) | undefined;\r\n\r\n  return operate((source, subscriber) => {\r\n    const len = inputs.length;\r\n    const otherValues = new Array(len);\r\n    // An array of whether or not the other sources have emitted. Matched with them by index.\r\n    // TODO: At somepoint, we should investigate the performance implications here, and look\r\n    // into using a `Set()` and checking the `size` to see if we're ready.\r\n    let hasValue = inputs.map(() => false);\r\n    // Flipped true when we have at least one value from all other sources and\r\n    // we are ready to start emitting values.\r\n    let ready = false;\r\n\r\n    // Other sources. Note that here we are not checking `subscriber.closed`,\r\n    // this causes all inputs to be subscribed to, even if nothing can be emitted\r\n    // from them. This is an important distinction because subscription constitutes\r\n    // a side-effect.\r\n    for (let i = 0; i < len; i++) {\r\n      innerFrom(inputs[i]).subscribe(\r\n        createOperatorSubscriber(\r\n          subscriber,\r\n          (value) => {\r\n            otherValues[i] = value;\r\n            if (!ready && !hasValue[i]) {\r\n              // If we're not ready yet, flag to show this observable has emitted.\r\n              hasValue[i] = true;\r\n              // Intentionally terse code.\r\n              // If all of our other observables have emitted, set `ready` to `true`,\r\n              // so we know we can start emitting values, then clean up the `hasValue` array,\r\n              // because we don't need it anymore.\r\n              (ready = hasValue.every(identity)) && (hasValue = null!);\r\n            }\r\n          },\r\n          // Completing one of the other sources has\r\n          // no bearing on the completion of our result.\r\n          noop\r\n        )\r\n      );\r\n    }\r\n\r\n    // Source subscription\r\n    source.subscribe(\r\n      createOperatorSubscriber(subscriber, (value) => {\r\n        if (ready) {\r\n          // We have at least one value from the other sources. Go ahead and emit.\r\n          const values = [value, ...otherValues];\r\n          subscriber.next(project ? project(...values) : values);\r\n        }\r\n      })\r\n    );\r\n  });\r\n}\r\n", "import { OperatorFunction, ObservableInput } from '../types';\r\nimport { zip } from '../observable/zip';\r\nimport { joinAllInternals } from './joinAllInternals';\r\n\r\n/**\r\n * Collects all observable inner sources from the source, once the source completes,\r\n * it will subscribe to all inner sources, combining their values by index and emitting\r\n * them.\r\n *\r\n * @see {@link zipWith}\r\n * @see {@link zip}\r\n */\r\nexport function zipAll<T>(): OperatorFunction<ObservableInput<T>, T[]>;\r\nexport function zipAll<T>(): OperatorFunction<any, T[]>;\r\nexport function zipAll<T, R>(project: (...values: T[]) => R): OperatorFunction<ObservableInput<T>, R>;\r\nexport function zipAll<R>(project: (...values: Array<any>) => R): OperatorFunction<any, R>;\r\n\r\nexport function zipAll<T, R>(project?: (...values: T[]) => R) {\r\n  return joinAllInternals(zip, project);\r\n}\r\n", "import { zip as zipStatic } from '../observable/zip';\r\nimport { ObservableInput, ObservableInputTuple, OperatorFunction, Cons } from '../types';\r\nimport { operate } from '../util/lift';\r\n\r\n/** @deprecated Replaced with {@link zipWith}. Will be removed in v8. */\r\nexport function zip<T, A extends readonly unknown[]>(otherInputs: [...ObservableInputTuple<A>]): OperatorFunction<T, Cons<T, A>>;\r\n/** @deprecated Replaced with {@link zipWith}. Will be removed in v8. */\r\nexport function zip<T, A extends readonly unknown[], R>(\r\n  otherInputsAndProject: [...ObservableInputTuple<A>],\r\n  project: (...values: Cons<T, A>) => R\r\n): OperatorFunction<T, R>;\r\n/** @deprecated Replaced with {@link zipWith}. Will be removed in v8. */\r\nexport function zip<T, A extends readonly unknown[]>(...otherInputs: [...ObservableInputTuple<A>]): OperatorFunction<T, Cons<T, A>>;\r\n/** @deprecated Replaced with {@link zipWith}. Will be removed in v8. */\r\nexport function zip<T, A extends readonly unknown[], R>(\r\n  ...otherInputsAndProject: [...ObservableInputTuple<A>, (...values: Cons<T, A>) => R]\r\n): OperatorFunction<T, R>;\r\n\r\n/**\r\n * @deprecated Replaced with {@link zipWith}. Will be removed in v8.\r\n */\r\nexport function zip<T, R>(...sources: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, any> {\r\n  return operate((source, subscriber) => {\r\n    zipStatic(source as ObservableInput<any>, ...(sources as Array<ObservableInput<any>>)).subscribe(subscriber);\r\n  });\r\n}\r\n", "import { ObservableInputTuple, OperatorFunction, Cons } from '../types';\r\nimport { zip } from './zip';\r\n\r\n/**\r\n * Subscribes to the source, and the observable inputs provided as arguments, and combines their values, by index, into arrays.\r\n *\r\n * What is meant by \"combine by index\": The first value from each will be made into a single array, then emitted,\r\n * then the second value from each will be combined into a single array and emitted, then the third value\r\n * from each will be combined into a single array and emitted, and so on.\r\n *\r\n * This will continue until it is no longer able to combine values of the same index into an array.\r\n *\r\n * After the last value from any one completed source is emitted in an array, the resulting observable will complete,\r\n * as there is no way to continue \"zipping\" values together by index.\r\n *\r\n * Use-cases for this operator are limited. There are memory concerns if one of the streams is emitting\r\n * values at a much faster rate than the others. Usage should likely be limited to streams that emit\r\n * at a similar pace, or finite streams of known length.\r\n *\r\n * In many cases, authors want `combineLatestWith` and not `zipWith`.\r\n *\r\n * @param otherInputs other observable inputs to collate values from.\r\n * @return A function that returns an Observable that emits items by index\r\n * combined from the source Observable and provided Observables, in form of an\r\n * array.\r\n */\r\nexport function zipWith<T, A extends readonly unknown[]>(...otherInputs: [...ObservableInputTuple<A>]): OperatorFunction<T, Cons<T, A>> {\r\n  return zip(...otherInputs);\r\n}\r\n"],
  "mappings": "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",
  "names": ["ConnectableObservable", "timestamp", "timestamp", "Subject", "observable", "AnonymousSubject", "BehaviorSubject", "ReplaySubject", "last", "AsyncSubject", "Action", "delay", "timeout", "AsyncAction", "delay", "AsapAction", "delay", "Scheduler", "delay", "AsyncScheduler", "AsapScheduler", "QueueAction", "delay", "QueueScheduler", "AnimationFrameAction", "delay", "AnimationFrameScheduler", "VirtualTimeScheduler", "VirtualAction", "delay", "delay", "repeat", "delay", "delay", "iterator", "iterator", "NotificationKind", "Notification", "config", "config", "config", "first", "delay", "_i", "isArray", "i", "expand", "buffer", "config", "sourceIndex", "_a", "isArray", "i", "count", "sourceIndex", "buffer", "count", "buffer", "buffer", "buffer", "buffer", "combineLatest", "combineLatest", "concat", "concat", "DEFAULT_CONFIG", "config", "count", "first", "findIndex", "count", "buffer", "last", "merge", "merge", "windowTime", "count", "delay", "config", "count", "delay", "buffer", "refCount", "windowTime", "refCount", "count", "_a", "config", "config", "last", "interval", "TimeInterval", "first", "count", "window", "_a", "window", "window", "i", "zip", "zip"]
}
