{
  "version": 3,
  "sources": ["../../rxjs/src/internal/observable/dom/fetch.ts"],
  "sourcesContent": ["import { createOperatorSubscriber } from '../../operators/OperatorSubscriber';\r\nimport { Observable } from '../../Observable';\r\nimport { innerFrom } from '../../observable/innerFrom';\r\nimport { ObservableInput } from '../../types';\r\n\r\nexport function fromFetch<T>(\r\n  input: string | Request,\r\n  init: RequestInit & {\r\n    selector: (response: Response) => ObservableInput<T>;\r\n  }\r\n): Observable<T>;\r\n\r\nexport function fromFetch(input: string | Request, init?: RequestInit): Observable<Response>;\r\n\r\n/**\r\n * Uses [the Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) to\r\n * make an HTTP request.\r\n *\r\n * **WARNING** Parts of the fetch API are still experimental. `AbortController` is\r\n * required for this implementation to work and use cancellation appropriately.\r\n *\r\n * Will automatically set up an internal [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)\r\n * in order to finalize the internal `fetch` when the subscription tears down.\r\n *\r\n * If a `signal` is provided via the `init` argument, it will behave like it usually does with\r\n * `fetch`. If the provided `signal` aborts, the error that `fetch` normally rejects with\r\n * in that scenario will be emitted as an error from the observable.\r\n *\r\n * ## Examples\r\n *\r\n * Basic use\r\n *\r\n * ```ts\r\n * import { fromFetch } from 'rxjs/fetch';\r\n * import { switchMap, of, catchError } from 'rxjs';\r\n *\r\n * const data$ = fromFetch('https://api.github.com/users?per_page=5').pipe(\r\n *   switchMap(response => {\r\n *     if (response.ok) {\r\n *       // OK return data\r\n *       return response.json();\r\n *     } else {\r\n *       // Server is returning a status requiring the client to try something else.\r\n *       return of({ error: true, message: `Error ${ response.status }` });\r\n *     }\r\n *   }),\r\n *   catchError(err => {\r\n *     // Network or other error, handle appropriately\r\n *     console.error(err);\r\n *     return of({ error: true, message: err.message })\r\n *   })\r\n * );\r\n *\r\n * data$.subscribe({\r\n *   next: result => console.log(result),\r\n *   complete: () => console.log('done')\r\n * });\r\n * ```\r\n *\r\n * ### Use with Chunked Transfer Encoding\r\n *\r\n * With HTTP responses that use [chunked transfer encoding](https://tools.ietf.org/html/rfc7230#section-3.3.1),\r\n * the promise returned by `fetch` will resolve as soon as the response's headers are\r\n * received.\r\n *\r\n * That means the `fromFetch` observable will emit a `Response` - and will\r\n * then complete - before the body is received. When one of the methods on the\r\n * `Response` - like `text()` or `json()` - is called, the returned promise will not\r\n * resolve until the entire body has been received. Unsubscribing from any observable\r\n * that uses the promise as an observable input will not abort the request.\r\n *\r\n * To facilitate aborting the retrieval of responses that use chunked transfer encoding,\r\n * a `selector` can be specified via the `init` parameter:\r\n *\r\n * ```ts\r\n * import { of } from 'rxjs';\r\n * import { fromFetch } from 'rxjs/fetch';\r\n *\r\n * const data$ = fromFetch('https://api.github.com/users?per_page=5', {\r\n *   selector: response => response.json()\r\n * });\r\n *\r\n * data$.subscribe({\r\n *   next: result => console.log(result),\r\n *   complete: () => console.log('done')\r\n * });\r\n * ```\r\n *\r\n * @param input The resource you would like to fetch. Can be a url or a request object.\r\n * @param initWithSelector A configuration object for the fetch.\r\n * [See MDN for more details](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\r\n * @returns An Observable, that when subscribed to, performs an HTTP request using the native `fetch`\r\n * function. The {@link Subscription} is tied to an `AbortController` for the fetch.\r\n */\r\nexport function fromFetch<T>(\r\n  input: string | Request,\r\n  initWithSelector: RequestInit & {\r\n    selector?: (response: Response) => ObservableInput<T>;\r\n  } = {}\r\n): Observable<Response | T> {\r\n  const { selector, ...init } = initWithSelector;\r\n  return new Observable<Response | T>((subscriber) => {\r\n    // Our controller for aborting this fetch.\r\n    // Any externally provided AbortSignal will have to call\r\n    // abort on this controller when signaled, because the\r\n    // signal from this controller is what is being passed to `fetch`.\r\n    const controller = new AbortController();\r\n    const { signal } = controller;\r\n    // This flag exists to make sure we don't `abort()` the fetch upon tearing down\r\n    // this observable after emitting a Response. Aborting in such circumstances\r\n    // would also abort subsequent methods - like `json()` - that could be called\r\n    // on the Response. Consider: `fromFetch().pipe(take(1), mergeMap(res => res.json()))`\r\n    let abortable = true;\r\n\r\n    // If the user provided an init configuration object,\r\n    // let's process it and chain our abort signals, if necessary.\r\n    // If a signal is provided, just have it finalized. It's a cancellation token, basically.\r\n    const { signal: outerSignal } = init;\r\n    if (outerSignal) {\r\n      if (outerSignal.aborted) {\r\n        controller.abort();\r\n      } else {\r\n        // We got an AbortSignal from the arguments passed into `fromFetch`.\r\n        // We need to wire up our AbortController to abort when this signal aborts.\r\n        const outerSignalHandler = () => {\r\n          if (!signal.aborted) {\r\n            controller.abort();\r\n          }\r\n        };\r\n        outerSignal.addEventListener('abort', outerSignalHandler);\r\n        subscriber.add(() => outerSignal.removeEventListener('abort', outerSignalHandler));\r\n      }\r\n    }\r\n\r\n    // The initialization object passed to `fetch` as the second\r\n    // argument. This ferries in important information, including our\r\n    // AbortSignal. Create a new init, so we don't accidentally mutate the\r\n    // passed init, or reassign it. This is because the init passed in\r\n    // is shared between each subscription to the result.\r\n    const perSubscriberInit: RequestInit = { ...init, signal };\r\n\r\n    const handleError = (err: any) => {\r\n      abortable = false;\r\n      subscriber.error(err);\r\n    };\r\n\r\n    fetch(input, perSubscriberInit)\r\n      .then((response) => {\r\n        if (selector) {\r\n          // If we have a selector function, use it to project our response.\r\n          // Note that any error that comes from our selector will be\r\n          // sent to the promise `catch` below and handled.\r\n          innerFrom(selector(response)).subscribe(\r\n            createOperatorSubscriber(\r\n              subscriber,\r\n              // Values are passed through to the subscriber\r\n              undefined,\r\n              // The projected response is complete.\r\n              () => {\r\n                abortable = false;\r\n                subscriber.complete();\r\n              },\r\n              handleError\r\n            )\r\n          );\r\n        } else {\r\n          abortable = false;\r\n          subscriber.next(response);\r\n          subscriber.complete();\r\n        }\r\n      })\r\n      .catch(handleError);\r\n\r\n    return () => {\r\n      if (abortable) {\r\n        controller.abort();\r\n      }\r\n    };\r\n  });\r\n}\r\n"],
  "mappings": ";;;;;;;;;AA8FM,SAAU,UACd,OACA,kBAEM;AAFN,MAAA,qBAAA,QAAA;AAAA,uBAAA,CAAA;EAEM;AAEE,MAAA,WAAsB,iBAAgB,UAAzB,OAAI,OAAK,kBAAxB,CAAA,UAAA,CAAqB;AAC3B,SAAO,IAAI,WAAyB,SAAC,YAAU;AAK7C,QAAM,aAAa,IAAI,gBAAe;AAC9B,QAAA,SAAW,WAAU;AAK7B,QAAI,YAAY;AAKR,QAAQ,cAAgB,KAAI;AACpC,QAAI,aAAa;AACf,UAAI,YAAY,SAAS;AACvB,mBAAW,MAAK;aACX;AAGL,YAAM,uBAAqB,WAAA;AACzB,cAAI,CAAC,OAAO,SAAS;AACnB,uBAAW,MAAK;;QAEpB;AACA,oBAAY,iBAAiB,SAAS,oBAAkB;AACxD,mBAAW,IAAI,WAAA;AAAM,iBAAA,YAAY,oBAAoB,SAAS,oBAAkB;QAA3D,CAA4D;;;AASrF,QAAM,oBAAiB,SAAA,SAAA,CAAA,GAAqB,IAAI,GAAA,EAAE,OAAM,CAAA;AAExD,QAAM,cAAc,SAAC,KAAQ;AAC3B,kBAAY;AACZ,iBAAW,MAAM,GAAG;IACtB;AAEA,UAAM,OAAO,iBAAiB,EAC3B,KAAK,SAAC,UAAQ;AACb,UAAI,UAAU;AAIZ,kBAAU,SAAS,QAAQ,CAAC,EAAE,UAC5B,yBACE,YAEA,QAEA,WAAA;AACE,sBAAY;AACZ,qBAAW,SAAQ;QACrB,GACA,WAAW,CACZ;aAEE;AACL,oBAAY;AACZ,mBAAW,KAAK,QAAQ;AACxB,mBAAW,SAAQ;;IAEvB,CAAC,EACA,MAAM,WAAW;AAEpB,WAAO,WAAA;AACL,UAAI,WAAW;AACb,mBAAW,MAAK;;IAEpB;EACF,CAAC;AACH;",
  "names": []
}
